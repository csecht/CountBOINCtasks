#!/usr/bin/env python3

"""
gcount-tasks provides task counts and time statistics at timed
intervals for tasks recently reported to BOINC servers. It can be run
on Windows, Linux, and MacOS. It is the tkinter GUI version of
count-tasks. The MVC architecture it uses is based on the example
provided by by Brian Oakley at
https://stackoverflow.com/questions/32864610/
Requires Python 3.6 or later and tkinter (tk/tcl) 8.6 or later.

    Copyright (C) 2021 C. Echt

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see https://www.gnu.org/licenses/.
"""
# ^^ Text for --about invocation argument and __doc__>>
__author__ = 'cecht, BOINC ID: 990821'
__copyright__ = 'Copyright (C) 2021 C.S. Echt'
__credits__ = 'Inspired by rickslab-gpu-utils'
__license__ = 'GNU General Public License'
__version__ = '0.5.21'
__program_name__ = 'gcount-tasks'
__project_url__ = 'https://github.com/csecht/CountBOINCtasks'
__maintainer__ = 'cecht'
__docformat__ = 'reStructuredText'
__status__ = 'Development Status :: 2 - Beta'

import argparse
import logging
import random
import re
import shutil
import statistics as stats
import sys
import threading
import time
from datetime import datetime
from pathlib import Path
from platform import node

from COUNTmodules import boinc_command, time_convert

try:
    import tkinter as tk
    from tkinter import messagebox, ttk
    from tkinter.scrolledtext import ScrolledText
except (ImportError, ModuleNotFoundError) as error:
    print('gcount-tasks requires tkinter, which is included with \n'
          'Python 3.7+ distributions.\n'
          'Install the most recent version or re-install Python and include Tk/Tcl.\n'
          '\nOn Linux, you may also need: $ sudo apt-get install python3-tk\n'
          f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

if sys.version_info < (3, 6):
    print('Sorry, but running gcount-tasks requires Python 3.6 or later.\n'
          'Current Python version: '
          f'{sys.version_info.major}.{sys.version_info.minor}\n'
          'Python downloads are available from https://docs.python.org/')
    sys.exit(1)

BC = boinc_command.BoincCommand()
TC = time_convert
MY_OS = sys.platform[:3]
GUI_TITLE = 'BOINC task counter'
SHORT_STRFTIME = '%Y %b %d %H:%M'
LONG_STRFTIME = '%Y-%b-%d %H:%M:%S'
DAY_STRFTIME = '%A %H:%M'
LONGSMRY_STRF = '%b %d %H:%M'
# Log file or its link should be in the CountBOINCtasks-master folder.
#  But use .resolve() to handle symlinks.
LOGFILE = Path('count-tasks_log.txt').resolve()
BKUPFILE = Path('count-tasks_log(copy).txt').resolve()
NOTICE_INTERVAL = 15  # <- time.sleep() seconds

# Use this for an immediate exit from Terminal; bypasses __name__ KeyInterrupt msg.
# signal.signal(signal.SIGINT, signal.SIG_DFL)


# ################# Useful functions not part of MVC ###################
def check_boinc():
    """
    Check whether BOINC client is running before proceeding to implement
    settings and begin counting.
    """
    # Note: Any BC boinccmd will return this string (in a list)
    #   if boinc-client is not running; use BC.get_version() b/c it is short.
    if "can't connect to local host" in BC.get_version():
        okay = messagebox.askokcancel(
            title='BOINC ERROR',
            detail='BOINC commands cannot be executed.\n'
                   'Is the BOINC client running?\nExiting now...')
        if okay:
            app.destroy()
            sys.exit(1)
        else:
            app.destroy()
            sys.exit(1)


def app_position(add_x=0, add_y=0) -> tuple:
    """
    Get position of the app (MASTER) window.
    Use to set position of a Toplevel child with respect to app.

    :param add_x: optional pixels added to app's x coordinate.
    :param add_y: optional pixels added to app's y coordinate.
    :return: x,y screen geometry coordinates of the app window.
    :rtype: tuple
    """
    app.update_idletasks()
    pos_x = app.winfo_x() + add_x
    pos_y = app.winfo_y() + add_y
    return pos_x, pos_y


def eval_digit_entry(entry_string, action_type) -> bool:
    """
    Only digits are accepted and displayed in Entry field.
    Used with .register() to configure Entry kw validatecommand.

    :param entry_string: value entered into an Entry() widget.
    :param action_type: edit action code.
    :return: True, False
    :rtype: bool
    """
    # Need to restrict entries to only digits,
    #   MUST use action type parameter to allow user to delete first number
    #   entered when wants to re-enter following backspace deletion.
    # source: https://stackoverflow.com/questions/4140437/
    # %P = value of the entry if the edit is allowed
    # Desired action type 1 is "insert", %d.
    if action_type == '1':
        if not entry_string.isdigit():
            return False
    return True


def ttimes_stats(numtasks: int, tasktimes: iter) -> dict:
    """
    Sum and run statistics of BOINC task times.
    Called from Modeler. Calls to time_convert.sec_to_format().

    :param numtasks: The number of elements in tasktimes.
    :param tasktimes: A list, tuple, or set of times, in seconds as
                      integers or floats.
    :return: Dict keys: tt_total, tt_mean, tt_sd, tt_min, tt_max;
             Dict values as: 00:00:00.
    :rtype: dict
    """
    total = TC.sec_to_format(int(sum(tasktimes)), 'std')
    if numtasks > 1:
        mean = TC.sec_to_format(int(stats.mean(tasktimes)), 'std')
        stdev = TC.sec_to_format(int(stats.stdev(tasktimes)), 'std')
        low = TC.sec_to_format(int(min(tasktimes)), 'std')
        high = TC.sec_to_format(int(max(tasktimes)), 'std')
        return {
            'tt_total': total,
            'tt_mean': mean,
            'tt_sd': stdev,
            'tt_min': low,
            'tt_max': high}
    if numtasks == 1:
        return {
            'tt_total': total,
            'tt_mean': total,
            'tt_sd': 'na',
            'tt_min': 'na',
            'tt_max': 'na'}
    # numtasks is 0...
    return {
        'tt_total': '00:00:00',
        'tt_mean': '00:00:00',
        'tt_sd': 'na',
        'tt_min': 'na',
        'tt_max': 'na'}


# pylint: disable=unused-argument
def view_log(event=None) -> None:
    """
    Create a separate window to view the log file as scrolled text.
    Called from File menu bar or keybinding.

    :param event: Needed for keybinding implicit event.
    """
    os_width = 0
    if MY_OS in 'lin, win':
        os_width = 79
    elif MY_OS == 'dar':
        os_width = 72

    try:
        with open(LOGFILE) as file:
            logwin = tk.Toplevel(app, bg='SteelBlue4')  # <- bg = master_bg
            logwin.title(f'{LOGFILE}, {node()}')
            if MY_OS in 'lin, dar':
                logwin.minsize(800, 220)
            elif MY_OS == 'win':
                logwin.minsize(800, 200)
            logwin.focus_set()
            # Use a "dark" background/foreground theme for log text.
            logtext = ScrolledText(logwin, width=os_width, height=30,
                                   font='TkFixedFont', fg='grey80', bd=4,
                                   bg='grey20', relief='groove', padx=12)
            logtext.insert(tk.INSERT, file.read())
            logtext.see('end')
            logtext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

            def update():
                """Replace log window text with log file content.
                """
                with open(LOGFILE) as new_text:
                    logtext.delete('1.0', tk.END)
                    logtext.insert('1.0', new_text.read())
                    logtext.see(tk.END)
                    logtext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

            def erase():
                """Delete log file content and log window text.
                """
                okay = messagebox.askokcancel(
                    parent=logwin,
                    title='Confirmation needed',
                    message='Delete log file content?',
                    detail="'Enter' or space bar will also delete log file content.")
                if okay:
                    # pylint: disable=consider-using-with
                    open(LOGFILE, 'w').close()
                    logtext.delete('1.0', tk.END)

            ttk.Button(logwin, text='Update', command=update).pack()
            ttk.Button(logwin, text='Erase', command=erase).pack()
            ttk.Button(logwin, text='Analysis', command=show_cumulative_data).pack(padx=4)
    except FileNotFoundError:
        info = (f'On {node()}, this file is missing:\n{LOGFILE}\n'
                'Was the settings log option used?\n'
                'Was file deleted, moved or renamed?')
        messagebox.showerror(title='FILE NOT FOUND', detail=info)


def backup_log() -> None:
    """
    Copy the log file to the current folder; overwrites previous
    back-up file.
    Called from File menu bar.
    """
    # Could make this an outside function with backupfile and logfile as
    #  arguments, but that would require import of partial from functools
    #  to call it as a command from its menu bar object, its only call.
    destination = Path.home() / BKUPFILE
    if Path.is_file(LOGFILE):
        try:
            shutil.copyfile(LOGFILE, destination)
            success_msg = 'Log file has been copied to: '
            success_detail = str(destination)
            messagebox.showinfo(title='Backup completed',
                                message=success_msg, detail=success_detail)
        except PermissionError:
            messagebox.showinfo(title='Log copy error',
                                message="Permission denied")
            print("Log file backup: Permission denied.")
        except IsADirectoryError:
            messagebox.showinfo(title='Log copy error',
                                message="Backup file name is a directory")
            print("Log file backup: Destination file is a directory.")
        except shutil.SameFileError:
            messagebox.showinfo(
                title='Log copy error',
                message="Source and destination are the same file")
            print("Log file backup: Source and destination are the same file.")
    else:
        warn_main = f'Log {LOGFILE} cannot be archived'
        warn_detail = ('Log file should be in folder:\n'
                       f'{Path.cwd()}\n'
                       'Has it been moved or renamed?')
        messagebox.showwarning(title='FILE NOT FOUND',
                               message=warn_main, detail=warn_detail)


def cumulative_data() -> tuple:
    """
    Reads log file and analyses Summary and Interval counts.
    Calls to show_cumulative_data().

    :return: text strings to print in show_cumulative_data()
             Toplevel window.
    """
    sumry_dates = []
    summary_intvls = []
    num_uniq_sumintvls = 0
    sumry_counts = []
    sumry_cnt_avg = 0
    sumry_cnt_range = ''
    intvl_dates = []
    reg_intvls = []
    num_uniq_intvls = 0
    intvl_counts = []
    intvl_cnt_avg = 0
    intvl_cnt_range = ''
    recent_dates = []
    recent_counts = []
    recent_intvls = []
    sumry_analysis = ''
    mop_up = ''

    try:
        with open(LOGFILE) as file:
            logtext = file.read()
    except FileNotFoundError:
        info = (f'On {node()}, this file is missing:\n{LOGFILE}\n'
                'Was the settings log option used?\n'
                'Was file deleted, moved or renamed?')
        messagebox.showerror(title='FILE NOT FOUND', detail=info)
        return sumry_analysis, mop_up

    # Need a match to summary lines in log, like this:
    #   2021-Oct-28 08:37:34; >>> SUMMARY: Count for the past 1d: 330
    #   and to regular interval lines, like this:
    #   2021-Oct-28 09:37:33; Tasks reported in the past 60m: 17
    #   The line formats are specified in CountModeler.log_it().
    capture_sumrys = re.findall(
        r'^(.*); >>> SUMMARY: .* (\d+[mhd]): (\d+$)', logtext, re.MULTILINE)
    capture_intvls = re.findall(
        r'^(.*); Tasks reported .* (\d+m): (\d+$)', logtext, re.MULTILINE)

    if capture_sumrys:
        sumry_dates, summary_intvls, sumry_cnts = zip(*capture_sumrys)
        num_uniq_sumintvls = len(set(summary_intvls))
        sumry_counts = list(map(int, sumry_cnts))
        sumry_cnt_avg = round(sum(sumry_counts) / len(sumry_counts), 1)
        sumry_cnt_range = f'[{min(sumry_counts)} -- {max(sumry_counts)}]'
    # Need these intvl vars when there are no summary data.
    if capture_intvls:
        intvl_dates, reg_intvls, intvl_cnts = zip(*capture_intvls)
        num_uniq_intvls = len(set(reg_intvls))
        intvl_counts = list(map(int, intvl_cnts))
        intvl_cnt_avg = round(sum(intvl_counts) / len(intvl_counts), 1)
        intvl_cnt_range = f'[{min(intvl_counts)} -- {max(intvl_counts)}]'
    # Need these interval vars when there are interval counts following last summary.
    #    But need only interval data following the last summary count.
    if capture_sumrys and capture_intvls:
        # Need the list index of first interval count after the last summary count.
        indicies = [
            i for i, tupl in enumerate(capture_intvls) if sumry_dates[-1] == tupl[0]]
        recent_dates, recent_intvls, recent_cnts = zip(*capture_intvls[indicies[0]:])
        num_uniq_intvls = len(set(recent_intvls))
        recent_counts = list(map(int, recent_cnts))
        intvl_cnt_avg = round(sum(recent_counts) / len(recent_counts), 1)
        intvl_cnt_range = f'[{min(recent_counts)} -- {max(recent_counts)}]'

    # Need to tailor report texts for various counting conditions.
    if not capture_sumrys and not capture_intvls:
        sumry_analysis = ('There are not enough data to analyze.\n'
                          '    Need at least one summary or one\n'
                          '    interval count in the log file.\n')
    if not capture_sumrys and capture_intvls:
        sumry_analysis = 'No summary counts are logged yet.\n'
        if num_uniq_intvls == 1:
            mop_up = (
                'Analysis of logged task counts from:\n'
                f'{intvl_dates[0]} to {intvl_dates[-1]}\n\n'
                f'   {len(intvl_counts)} intervals have been logged.\n'
                f'   {sum(intvl_counts)} reported tasks\n'
                f'   {intvl_cnt_avg} tasks per {reg_intvls[-1]} interval\n'
                f'   {intvl_cnt_range} range of task counts\n')
        else:
            mop_up = (
                'Analysis of logged task counts from:\n'
                f'{intvl_dates[0]} to {intvl_dates[-1]}\n\n'
                f'There are {num_uniq_intvls} different interval times\n'
                f'logged, {set(reg_intvls)},\n'
                'so results may be inaccurate.\n\n'
                f'   {len(intvl_counts)} count intervals have been logged.\n'
                f'   {sum(intvl_counts)} reported tasks\n'
                f'   {intvl_cnt_avg} tasks per {num_uniq_intvls} interval\n'
                f'   {intvl_cnt_range} range of task counts\n')
    if capture_sumrys:
        if num_uniq_sumintvls == 1:
            sumry_analysis = (
                'Summary data in the log file from:\n'
                f'{sumry_dates[0]} to {sumry_dates[-1]}\n\n'
                f'   {len(sumry_counts)} summaries logged\n'
                f'   {sum(sumry_counts)} reported tasks\n'
                f'   {sumry_cnt_avg} tasks per {summary_intvls[-1]} summary interval\n'
                f'   {sumry_cnt_range} range of summary counts\n')
        else:
            sumry_analysis = (
                'Summary data in the log file from:\n'
                f'{sumry_dates[0]} to {sumry_dates[-1]}\n\n'
                f'There are {num_uniq_sumintvls} different logged Summary\n'
                f' interval times, {set(summary_intvls)},\n'
                'so results may be inaccurate.\n\n'
                f'   {len(sumry_counts)} summaries logged\n'
                f'   {sum(sumry_counts)} reported tasks\n'
                f'   {sumry_cnt_avg} tasks per summary\n'
                f'   {sumry_cnt_range} range of summary counts\n')
    if capture_sumrys and capture_intvls:
        if num_uniq_intvls == 1:
            mop_up = (
                '\nSince last Summary, interval counts from:\n'
                f'{recent_dates[0]} to {recent_dates[-1]}\n\n'
                f'   {len(recent_counts)} interval counts were logged.\n'
                f'   {sum(recent_counts)} reported tasks\n'
                f'   {intvl_cnt_avg} tasks per {recent_intvls[0]} interval\n'
                f'   {intvl_cnt_range} range of interval counts\n')
        else:
            mop_up = (
                'Since last Summary, interval counts from:\n'
                f'{recent_dates[0]} to {recent_dates[-1]}\n\n'
                f'There are {num_uniq_intvls} different logged\n'
                f' interval times, {set(recent_intvls)},\n'
                'so results may be inaccurate.\n\n'
                f'   {len(intvl_counts)} count intervals have been logged.\n'
                f'   {sum(intvl_counts)} reported tasks\n'
                f'   {intvl_cnt_avg} tasks per interval\n'
                f'   {intvl_cnt_range} range of interval counts\n')

    return sumry_analysis, mop_up


def show_cumulative_data(event=None) -> None:
    """
    Generates a Toplevel window to display cumulative task counts that
    have been logged.
    Called from a view_log() button or a keybinding.
    Provides option to append results to a file.

    :param event: Needed for keybinding implicit event.
    """

    # NOTE: When the log file is not found by cumulative_data(), the returned
    #   texts will be empty, so there is no need to continue with function.
    summary_text, interval_text = cumulative_data()
    if not summary_text and not interval_text:
        return
    pos_x, pos_y = app_position(15, 15)
    analysiswin = tk.Toplevel(bg='SteelBlue4')  # <- bg = master_bg)
    analysiswin.title('Analysis of logged data')
    analysiswin.geometry(f'+{pos_x}+{+pos_y}')
    analysiswin.minsize(400, 150)
    analysiswin.focus_set()

    # Separator dashes from https://coolsymbol.com/line-symbols.html.
    sep = '─────────────────────────────────────────────\n'
    text = summary_text + interval_text + sep
    num_lines = text.count('\n') + 1
    analysistext = tk.Text(analysiswin, font='TkFixedFont',
                           width=46, height=num_lines,
                           background='grey85', foreground='grey5',
                           relief='groove', borderwidth=4,
                           padx=15, pady=10)
    analysistext.insert(1.0, text)
    analysistext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

    def save_results():
        destination = Path('cumulative_analysis.txt').resolve()
        savetxt = analysistext.get(1.0, tk.END)
        with open(destination, 'a', encoding='utf-8') as saved_analysis:
            saved_analysis.write(savetxt)
        messagebox.showinfo(message='Results saved to:',
                            detail=destination,
                            parent=analysiswin)
    ttk.Button(
        analysiswin, text='Save results', command=save_results).pack(padx=4)


# ############################ MVC Classes #############################
# MVC Modeler: The engine that gets BOINC data and runs count intervals.
class CountModeler:
    """
    Counting, statistical analysis, and formatting of BOINC task data.
    """
    # Need to have ttimes_used not in __init__ where it will be reset when
    #   set_interval_data is called. ttimes_smry is OK in __init__, but
    #   in here as a Class attribute for clarity. Is there a better way?
    ttimes_used = set()
    ttimes_smry = set()

    def __init__(self, share):
        self.share = share
        self.thread_lock = threading.Lock()
        self.proj_stalled = False
        self.task_count_start = 0
        self.task_count_new = 0

    def default_settings(self) -> None:
        """Set or reset default run parameters in the setting dictionary.
        """
        self.share.setting['interval_t'].set('60m')
        self.share.setting['interval_m'].set(60)
        self.share.setting['summary_t'].set('1d')
        self.share.setting['sumry_t_value'].set(1)
        self.share.setting['sumry_t_unit'].set('day')
        self.share.setting['cycles_max'].set(1008)
        self.share.setting['do_log'].set(True)
        self.share.setting['proj_update'].set(False)

    def set_start_data(self):
        """
        Gather initial task data and times; set data dictionary
        control variables. Log data to file if so optioned.
        Called from check_and_start().
        """
        # As with task names, task times as sec.microsec are unique.
        #   In future, may want to inspect task names with
        #     tnames = BC.get_reported('tasks').
        ttimes_start = BC.get_reported('elapsed time')
        self.share.data['task_count'].set(len(ttimes_start))
        self.share.data['num_tasks_all'].set(len(BC.get_tasks('name')))

        # Begin set of used/old tasks to exclude from new tasks;
        #   used in set_interval_data() to track tasks across intervals.
        self.ttimes_used.update(ttimes_start)

        # Need to parse data returned from ttimes_stats().
        startdict = ttimes_stats(
            self.share.data['task_count'].get(), ttimes_start)
        self.share.data['tt_mean'].set(startdict['tt_mean'])
        self.share.data['tt_sd'].set(startdict['tt_sd'])
        self.share.data['tt_range'].set(
            f"{startdict['tt_min']} -- {startdict['tt_max']}")
        self.share.data['tt_total'].set(startdict['tt_total'])

        self.share.data['time_prev_cnt'].set('Last hourly BOINC report.')

        if self.share.setting['do_log'].get():
            self.share.logit('start')

    def set_task_states(self) -> None:
        """
        Query boinc-client for status of tasks queued, running, and
        suspended; set corresponding dictionary tk control variables.
        Called from notice_it().
        """

        self.share.status_time = datetime.now().strftime(LONG_STRFTIME)
        tasks_all = BC.get_tasks('all')

        # Need the literal task data tags as found in boinccmd stdout;
        #   the format is same as tag_str in BC.get_tasks().
        #   Use tuple index to populate the list expressions.
        tags = ('   name: ',
                '   active_task_state: ',
                '   state: ')
        num_tasks_all = len([elem for elem in tasks_all if tags[0] in elem])
        tasks_active = [elem.replace(tags[1], '') for elem in tasks_all
                        if tags[1] in elem]
        task_states = [elem.replace(tags[2], '') for elem in tasks_all
                       if tags[2] in elem]
        # When communication to server is stalled, all tasks will be
        #  "Ready to report" with a state of 'uploaded', so a forced
        #   Project update in notice_it() may prompt finalizing
        #   the task upload.
        if 'uploaded' in task_states and 'downloaded' not in task_states:
            self.share.note['proj_stalled'].set(True)
        num_running = len(
            [task for task in tasks_active if 'EXECUTING' in task])
        num_suspended_by_boinc = len(
            [task for task in tasks_active if 'SUSPENDED' in task])
        num_suspended_by_user = len(
            [task for task in tasks_all if 'suspended via GUI: yes' in task])

        self.share.data['num_tasks_all'].set(num_tasks_all)
        self.share.note['num_running'].set(num_running)
        self.share.note['num_suspended_by_boinc'].set(num_suspended_by_boinc)
        self.share.note['num_suspended_by_user'].set(num_suspended_by_user)

    def set_interval_data(self) -> None:
        """
        Run timer and countdown clock to update and analyze regular and
        summary data for task status and times. Set control variables
        for data and note dictionaries.
        Is threaded as interval_thread; start in Viewer.start_threads()
        Calls to: ttimes_stats(), get_minutes() log_it().
        """
        ttimes_new = set()
        cycles_max = self.share.setting['cycles_max'].get()
        interval_m = self.share.setting['interval_m'].get()
        reference_time = time.time()
        tic_nnt = 0
        for cycle in range(cycles_max):
            if cycle == 1 or cycles_max == 1:
                # Need to change button name and function from Start to Interval
                #   after initial cycle[0] completes and intvl data displays.
                #  It might be better if statement were in Viewer, but simpler
                #  to put it here with easy reference to cycle.
                self.share.starting_b.grid_forget()
                self.share.intvl_b.grid(row=0, column=1,
                                        padx=(16, 0), pady=(8, 4))

            # Need to sleep between counts while displaying a countdown timer.
            # Need to limit total time of interval to target_elapsed_time,
            #   in Epoch seconds, b/c each interval sleep cycle will run longer
            #   than the intended interval. Realized interval time should not
            #   drift by more than 1 second during count_max cycles.
            # Without this time limit, each 60m interval would gain ~4s.
            interval_sec = interval_m * 60
            target_elapsed_time = reference_time + (interval_sec * (cycle + 1))
            for _sec in range(interval_sec):
                if cycle == cycles_max:
                    break
                if time.time() > target_elapsed_time:
                    self.share.data['time_next_cnt'].set('00:00')
                    break
                interval_sec -= 1
                # Need to show the time remaining in clock time format.
                self.share.data['time_next_cnt'].set(
                    TC.sec_to_format(interval_sec, 'clock'))
                time.sleep(1.0)

            # NOTE: Starting tasks are not included in interval and summary
            #   counts, but starting task times are used here to determine
            #   "new" tasks.
            # Need to add all prior tasks to the "used" set.
            #  "new" task times are carried over from the prior interval cycle.
            #  For cycle[0], ttimes_used is starting tasks from set_start_data()
            #    and ttimes_new is empty.
            with self.thread_lock:
                self.ttimes_used.update(ttimes_new)
                ttimes_reported = set(BC.get_reported('elapsed time'))

                # Need to reset prior ttimes_new, then repopulate it with only newly
                #   reported tasks.
                ttimes_new.clear()
                ttimes_new = ttimes_reported - self.ttimes_used

                task_count_new = len(ttimes_new)
                self.share.data['task_count'].set(task_count_new)
                # Add new tasks to summary set for later analysis.
                self.ttimes_smry.update(ttimes_new)

                cycles_remain = int(self.share.data['cycles_remain'].get()) - 1
                self.share.data['cycles_remain'].set(cycles_remain)
                # Display weekday with time of previous interval to aid the user.
                self.share.data['time_prev_cnt'].set(
                    datetime.now().strftime(DAY_STRFTIME))
                # Capture full ending time here, instead of in log_it(),
                #   so that the logged time matches displayed time.
                self.share.data['intvl_count_t'].set(
                    datetime.now().strftime(LONG_STRFTIME))

                # Track when no new tasks were reported in past interval;
                #   tic_nnt used in log_it().
                # Call is needed here to get current num_running value for eval.
                self.set_task_states()
                num_running = self.share.note['num_running'].get()
                if task_count_new == 0:
                    tic_nnt += 1
                elif task_count_new > 0 and num_running > 0:
                    tic_nnt = 0
                self.share.note['tic_nnt'].set(tic_nnt)

                # Need to parse data returned from ttimes_stats().
                intervaldict = ttimes_stats(task_count_new, ttimes_new)
                self.share.data['tt_mean'].set(intervaldict['tt_mean'])
                self.share.data['tt_sd'].set(intervaldict['tt_sd'])
                self.share.data['tt_range'].set(
                    f"{intervaldict['tt_min']} -- {intervaldict['tt_max']}")
                self.share.data['tt_total'].set(intervaldict['tt_total'])

                # SUMMARY DATA ####################################################
                # NOTE: Starting data are not included in summary tabulations.
                summary_m = TC.string_to_m(self.share.setting['summary_t'].get())
                # When summary interval is >= 1 week, need to provide date of
                #   prior summary rather than weekday, as above (%A %H:%M).
                if summary_m >= 10080:
                    self.share.data['time_prev_cnt'].set(
                        datetime.now().strftime(LONGSMRY_STRF))
                summary_time = self.share.data['time_prev_cnt'].get()
                if (cycle + 1) % (summary_m // interval_m) == 0 and num_running > 0:
                    # Flag used in log_it() to log summary data.
                    self.share.data['log_summary'].set(True)
                    # Need to activate disabled Summary data button now; only need
                    #  statement for 1st summary, but, oh well, here we go again...
                    self.share.sumry_b.config(state=tk.NORMAL)

                    # Display time and stats of summary count.
                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(len(self.ttimes_smry))
                    summarydict = ttimes_stats(
                        len(self.ttimes_smry), self.ttimes_smry)
                    self.share.data['tt_mean_sumry'].set(summarydict['tt_mean'])
                    self.share.data['tt_sd_sumry'].set(summarydict['tt_sd'])
                    self.share.data['tt_range_sumry'].set(
                        f"{summarydict['tt_min']} -- {summarydict['tt_max']}")
                    self.share.data['tt_total_sumry'].set(summarydict['tt_total'])

                    # Need to reset data set for the next summary interval.
                    self.ttimes_smry.clear()

            # Call to log_it() needs to be outside of the thread lock.
            app.update_idletasks()
            if self.share.setting['do_log'].get():
                self.share.logit('interval')

    def notice_it(self) -> None:
        """
        Notices for BOINC task state information should run on short
        time intervals.
        Is threaded as notice_thread; start in Viewer.start_threads().
        Calls to: set_task_states() and log_it().
        """
        while self.share.data['cycles_remain'].get() > 0:
            time.sleep(NOTICE_INTERVAL)
            with self.thread_lock:
                # Need to quit app if boinc-client is no longer running.
                check_boinc()

                self.set_task_states()
                num_running = self.share.note['num_running'].get()
                num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
                num_suspended_by_boinc = self.share.note['num_suspended_by_boinc'].get()
                num_tasks_all = self.share.data['num_tasks_all'].get()
                tic_nnt = self.share.note['tic_nnt'].get()
                proj_stalled = self.share.note['proj_stalled'].get()
                cycles_max = self.share.setting['cycles_max'].get()
                cycles_remain = self.share.data['cycles_remain'].get()
                interval_m = self.share.setting['interval_m'].get()

                # Need to change to notice fg color from "All is well" row_fg color.
                self.share.notice_l.config(fg=self.share.highlight)

                # Need notices for task status that might need user attention,
                #   conditioned in descending priority.
                if num_running > 0:
                    if num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'{num_suspended_by_user} tasks are suspended by user.\n'
                            'BOINC will not upload while tasks are suspended.')
                    elif num_running == num_tasks_all:
                        self.share.note['notice_txt'].set(
                            'BOINC client is about to run out of tasks.\n'
                            'Check BOINC Manager.')
                    elif tic_nnt > 0:
                        nnt_time = TC.sec_to_format(
                            (tic_nnt * interval_m * 60), 'short')
                        self.share.note['notice_txt'].set(
                            f'NO TASKS reported in past {nnt_time}\n'
                            f'for the prior {tic_nnt} counting interval(s).')
                    else:
                        # Everything is fine, remove any prior notice.
                        # Use a de-emhasized color for this non-notice status text.
                        self.share.notice_l.config(fg=self.share.row_fg)
                        self.share.note['notice_txt'].set(
                            f'All is well (updates every {NOTICE_INTERVAL} seconds)')

                if num_running == 0:
                    if proj_stalled:
                        if self.share.setting['proj_update'].get():
                            # Note: this will sleep notice_it() for 70 seconds.
                            self.update_project()
                        else:
                            self.share.note['notice_txt'].set(
                                'A PROJECT UPDATE MAY BE NEEDED.\n'
                                'Check BOINC Manager.')
                    elif num_tasks_all == 0:
                        self.share.note['notice_txt'].set(
                            'BOINC client has no tasks to run!\n'
                            'Check BOINC Manager.')
                    elif num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'NO TASKS running; {num_suspended_by_user} tasks suspended by user.\n'
                            'You may want to resume them.')
                    elif num_suspended_by_boinc > 0:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running.\n'
                            'A BOINC Manager "When to suspend" condition was met.\n'
                            'Edit BOINC Manager Computing preferences if this is a problem.')
                    else:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running. Is Project suspended?\nCheck BOINC Manager.')

                if cycles_remain == 0:
                    prior_note = self.share.note['notice_txt'].get()
                    if prior_note:
                        self.share.note['notice_txt'].set(
                            f'{prior_note}\n'
                            f'*** {cycles_max} count intervals have been run. ***\n')
                    else:
                        self.share.note['notice_txt'].set(
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    print(f'\n*** {cycles_max} counting cycles have ended. ***\n')

            app.update_idletasks()
            # Call to log_it() here needs to be outside of the thread lock.
            if self.share.setting['do_log'].get():
                self.share.logit('notice')

    def log_it(self, called_from=None) -> None:
        """
        Write to file interval and summary metrics for recently reported
        BOINC tasks. Provide information on aberrant task status.
        Called from set_interval_data() and notice_it().
        Is threaded as log_thread; start in Viewer.start_threads()

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """

        # Log text file formatting:
        indent = ' ' * 22
        bigindent = ' ' * 33

        # Note: Lots of local variables are used here to make the notice text
        #   statements easier to read
        #   Var outside of thread lock are set in settings() and invariant.
        cycles_max = self.share.setting['cycles_max'].get()
        interval_t = self.share.setting['interval_t'].get()
        summary_t = self.share.setting['summary_t'].get()
        intvl_count_t = self.share.data['intvl_count_t'].get()
        with self.thread_lock:
            if called_from == 'start':
                self.task_count_start = self.share.data['task_count'].get()
            elif called_from == 'interval':
                self.task_count_new = self.share.data['task_count'].get()
            tt_mean = self.share.data['tt_mean'].get()
            tt_sd = self.share.data['tt_sd'].get()
            tt_range = self.share.data['tt_range'].get()
            tt_total = self.share.data['tt_total'].get()
            num_tasks_all = self.share.data['num_tasks_all'].get()
            cycles_remain = self.share.data['cycles_remain'].get()
            num_running = self.share.note['num_running'].get()
            num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
            tic_nnt = self.share.note['tic_nnt'].get()

            if called_from == 'start' and cycles_max > 0:
                report = (
                    f'\n>>> START SETTINGS, GUI TASK COUNTER v.{__version__} <<<\n'
                    f'{self.share.long_time_start};'
                    ' Number of tasks in the most recent BOINC report:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: mean {tt_mean},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}Number of scheduled count intervals: {cycles_max}\n'
                    f'{indent}Counts every {interval_t}, summaries every {summary_t}.\n'
                    f'{indent}BOINC status evaluations every {NOTICE_INTERVAL}s.\n'
                    f'{indent}Project auto-update:'
                    f" {self.share.setting['proj_update'].get()}\n"
                    'Timed intervals beginning now...\n')
                logging.info(report)
            # Need to provide a truncated report for one-off "status" runs.
            elif called_from == 'start' and cycles_max == 0:
                report = (
                    f'\n{self.share.long_time_start}; STATUS REPORT\n'
                    f'{indent}Number of tasks in the most recent BOINC report:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: mean {tt_mean},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n')
                logging.info(report)

            # Note: Two timestamps are used: self.share.data['intvl_count_t']
            #   is defined in set_interval_data() at end of each count cycle,
            #   self.share.status_time is defined in set_task_states().
            if called_from == 'notice' and num_running > 0:
                # A Notice for no new tasks reported, tic_nnt, is issued in
                #   set_interval_data() instead of here.
                if num_running == num_tasks_all:
                    report = (f'\n{self.share.status_time};'
                              'BOINC client is about to run out of tasks.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'\n{self.share.status_time}; '
                              f'{num_suspended_by_user} tasks are suspended by user.')
                    logging.info(report)
            elif called_from == 'notice' and num_running == 0:
                report = (f'\n{self.share.status_time};'
                          ' *** NO TASKS RUNNING. Check BOINC Manager.***')
                logging.info(report)
                if self.share.note['proj_stalled'].get():
                    report = (
                        f' *** PROJECT AUTO-UPDATE REQUESTED for {self.share.first_project}. ***\n'
                        '  All tasks were "Ready to report" and waiting to upload.\n'
                        '  If Project auto-update is allowed, tasks should now be uploaded.\n'
                        '  Verify in BOINC Manager.')
                    logging.info(report)
                if num_tasks_all == 0:
                    report = f'{indent}BOINC client has no tasks!\n'
                    logging.info(report)
                if self.share.note['num_suspended_by_boinc'].get() > 0:
                    report = (f'{indent}BOINC Manager has suspended tasks;\n'
                              f'{indent}A "When to suspend" condition was met\n'
                              f'{indent}in BOINC Manager Computing preferences.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'{indent}'
                              f'{num_suspended_by_user} tasks suspended by user.')
                    logging.info(report)

            if called_from == 'interval' and tic_nnt > 0:
                report = (f'\n{intvl_count_t}; NO TASKS reported in the past'
                          f' {tic_nnt} counting intervals.\n'
                          f'{indent}{cycles_remain} counts remain.')
                logging.info(report)

            # This tic condition is equivalent to: task_count_new > 0 and
            #   num_running > 0; that is, everything normal.
            elif called_from == 'interval' and tic_nnt == 0:
                report = (
                    f'\n{intvl_count_t}; Tasks reported in the past {interval_t}:'
                    f' {self.task_count_new}\n'
                    f'{indent}Task Time: mean {tt_mean},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}{cycles_remain} counts remain.'
                )
                logging.info(report)

            if called_from == 'interval' and self.share.data['log_summary'].get():
                report = (
                    f'\n{intvl_count_t}; >>> SUMMARY: Count for the past'
                    f" {summary_t}: {self.share.data['task_count_sumry'].get()}\n"
                    f"{indent}Task Time: mean {self.share.data['tt_mean_sumry'].get()},\n"
                    f"{bigindent}range [{self.share.data['tt_range_sumry'].get()}],\n"
                    f"{bigindent}stdev {self.share.data['tt_sd_sumry'].get()},"
                    f" total {self.share.data['tt_total_sumry'].get()}")
                logging.info(report)
                # Need to reset flag to toggle summary logging.
                self.share.data['log_summary'].set(False)

            if called_from == 'interval' and cycles_remain == 0:
                report = f'\n### {cycles_max} counting cycles have ended. ###\n'
                logging.info(report)

    def update_project(self):
        """
        Called from notice_it() when update project setting is True.
        """
        # I'm not sure how to handle multiple concurrent Projects.
        # If they are all stalled, then updating the first works?
        # B/c of how BC.project_action is structured, here I use the
        #  url to get the Project name ID which is used to get the
        #  url needed for the project cmd.  Silly, but uses existing
        #  boinc_command.py methods. Is there a better way?
        first_local_url = BC.get_project_url()[0]
        self.share.first_project = list(BC.project_url.keys())[
            list(BC.project_url.values()).index(first_local_url)]
        BC.project_action(self.share.first_project, 'update')
        self.share.note['notice_txt'].set(
            'Project auto-update in progress for'
            f' {self.share.first_project}...')
        if self.share.setting['do_log'].get():
            self.share.logit('notice')
        # Need to provide time for BOINC Project server to respond before
        #   continuing with notice_it() thread.
        time.sleep(70)

    # pylint: disable=unused-argument
    def quit_gui(self, event=None) -> None:
        """
        Safe and informative exit from the program.
        Called from multiple widgets via Controller.quitgui().

        :param event: Needed for keybinding implicit event.
        """

        # Note: quit_gui() is a method instead of a function b/c it needs
        #   to evaluate the status of 'do_log' so the quit msg can be logged.
        time_now = datetime.now().strftime(LONG_STRFTIME)
        quit_msg = f'\n{time_now}; *** User quit the program. ***\n'
        print(quit_msg)
        if self.share.setting['do_log'].get():
            logging.info(quit_msg)
        app.destroy()
        sys.exit(0)


# MVC Viewer, the tkinter GUI engine; runs in main thread.
class CountViewer(tk.Frame):
    """
    The Viewer communicates with Modeler via 'share' objects handled
    through the Controller class. All GUI widgets go here.
    """

    def __init__(self, master, share):
        super().__init__(master)
        self.share = share
        self.dataframe = tk.Frame()
        self.menubar = tk.Menu()

        # Set colors for row labels and data display.
        # These colors are compatible with red-green color-blindness.
        self.share.row_fg = 'LightYellow'  # foreground for row labels
        self.master_bg = 'SteelBlue4'  # also used for row header labels
        self.data_bg = 'grey40'  # background for data labels and frame
        self.share.highlight = 'gold1'  # fg for notices, compliments, et al.
        self.emphasize = 'grey90'
        self.deemphasize = 'grey60'

        # Need to grey-out menu bar headings and View log button when
        #   another application has focus.
        #   source: https://stackoverflow.com/questions/18089068/
        #   tk-tkinter-detect-application-lost-focus
        self.bind_all("<FocusIn>", self.app_got_focus)
        self.bind_all("<FocusOut>", self.app_lost_focus)

        # Basic run parameters/settings passed between Viewer and Modeler.
        # Defaults, from in Modeler.default_settings(), can be changed in
        # settings().
        self.good_settings = False
        self.share.setting = {
            'interval_t': tk.StringVar(),
            'interval_m': tk.IntVar(),
            'sumry_t_value': tk.IntVar(),
            'sumry_t_unit': tk.StringVar(),
            'summary_t': tk.StringVar(),
            'cycles_max': tk.IntVar(),
            'do_log': tk.BooleanVar(),
            'proj_update': tk.BooleanVar()
        }

        # Control variables for display; passed between Viewer and Modeler
        self.share.data = {
            # Start and Interval data
            'task_count': tk.IntVar(),
            'tt_mean': tk.StringVar(),
            'tt_sd': tk.StringVar(),
            'tt_range': tk.StringVar(),
            'tt_total': tk.StringVar(),
            'intvl_count_t': tk.StringVar(),
            # General data
            'time_prev_cnt': tk.StringVar(),
            'cycles_remain': tk.IntVar(),
            'time_next_cnt': tk.StringVar(),
            'num_tasks_all': tk.IntVar(),
            # Summary data
            'time_prev_sumry': tk.StringVar(),
            'task_count_sumry': tk.IntVar(),
            'tt_mean_sumry': tk.StringVar(),
            'tt_sd_sumry': tk.StringVar(),
            'tt_range_sumry': tk.StringVar(),
            'tt_total_sumry': tk.StringVar(),
            'log_summary': tk.BooleanVar()
        }

        # Data for notices and logging passed between Viewer and Modeler
        # and between Modeler threads.
        self.share.note = {
            'notice_txt': tk.StringVar(),
            'num_running': tk.IntVar(),
            'tic_nnt': tk.IntVar(),
            'proj_stalled': tk.BooleanVar(),
            'num_suspended_by_user': tk.IntVar(),
            'num_suspended_by_boinc': tk.IntVar(),
        }

        # settings() window widgets:
        self.settings_win = tk.Toplevel()
        self.sumry_t_value = ttk.Entry(self.settings_win)
        self.sumry_t_unit = ttk.Combobox(self.settings_win)
        self.cycles_max_entry = ttk.Entry(self.settings_win)
        self.countnow_button = ttk.Button(self.settings_win)
        self.intvl_choice = ttk.Combobox(self.settings_win)
        self.log_choice = tk.Checkbutton(self.settings_win)
        self.update_choice = tk.Checkbutton(self.settings_win)

        # Labels for settings values; gridded in master_layout(). They are
        #   fully configured here simply to reduce number of lines in code.
        # NOTE: self.time_start_l label is initially configured for text to
        #   show a startup message, then reconfigured in emphasize_start_data()
        #   for the time_start.
        self.time_start_l = tk.Label(self.dataframe, bg=self.data_bg, fg='grey90')
        self.interval_t_l = tk.Label(self.dataframe, width=21, borderwidth=2,
                                     textvariable=self.share.setting['interval_t'],
                                     relief='groove', bg=self.data_bg)
        self.summary_t_l = tk.Label(self.dataframe, width=21, borderwidth=2,
                                    textvariable=self.share.setting['summary_t'],
                                    relief='groove', bg=self.data_bg)
        self.cycles_max_l = tk.Label(textvariable=self.share.setting['cycles_max'],
                                     bg=self.master_bg, fg=self.share.row_fg)

        # Labels for BOINC data.
        self.task_count_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                     textvariable=self.share.data['task_count'])
        self.tt_mean_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                  textvariable=self.share.data['tt_mean'])
        self.tt_sd_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                textvariable=self.share.data['tt_sd'])
        self.tt_range_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                   textvariable=self.share.data['tt_range'])
        self.tt_total_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                   textvariable=self.share.data['tt_total'])
        self.task_count_sumry_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                           textvariable=self.share.data['task_count_sumry'])
        self.ttmean_sumry_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                       textvariable=self.share.data['tt_mean_sumry'])
        self.ttsd_sumry_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                     textvariable=self.share.data['tt_sd_sumry'])
        self.ttrange_sumry_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                        textvariable=self.share.data['tt_range_sumry'])
        self.ttsum_sumry_l = tk.Label(self.dataframe, width=3, bg=self.data_bg,
                                      textvariable=self.share.data['tt_total_sumry'])
        # Data labels in master
        self.time_prev_cnt_l = tk.Label(
            textvariable=self.share.data['time_prev_cnt'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_prev_sumry_l = tk.Label(
            textvariable=self.share.data['time_prev_sumry'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_next_cnt_l = tk.Label(
            textvariable=self.share.data['time_next_cnt'],
            bg=self.master_bg, fg=self.share.highlight)
        self.cycles_remain_l = tk.Label(
            textvariable=self.share.data['cycles_remain'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.num_tasks_all_l = tk.Label(
            textvariable=self.share.data['num_tasks_all'],
            bg=self.master_bg, fg=self.share.row_fg)
        # Text for compliment_l is configured in compliment_me()
        self.share.compliment_l = tk.Label(bg=self.master_bg,
                                           fg=self.share.highlight)
        self.share.notice_l = tk.Label(
            textvariable=self.share.note['notice_txt'],
            fg=self.share.highlight, bg=self.master_bg,
            relief='flat', border=0)

        # This style is used only to configure viewlog_b color in
        #   app_got_focus() and app_lost_focus().
        self.view_button_style = ttk.Style(self.master)

        self.master_widgets()
        self.master_layout()
        self.share.defaultsettings()
        self.settings()
        # Starting functions sequence after settings() is called:
        #   check_and_set(), check_and_start(), start_threads(),
        #   emphasize_start_data(), CountModeler.set_start_data().
        # Note: none of that sequence will occur, however, if BOINC
        #   client is not running, so...
        check_boinc()

    def master_widgets(self) -> None:
        """
        Master data frame, menus, and buttons.
        """
        self.dataframe.configure(borderwidth=3, relief='sunken',
                                 bg=self.data_bg)
        self.dataframe.grid(row=2, column=1, rowspan=7, columnspan=2,
                            padx=(5, 10), sticky=tk.NSEW)
        self.dataframe.columnconfigure(1, weight=1)
        self.dataframe.columnconfigure(2, weight=1)

        # Add pull-down menus
        self.master.config(menu=self.menubar)
        os_accelerator = ''
        if MY_OS in 'lin, win':
            os_accelerator = 'Ctrl'
        elif MY_OS == 'dar':
            os_accelerator = 'Command'
        # Note: 'self'.file b/c also used in check_and_set()
        self.file = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="File", menu=self.file)
        self.file.add_command(label="Backup log file", command=backup_log)
        self.file.add_separator()
        self.file.add_command(label='Quit', command=self.share.quitgui,
                              # Note: macOS won't display this accelerator text
                              #   b/c can't override macOS native Command+Q;
                              #   and don't want Ctrl+Q displayed or used on macOS.
                              accelerator=f'{os_accelerator}+Q')
        view = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="View", menu=view)
        view.add_command(label="Log file", command=view_log,
                         # MacOS: can't display "Cmd+L" b/c won't override native cmd.
                         accelerator="Ctrl+L")
        view.add_command(label="Analysis", command=show_cumulative_data,
                         accelerator="Ctrl+A")
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label='Information', command=self.share.info)
        help_menu.add_command(label="Compliment", command=self.share.complimentme,
                              accelerator="Ctrl+Shift+C")
        help_menu.add_command(label="About", command=self.share.about)

        self.viewlog_b = ttk.Button(text='View log file', command=view_log)
        # Set interval & summary focus button attributes with .share. b/c need
        #   to reconfigure them in Modeler.
        # starting_b will be replaced with ttk intvl_b after first interval
        #   completes; it is re-grid in set_interval_data().
        # starting_b is tk.B b/c that accepts disabledforeground keyword.
        self.share.starting_b = tk.Button(text='Starting data', width=18,
                                          disabledforeground='grey10',
                                          state=tk.DISABLED)
        self.share.intvl_b = ttk.Button(text='Interval data', width=18,
                                        command=self.emphasize_intvl_data)
        self.share.sumry_b = ttk.Button(text='Summary data', width=20,
                                        command=self.emphasize_sumry_data)

    def master_layout(self) -> None:
        """
        Master Frame configuration, keybindings, row headers,
        separators, and grids.
        """
        # Background color of container Frame is configured in __init__
        # OS-specific window size ranges set in Controller __init__
        self.master.title(GUI_TITLE)
        # Need to color in all of master Frame, and use near-white border;
        #    changes to grey for click-drag and loss of focus.
        self.master.configure(bg=self.master_bg,
                              highlightthickness=3,
                              highlightcolor='grey95',
                              highlightbackground='grey75')

        # Provide Terminal exit info.
        self.master.protocol('WM_DELETE_WINDOW', self.share.quitgui)
        self.master.bind_all('<Escape>', self.share.quitgui)

        # Set up universal and OS-specific keybindings and menus
        cmdkey = ''
        if MY_OS in 'lin, win':
            cmdkey = 'Control'
        elif MY_OS == 'dar':
            cmdkey = 'Command'
        self.master.bind(f'<{f"{cmdkey}"}-q>', self.share.quitgui)
        self.master.bind('<Shift-Control-C>', self.share.complimentme)
        self.master.bind("<Control-l>", view_log)
        self.master.bind("<Control-a>", show_cumulative_data)

        # Theme controls entire window theme, but only for ttk.Style objects.
        # Options: classic, alt, clam, default, aqua(MacOS only)
        ttk.Style().theme_use('alt')

        self.master.columnconfigure(1, weight=1)
        self.master.columnconfigure(2, weight=1)

        # Fill in headers for data rows.
        row_header = {'Counting since': 2,
                      'Count interval': 3,
                      '# tasks reported': 4,
                      'Task times:  mean': 5,
                      'stdev': 6,
                      'range': 7,
                      'total': 8,
                      'Interval time:': 10,
                      # 'Summary time:': 10,
                      'Next count in:': 11,
                      # 'Counts remaining:': 12,
                      'Tasks in queue:': 12,
                      'Notices:': 13
                      }
        for header, rownum in row_header.items():
            tk.Label(self.master, text=f'{header}',
                     bg=self.master_bg, fg=self.share.row_fg
                     ).grid(row=rownum, column=0, padx=(5, 0), sticky=tk.E)
        # Need to accommodate instances of two headers in same row.
        tk.Label(self.master, text='Summary time:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=10, column=2, sticky=tk.W)
        tk.Label(self.master, text='Counts remaining:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=12, column=2, sticky=tk.W)

        # For colored separators, use ttk.Frame instead of ttk.Separator.
        # Initialize then configure style for separator color.
        style_sep = ttk.Style(self.master)
        style_sep.configure('Sep.TFrame', background=self.master_bg)
        sep1 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)
        sep2 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)

        # %%%%%%%%%%%%%%%%%%% grid: sorted by row number %%%%%%%%%%%%%%%%%%%%%%
        self.viewlog_b.grid(row=0, column=0, padx=5, pady=(8, 4))
        self.share.starting_b.grid(row=0, column=1, padx=(16, 0), pady=(6, 4))
        self.share.sumry_b.grid(row=0, column=2, padx=(0, 22), pady=(8, 4))
        sep1.grid(row=1, column=0, columnspan=5, padx=5, pady=(2, 5), sticky=tk.EW)
        self.time_start_l.grid(row=2, column=1, padx=(10, 16), sticky=tk.EW,
                               columnspan=2)
        self.interval_t_l.grid(row=3, column=1, padx=(12, 6), sticky=tk.EW)
        self.summary_t_l.grid(row=3, column=2, padx=(0, 16), sticky=tk.EW)
        self.task_count_l.grid(row=4, column=1, padx=10, sticky=tk.EW)
        self.task_count_sumry_l.grid(row=4, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_mean_l.grid(row=5, column=1, padx=10, sticky=tk.EW)
        self.ttmean_sumry_l.grid(row=5, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_sd_l.grid(row=6, column=1, padx=10, sticky=tk.EW)
        self.ttsd_sumry_l.grid(row=6, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_range_l.grid(row=7, column=1, padx=10, sticky=tk.EW)
        self.ttrange_sumry_l.grid(row=7, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_total_l.grid(row=8, column=1, padx=10, sticky=tk.EW)
        self.ttsum_sumry_l.grid(row=8, column=2, padx=(0, 16), sticky=tk.EW)
        sep2.grid(row=9, column=0, columnspan=5, padx=5, pady=(6, 6), sticky=tk.EW)
        self.time_prev_cnt_l.grid(row=10, column=1, padx=3, sticky=tk.W,
                                  columnspan=2)
        self.time_prev_sumry_l.grid(row=10, column=2, padx=(108, 0), sticky=tk.W)
        self.time_next_cnt_l.grid(row=11, column=1, padx=3, sticky=tk.W)
        self.num_tasks_all_l.grid(row=12, column=1, padx=3, sticky=tk.W)
        # Place cycles_remain value in same cell as its header, but shifted right.
        if MY_OS in 'lin, dar':
            self.cycles_remain_l.grid(row=12, column=2, padx=(123, 0), sticky=tk.W)
        elif MY_OS == 'win':
            self.cycles_remain_l.grid(row=12, column=2, padx=(110, 0), sticky=tk.W)
        # Need rowspan=2 for proper vertical alignment and to avoid gap artifact in
        #   frame border from row 14 exceeding vertical geometry when notices >1 row.
        #   Need pady for alignment with the row header.
        self.share.notice_l.grid(row=13, column=1, columnspan=2, rowspan=2,
                                 padx=5, pady=(1, 0), sticky=tk.NW)
        self.share.compliment_l.grid(row=14, column=1, columnspan=2,
                                     padx=5, sticky=tk.W)

        # These control variables have default or initial start values,
        #   so make values invisible in pre-settings dataframe by matching
        #   them to the background color.
        self.interval_t_l.config(foreground=self.data_bg)
        self.summary_t_l.config(foreground=self.data_bg)
        self.task_count_l.config(foreground=self.data_bg)
        self.task_count_sumry_l.config(foreground=self.data_bg)

    def settings(self) -> None:
        """
        Configures the Toplevel window that appears at startup.
        Confirms default parameters or sets new ones for count and
        summary interval times, counting limit, and log file option.
        """
        # Toplevel window basics
        self.settings_win.title('Set and confirm run settings')
        # Need to position over app window, which is at '+96+134'.
        self.settings_win.geometry('+136+174')
        self.settings_win.resizable(False, False)
        self.settings_win.config(relief='raised', bg=self.master_bg,
                                 highlightthickness=3,
                                 highlightcolor=self.share.highlight,
                                 highlightbackground=self.deemphasize)
        if MY_OS in 'lin, win':
            self.settings_win.attributes('-topmost', True)
        # In macOS, topmost places Combobox selections BEHIND the window,
        #    but focus_force() makes it visible; must be a tkinter bug?
        elif MY_OS == 'dar':
            self.settings_win.focus_force()

        settings_style = ttk.Style()
        settings_style.configure('Set.TLabel', background=self.master_bg,
                                 foreground=self.share.row_fg)

        # Need text in master window to prompt user to enter settings.
        #   The message text is covered by the settings_win, but is
        #   seen if user drags settings_win away.
        self.time_start_l.configure(text='Waiting for run settings...')

        # Inner functions for window control and user FYI:
        # Need to disable default window Exit; only allow exit from active Confirm button.
        # https://stackoverflow.com/questions/22738412/a-suitable-do-nothing-lambda-expression-in-python
        #    to just disable 'X' exit, the protocol func can be lambda: None, or type(None)()
        def no_exit_on_x():
            msg = ('Please close window with "Count now" button.\n'
                   '"Count now" is allowed once "Confirm" checks settings.')
            messagebox.showinfo(title='Confirm before closing', detail=msg,
                                parent=self.settings_win)
        self.settings_win.protocol('WM_DELETE_WINDOW', no_exit_on_x)

        def explain_zero_max():
            explain = ('Interval counting stops after entered number of '
                       'cycles. Enter 0 (zero) for a status report.')
            messagebox.showinfo(parent=self.settings_win, detail=explain)

        def explain_update():
            explain = ('Allows automatic Project update to re-establish communication '
                       ' with the BOINC server when no tasks are running and '
                       ' all tasks are "Ready to report" in the BOINC Manager.')
            messagebox.showinfo(parent=self.settings_win, detail=explain)

        # Settings widget configurations and grids.
        self.intvl_choice.configure(state='readonly', width=4, height=12,
                                    textvariable=self.share.setting['interval_t'])
        self.intvl_choice['values'] = ('60m', '30m', '20m', '15m', '10m')
        self.intvl_choice.bind(
            "<<ComboboxSelected>>", self.share.setting['interval_t'].set(self.intvl_choice.get()))
        intvl_label1 = ttk.Label(self.settings_win, text='Count interval',
                                 style='Set.TLabel')
        intvl_label2 = ttk.Label(self.settings_win, text='minutes',
                                 style='Set.TLabel')

        self.sumry_t_value.configure(
            validate='key', width=4,
            textvariable=self.share.setting['sumry_t_value'],
            validatecommand=(
                self.sumry_t_value.register(eval_digit_entry), '%P', '%d'))
        self.sumry_t_unit.configure(state='readonly',
                                    textvariable=self.share.setting['sumry_t_unit'],
                                    values=('day', 'hr', 'min'), width=4)
        self.sumry_t_unit.bind(
            "<<ComboboxSelected>>", self.share.setting['sumry_t_unit'].set(self.sumry_t_unit.get()))
        sumry_label1 = ttk.Label(
            self.settings_win, text='Summary interval: time value',
            style='Set.TLabel')
        sumry_label2 = ttk.Label(
            self.settings_win, text='time unit', style='Set.TLabel')

        # Specify number limit of counting cycles to run.
        self.cycles_max_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['cycles_max'],
            validatecommand=(
                self.cycles_max_entry.register(eval_digit_entry), '%P', '%d'))
        cycles_label1 = ttk.Label(self.settings_win, text='# Count cycles',
                                  style='Set.TLabel')
        cycles_query_button = ttk.Button(self.settings_win, text='?', width=0,
                                         command=explain_zero_max)

        # Need user options to log results to file and to use auto-updates.
        self.log_choice.configure(variable=self.share.setting['do_log'],
                                  bg=self.master_bg, borderwidth=0)
        log_label = ttk.Label(self.settings_win, text='Log results to file',
                              style='Set.TLabel')

        self.update_choice.configure(variable=self.share.setting['proj_update'],
                                     bg=self.master_bg, borderwidth=0)
        update_label = ttk.Label(self.settings_win, text='Use Project auto-update',
                                 style='Set.TLabel')
        update_query_btn = ttk.Button(self.settings_win, text='?', width=0,
                                      command=explain_update)

        confirm_button = ttk.Button(self.settings_win, text='Confirm',
                                    command=self.check_and_set)
        default_button = ttk.Button(self.settings_win, text='Use defaults',
                                    command=self.share.defaultsettings)
        self.countnow_button.configure(text='Count now',
                                       command=self.check_and_start)
        # Need to disable button to force user to first "Confirm" settings,
        #    even when using default settings: it is a 2-click closing.
        #    'Count now' button is enabled (tk.NORMAL) in check_and_set().
        self.countnow_button.config(state=tk.DISABLED)

        # Grid all window widgets; generally sorted by row.
        self.intvl_choice.grid(column=1, row=0)
        intvl_label1.grid(column=0, row=0, padx=5, pady=10, sticky=tk.E)
        intvl_label2.grid(column=2, row=0, padx=5, pady=10, sticky=tk.W)
        sumry_label1.grid(column=0, row=1, padx=(10, 5), pady=10, sticky=tk.E)
        self.sumry_t_value.grid(column=1, row=1)
        sumry_label2.grid(column=2, row=1, padx=5, pady=10, sticky=tk.E)
        self.sumry_t_unit.grid(column=3, row=1, padx=5, pady=10, sticky=tk.W)
        cycles_label1.grid(column=0, row=2, padx=5, pady=10, sticky=tk.E)
        self.cycles_max_entry.grid(column=1, row=2)
        log_label.grid(column=0, row=3, padx=5, pady=5, sticky=tk.E)
        self.log_choice.grid(column=1, row=3, padx=0, pady=5, sticky=tk.W)
        update_label.grid(column=0, row=4, padx=5, pady=0, sticky=tk.E)
        self.update_choice.grid(column=1, row=4, padx=0, pady=0, sticky=tk.W)
        confirm_button.grid(column=3, row=4, padx=10, pady=(0, 10), sticky=tk.E)
        default_button.grid(column=0, row=5, padx=10, pady=(0, 10), sticky=tk.W)
        self.countnow_button.grid(column=3, row=5, padx=10, pady=(0, 10), sticky=tk.E)
        # Need OS-specific gridding for proper alignments:
        if MY_OS in 'lin, dar':
            cycles_query_button.grid(column=0, row=2, padx=(80, 0), sticky=tk.W)
            update_query_btn.grid(column=0, row=4, padx=(15, 0), sticky=tk.W)
        if MY_OS == 'win':
            cycles_query_button.grid(column=0, row=2, padx=(70, 0), sticky=tk.W)
            update_query_btn.grid(column=0, row=4, padx=(10, 0), sticky=tk.W)

    def check_and_set(self):
        """
        Confirm that summary time is valid for interval time,
        set all settings to valid control variable dict values,
        and set up logging data if optioned.
        Called from confirm_button in settings().
        """
        self.countnow_button.config(state=tk.DISABLED)

        # Note: self.share.setting['interval_t'] and self.sumry_t_value
        #    are set in settings().
        interval_m = int(self.share.setting['interval_t'].get()[:-1])
        self.share.setting['interval_m'].set(interval_m)
        sumry_value = self.sumry_t_value.get()
        # When sumry_value == 0, it will be caught by interval_m comparison.
        if not sumry_value:
            self.share.setting['sumry_t_value'].set(1)
            sumry_value = 1
        elif sumry_value != '0':
            self.share.setting['sumry_t_value'].set(int(sumry_value.lstrip('0')))

        # Need to set summary_t here as concat of the two sumry_t element strings,
        #   then convert to minutes to use in comparisons.
        summary_t = f"{sumry_value}{self.sumry_t_unit.get()[:1]}"
        self.share.setting['summary_t'].set(summary_t)
        summary_m = TC.string_to_m(summary_t)
        if interval_m >= summary_m or summary_m % interval_m != 0:
            self.countnow_button.config(state=tk.DISABLED)
            self.good_settings = False
            info = "Summary time must be greater than, and a multiple of, interval time"
            messagebox.showerror(title='Invalid entry', detail=info,
                                 parent=self.settings_win)
        elif interval_m < summary_m and summary_m % interval_m == 0:
            self.good_settings = True
            self.countnow_button.config(state=tk.NORMAL)

        # Need to remove leading zeros, but allow a zero entry.
        #   Replace empty Entry with default values.
        cycles_max = self.cycles_max_entry.get()
        if cycles_max == '':
            self.share.setting['cycles_max'].set(1008)
        elif cycles_max != '0':
            self.share.setting['cycles_max'].set(int(cycles_max.lstrip('0')))
        # Allow zero entry for 1-off status report of task data.
        elif cycles_max == '0':
            self.share.setting['cycles_max'].set(0)

        # Need to set initial cycles_remain to cycles_max.
        self.share.data['cycles_remain'].set(self.share.setting['cycles_max'].get())

        # Here logging is lazily employed to manage the file of report data.
        # A log file will be created only if so optioned (default).
        if self.share.setting['do_log'].get():
            logging.basicConfig(filename=str(LOGFILE), level=logging.INFO,
                                filemode="a", format='%(message)s')
        else:
            self.viewlog_b.config(state=tk.DISABLED)
            self.file.entryconfig("Backup log file", state=tk.DISABLED)
            self.master.unbind("<Control-l>")

    def check_and_start(self):
        """
        Main gatekeeper for settings().
        Calls check_and_set(); if all is good then starts threads,
        calls emphasize_start_data(), and closes settings() window,
        which ends the startup sequence.
        Called from settings() countnow_button.
        """
        # Need to run final validation of settings in case user changed
        #   something since a prior "Confirm" check_and_set() call.
        self.check_and_set()
        if self.good_settings:
            # Run 1-off status report or begin interval counts...
            if self.share.setting['cycles_max'].get() == 0:
                self.share.data['cycles_remain'].set(0)
                self.share.setting['interval_t'].set('DISABLED')
                self.share.setting['summary_t'].set('DISABLED')
                self.share.note['notice_txt'].set('STATUS REPORT ONLY')
                self.emphasize_start_data()
                self.share.setstartdata()
                self.settings_win.destroy()
            # Begin main interval counting functions...
            else:
                self.start_threads()
                self.emphasize_start_data()
                self.share.setstartdata()
                self.settings_win.destroy()

    def start_threads(self) -> None:
        """
        Set up and start threads for intervals, notices, and logging.
        Called from check_and_start() in Viewer as part of
        startup sequence.
        """
        # There are no thread.join(), so use daemon for clean exits.
        intvl_thread = threading.Thread(
            target=self.share.setintervaldata, daemon=True)
        notice_thread = threading.Thread(
            target=self.share.taskstatenotices, daemon=True)
        log_thread = threading.Thread(
            target=self.share.logit, daemon=True)
        intvl_thread.start()
        notice_thread.start()
        log_thread.start()

    def emphasize_start_data(self) -> None:
        """
        Config data labels in master window for starting data emphasis.
        Establish start time.
        Called from check_and_start() with 'Count now' button.
        """
        time_start = datetime.now().strftime(SHORT_STRFTIME)
        self.time_start_l.config(text=time_start)
        self.share.long_time_start = datetime.now().strftime(LONG_STRFTIME)

        # Need to keep sumry_b button disabled until after 1st summary interval.
        self.share.sumry_b.config(state=tk.DISABLED)

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)
        self.task_count_l.config(foreground=self.share.highlight)

        self.tt_mean_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_intvl_data(self) -> None:
        """
        Switches font emphasis from Summary data to Interval data.
        Called from 'Interval data' button.
        """

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)

        # Interval data, column1
        self.task_count_l.configure(foreground=self.share.highlight)
        self.tt_mean_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        # Summary data, column2, deemphasize font color
        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_sumry_data(self) -> None:
        """
        Switches font emphasis from Interval data to Summary data.
        Called from 'Summary data' button.
        """
        self.interval_t_l.config(foreground=self.deemphasize)
        self.summary_t_l.config(foreground=self.emphasize)

        # Summary data, column2, emphasize font color
        self.task_count_sumry_l.configure(foreground=self.share.highlight)
        self.ttmean_sumry_l.configure(foreground=self.share.highlight)
        self.ttsd_sumry_l.configure(foreground=self.emphasize)
        self.ttrange_sumry_l.configure(text=self.share.data['tt_range'].get(),
                                       foreground=self.emphasize)
        self.ttsum_sumry_l.configure(foreground=self.emphasize)

        # Interval data, column1, deemphasize font color
        self.task_count_l.configure(foreground=self.deemphasize)
        self.task_count_l.configure(foreground=self.deemphasize)
        self.tt_mean_l.configure(foreground=self.deemphasize)
        self.tt_sd_l.configure(foreground=self.deemphasize)
        self.tt_range_l.configure(foreground=self.deemphasize)
        self.tt_total_l.configure(foreground=self.deemphasize)

    # pylint: disable=unused-argument
    def app_got_focus(self, event=None) -> None:
        """Give menu bar headings normal color when app has focus.

        :param event: <FocusIn> mouse click.
        """
        self.menubar.entryconfig("File", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("View", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("Help", foreground='black', state=tk.NORMAL)
        self.view_button_style.configure('View.TButton', foreground='black',
                                         background='grey75')
        if self.share.setting['do_log'].get():
            self.viewlog_b.configure(style='View.TButton', state=tk.NORMAL)

    # pylint: disable=unused-argument
    def app_lost_focus(self, event=None) -> None:
        """Give menu bar headings grey-out color when app looses focus.

        :param event: <FocusOut> mouse click.
        """
        self.menubar.entryconfig("File", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("View", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("Help", foreground='grey', state=tk.DISABLED)
        self.view_button_style.configure('View.TButton', foreground='grey')
        if self.share.setting['do_log'].get():
            self.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)


# ################## MVC Controller; is app mainloop ##################
class CountController(tk.Tk):
    """
    The Controller through which other MVC Count Classes can interact
    through the 'share' parameter.
    Instantiates CountViewer() with master tk.Frame inheritance.
    Concept from https://stackoverflow.com/questions/32864610/
    """

    def __init__(self):
        super().__init__()

        # Need geometry so that master window will be under settings()
        #   Toplevel window at startup.
        #   Not setting geometry here places app window below settings_win
        # These x, y coordinates match default window placement on Ubuntu desktop.
        self.geometry('+96+134')

        # Need window sizes to make room for multi-line notices,
        #    but not get minimized enough to exclude notices row.
        # Need OS-specific master window sizes b/c of different default font widths.
        if MY_OS == 'lin':
            self.minsize(580, 360)
            self.maxsize(780, 390)
        elif MY_OS == 'win':
            self.minsize(532, 380)
            self.maxsize(720, 400)
        elif MY_OS == 'dar':
            self.minsize(600, 390)
            self.maxsize(780, 425)

        # pylint: disable=assignment-from-no-return
        container = tk.Frame(self).grid()
        CountViewer(master=container, share=self)

    def defaultsettings(self) -> None:
        """
        Starting settings of: report interval, summary interval,
        counting limit, and log file option.
        """
        CountModeler(share=self).default_settings()

    def setstartdata(self) -> None:
        """
        Is called from Viewer.startup().
        """
        CountModeler(share=self).set_start_data()

    def setintervaldata(self) -> None:
        """
        Is called from Viewer.start_threads(), which starts the Modeler
        interval thread.
        """
        CountModeler(share=self).set_interval_data()

    def taskstatenotices(self) -> None:
        """
        Is called from Viewer.start_threads(), which starts the Modeler
        task state notification thread.
        """
        CountModeler(share=self).notice_it()

    def logit(self, called_from=None) -> None:
        """Send data to log file.
        Is called from Viewer.start_threads(), which starts the Modeler
        log_it() thread.

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """
        CountModeler(share=self).log_it(called_from)

    # pylint: disable=unused-argument
    def quitgui(self, event=None) -> None:
        """
        Close down program. Called from button, menu bar, and keybinding.

        :param event: Needed for implicit keybinding event
        """
        CountModeler(share=self).quit_gui()

    def info(self) -> None:
        """Is called from Help menu bar
        """
        CountFyi(share=self).information()

    # pylint: disable=unused-argument
    def complimentme(self, event=None) -> None:
        """Is called from Help menu bar. A silly diversion.

        :param event: Needed for implicit keybinding event
        """
        CountFyi(share=self).compliment_me()

    def about(self):
        """Is called from Viewer Help menu bar.
        """
        CountFyi(share=self).about()


# ############ An MVC add-on; independent of data functions ###########
class CountFyi:
    """
    Methods to provide user with information and help.
    """

    def __init__(self, share):
        self.share = share

    @staticmethod
    def information() -> None:
        """
        Basic information program usage and actions;
        Toplevel window called from Help menu bar.
        """
        pos_x, pos_y = app_position(15, 15)
        infowin = tk.Toplevel()
        infowin.geometry(f'+{pos_x}+{+pos_y}')
        infowin.resizable(False, False)
        infowin.title('Usage information')
        information = ("""
            - Counting begins once settings are confirmed at start.\n
            - Interval and Summary data buttons switch visual emphasis;
                    ...those buttons activate once their data post.\n
            - At start, # tasks reported and time of last count are from
                    the most recent hourly BOINC report.\n
            - Number of tasks in queue and Notices update every"""
                       f' {NOTICE_INTERVAL} seconds.\n'
                       """
            - Displayed countdown clock time is approximate.\n
            - Review counts and Notices history with "View log file".\n
            - File>'Backup log file' copies log to the current folder.""")

        num_doc_lines = information.count('\n')
        os_width = 0
        if MY_OS in 'lin, win':
            os_width = 64
        elif MY_OS == 'dar':
            os_width = 56
        infotxt = tk.Text(infowin, font='TkTextFont',
                          width=os_width, height=num_doc_lines + 2,
                          bg='grey20', fg='grey85',
                          relief='groove', padx=15)
        infotxt.insert(1.0, information)
        infotxt.pack()

    def compliment_me(self) -> None:
        """A silly diversion; called from Help menu bar and keybinding.
        """
        compliments = [
            "Hey there good lookin'!", 'I wish we had met sooner.',
            'You are the smartest person I know.', 'I like your hair.',
            'You have such a nice smile.', 'Smart move!',
            'Blue is your color.', 'Good choice!',
            "That's very kind of you.", "Stop! You're making me blush.",
            'I just love what you did.', 'How witty you are!', 'Awesome!',
            'Your tastes are impeccable.', "You're incredible!",
            'You are so talented!', "I wish I'd thought of that.",
            'This is fun!', 'Get back to work.', 'Nice!', 'You saved me.',
            'You are an inspiration to us all.', "That's so funny!",
            'Show me how you do that.', "I've always looked up to you.",
            'You sound great!', 'You smell nice.', 'Great job!',
            'You are a role model.', 'I wish more people were like you.',
            'We appreciate what you did.', 'I hear people look up to you.',
            'You are a really good dancer.', 'What makes you so successful?',
            'When you speak, people listen.', 'You are a superb person.',
            'You rock!', 'You nailed it!', 'That was really well done.',
            'You are amazing!', 'We need more folks like you around here.',
            'Excuse me, are you a model?', 'What a lovely laugh you have.',
            "I'm jealous of your ability.", "You're the stuff of legends.",
            'This would not be possible without you.', 'Way to go! Yay!',
            'Did you make that? I love it!', 'You are the best!',
            'I like what you did.', 'Whoa. Have you been working out?',
            "We can't thank you enough.", 'No, really, you have done enough.',
            "That's a good look for you.", 'I could not have done it better.',
            "I can't think of anything to say. Sorry.", 'Congratulations!',
            "Well, THAT's impressive.", 'I hear that you are the one.',
            'You excel at everything.', 'Your voice is very soothing.',
            'Is it true what people say?', 'The word is, you got it!',
            'The Nobel Committee has been trying to reach you.',
            'The Academy is asking for your CV.', 'You look great!',
            'The President seeks your council.', 'Thank you so much!',
            'The Prime Minister seeks your council.', 'Crunchers rule!',
            'Crunchers are the best sort of people.'
        ]
        praise = random.choice(compliments)
        self.share.compliment_l.config(text=praise)
        self.share.notice_l.grid_remove()
        # Need to re-grid initial master_widgets gridding b/c its grid may
        #   have been removed by a notice_l call. Original grid coordinates
        #   are set in master_widgets().
        self.share.compliment_l.grid()

        def refresh():
            self.share.compliment_l.grid_remove()
            # Re-grid notice to return to current Notice text.
            self.share.notice_l.grid()
            app.update_idletasks()

        self.share.compliment_l.after(3333, refresh)

    @staticmethod
    def about() -> None:
        """
        Basic information for gcount-tasks;
        Toplevel window called from Help menu bar.
        """
        pos_x, pos_y = app_position(15, 15)
        aboutwin = tk.Toplevel()
        aboutwin.geometry(f'+{pos_x}+{+pos_y}')
        aboutwin.resizable(False, False)
        aboutwin.title('About count-tasks')
        colour = ['SkyBlue4', 'DarkSeaGreen4', 'DarkGoldenrod4', 'DarkOrange4',
                  'grey40', 'blue4', 'navy', 'DeepSkyBlue4', 'dark slate grey',
                  'dark olive green', 'grey10', 'grey25', 'DodgerBlue4',
                  'DarkOrchid4']
        bkg = random.choice(colour)
        num_doc_lines = __doc__.count('\n') + 2
        os_width = 0
        if MY_OS in 'lin, win':
            os_width = 60
        elif MY_OS == 'dar':
            os_width = 54
        abouttxt = tk.Text(aboutwin, font='TkTextFont',
                           width=os_width, height=num_doc_lines + 6,
                           bg=bkg, fg='grey98', relief='groove',
                           borderwidth=5, padx=25)
        abouttxt.insert(1.0, f'{__doc__}\n'
                             f'Author:    {__author__}\n'
                             f'Credits:   {__credits__}\n'
                             f'License:   {__license__}\n'
                             f'URL:       {__project_url__}\n'
                             f'Version:   {__version__}\n'
                             f'Status:    {__status__}\n')
        abouttxt.pack()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--about',
                        help='Provides description, version, GNU license',
                        action='store_true',
                        default=False)
    args = parser.parse_args()
    if args.about:
        print(__doc__)
        print('Author:    ', __author__)
        print('Credits:   ', __credits__)
        print('License:   ', __license__)
        print('URL:       ', __project_url__)
        print('Version:   ', __version__)
        print('Status:    ', __status__)
        print()
        sys.exit(0)
    else:
        try:
            app = CountController()
            app.title(f"Count BOINC tasks on {node()}")
            # Note: cannot use Path(__file__).name with py2exe, so instead
            #  use literal file name for Windows standalone compilation.
            # print('gcount-tasks now running...')  # Windows py2exe compile only.
            print(f'{Path(__file__).name} now running...')
            app.mainloop()
        # Ctrl-C from Terminal is not recognized by tk/tcl until an event occurs,
        #  like moving cursor over window, or a timer action.
        #  Can use signal.signal(signal.SIGINT, signal.SIG_DFL) to allow
        #  immediate exit, but that would bypass this exit message.
        except KeyboardInterrupt:
            exit_msg = ('\n\n  *** Interrupted by user ***\n'
                        f'  Quitting now...{datetime.now()}\n\n')
            print(exit_msg)
            logging.info(msg=exit_msg)
