#!/usr/bin/env python3

"""
GcountTasks (gcount-tasks) provides task counts and time statistics at
timed intervals for tasks recently reported to BOINC servers. It can be
run on Windows, Linux, or MacOS. It is the tkinter GUI version of
count-tasks. Its MVC architecture is modified from examples provided
at https://stackoverflow.com/questions/32864610/ and links therein.
Requires Python 3.6 or later and tkinter (tk/tcl) 8.6 or later.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see https://www.gnu.org/licenses/.
"""
# ^^ Text for --about invocation argument via __doc__.
# Also used in Fyi.about(); __program_name__ used throughout.
# __program_name__ may be context-specific, see definition below.
__author__ = 'cecht, BOINC ID: 990821'
__copyright__ = 'Copyright (C) 2021 C.S. Echt'
__credits__ = 'Inspired by rickslab-gpu-utils'
__license__ = 'GNU General Public License'
__version__ = '0.10.11'
__dev_environment__ = "Python 3.8 - 3.9"
__project_url__ = 'https://github.com/csecht/CountBOINCtasks'
__maintainer__ = 'cecht'
__status__ = 'Development Status :: 2 - Beta'

import argparse
import logging
import sys
import threading
from datetime import datetime
from pathlib import Path
from random import choice
from socket import gethostname
from time import sleep, time

from COUNTmodules \
    import binds, boinc_commands, files, instances, logs, times, utils, vcheck

# Need to check that Python interpreter is at least the required version.
vcheck.minversion('3.6')

try:
    import tkinter as tk
    from tkinter import messagebox, ttk
except (ImportError, ModuleNotFoundError) as error:
    print(f'This program requires tkinter, which is included with \n'
          'Python 3.7+ distributions.\n'
          'Install the most recent version or re-install Python and include Tk/Tcl.\n'
          '\nOn Linux, you may also need: $ sudo apt-get install python3-tk\n'
          f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

Binds = binds
BC = boinc_commands
Files = files
Instances = instances
Logs = logs.Logs()
T = times
Utils = utils
Tooltip = utils.Tooltip

__program_name__ = Instances.program_name()

MY_OS = sys.platform[:3]
LONG_STRFTIME = '%Y-%b-%d %H:%M:%S'
SHORT_STRFTIME = '%Y %b %d %H:%M'
SHORTER_STRFTIME = '%b %d %H:%M'
DAY_STRFTIME = '%A %H:%M'
NOTICE_INTERVAL = 15  # <- time.sleep() seconds


# ################ Useful functions, not part of MVC ###################
def parse_args() -> None:
    """Allow handling of common command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about',
                        help='Provides description, version, GNU license',
                        action='store_true',
                        default=False)
    args = parser.parse_args()
    if args.about:
        print(__doc__)
        print(f'{"Author:".ljust(13)}', __author__)
        print(f'{"Credits:".ljust(13)}', __credits__)
        print(f'{"License:".ljust(13)}', __license__)
        print(f'{"Copyright:".ljust(13)}', __copyright__)
        print(f'{"Program:".ljust(13)}', __program_name__)
        print(f'{"Version:".ljust(13)}', __version__)
        print(f'{"Dev Env:".ljust(13)}', __dev_environment__)
        print(f'{"URL:".ljust(13)}', __project_url__)
        print(f'{"Maintainer:".ljust(13)}', __maintainer__)
        print(f'{"Status:".ljust(13)}', __status__)
        print()
        sys.exit(0)


def check_boinc_tk() -> None:
    """
    Check whether BOINC client is running; quit app if not.
    Called before proceeding to implement settings and begin counting,
    and at each notice interval.
    """
    # Note: Any BC boinccmd will return this string (in a list)
    #   if boinc-client is not running. BC.get_version() is used b/c it
    #   is short. A similar function is BC.check_boinc(), but only for
    #   Terminal output; with GUI, need to use messagebox and destroy().
    if "can't connect to local host" in BC.get_version():
        okay = messagebox.askokcancel(
            title='BOINC ERROR',
            detail='BOINC commands cannot be executed.\n'
                   'Is the BOINC client running?\nExiting now...')
        if okay:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)
        else:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)


def quit_gui(keybind=None) -> None:
    """
    Error-free and informative exit from the program.
    Called from multiple widgets or keybindings.

    :param keybind: Implicit event passed from bind().
    """

    # Write exit message to an existing log file, even if the setting
    #   "log to file" was not selected, BUT not for additional instances.
    time_now = datetime.now().strftime(LONG_STRFTIME)
    quit_txt = f'\n{time_now}; *** User quit the program. ***\n'
    print(quit_txt)

    if Path.exists(Logs.LOGFILE):
        Files.append_txt(Logs.LOGFILE, quit_txt, False)
    # pylint: disable=broad-except
    try:
        app.update_idletasks()
        app.after(200)
        app.destroy()
    except Exception as unk:
        print(f'An error occurred: {unk}')
        if MY_OS == 'win':
            sentinel.close()
        sys.exit('Program exit with unexpected condition.')

    return keybind


# ############################ MVC Classes #############################
# MVC Modeler: The engine that gets BOINC data and runs count intervals.
class CountModeler:
    """
    Counting, statistical analysis, and formatting of BOINC task data.
    Communication with the Viewer Class for data display occurs via
    the 'share' parameter.
    """
    # Need to have these vars as Class attributes, so they will not be
    # reset when interval_data() is called.
    # ttimes_smry would be fine in __init__, but is here for clarity.
    ttimes_used = set()
    ttimes_smry = set()

    def __init__(self, share):
        self.share = share
        self.thread_lock = threading.Lock()
        self.task_count_start = 0
        self.task_count_new = 0
        # self.master is implicit as an internal attribute.

    def default_settings(self) -> None:
        """
        Set or reset default run parameters in the setting dictionary.
        """
        self.share.setting['interval_t'].set('1h')
        self.share.setting['interval_m'].set(60)
        self.share.intvl_choice['values'] = ('1h', '30m', '20m', '15m', '10m')
        self.share.intvl_choice.select_clear()
        self.share.setting['summary_t'].set('1d')
        self.share.setting['sumry_t_value'].set(1)
        self.share.setting['sumry_t_unit'].set('day')
        self.share.sumry_unit_choice['values'] = ('day', 'hr', 'min')
        self.share.sumry_unit_choice.select_clear()
        self.share.setting['cycles_max'].set(1008)
        self.share.setting['do_log'].set(True)
        self.share.setting['proj_update'].set(False)

    def start_data(self) -> None:
        """
        Gather initial task data and times; set data dictionary
        control variables. Log data to file if so optioned.
        Called from start_when_confirmed().
        """
        # As with task names, task times as sec.microsec are unique.
        #   In the future, may want to inspect task names with
        #     tnames = BC.get_reported('tasks').
        ttimes_start = BC.get_reported('elapsed time')
        self.share.data['task_count'].set(len(ttimes_start))
        self.share.data['num_tasks_all'].set(len(BC.get_tasks('name')))

        # Begin the set of used/old tasks to exclude from new tasks;
        #   used in interval_data() to track tasks across intervals.
        self.ttimes_used.update(ttimes_start)

        startdict = T.boinc_ttimes_stats(ttimes_start)
        self.share.data['tt_avg'].set(startdict['tt_avg'])
        self.share.data['tt_sd'].set(startdict['tt_sd'])
        self.share.data['tt_range'].set(
            f"{startdict['tt_min']} -- {startdict['tt_max']}")
        self.share.data['tt_total'].set(startdict['tt_total'])

        self.share.data['time_prev_cnt'].set('Last hourly BOINC report.')

        if self.share.setting['do_log'].get():
            self.log_it('start')

    def task_states(self) -> None:
        """
        Query boinc-client for status of tasks queued, running, and
        suspended; set corresponding dictionary tk control variables.
        Called from notice_it().
        """

        self.share.status_time = datetime.now().strftime(LONG_STRFTIME)
        tasks_all = BC.get_tasks('all')
        no_new_tasks = BC.no_new_tasks()

        # Need the literal task data tags as found in boinccmd stdout;
        #   the format is same as tag_str in BC.get_tasks().
        # Use tuple index to populate the list expressions instead of
        #   calling BC.get_tasks() for each tag.
        tags = ('   name: ',
                '   active_task_state: ',
                '   state: ')
        num_tasks_all = len([elem for elem in tasks_all if tags[0] in elem])
        tasks_active = [elem.replace(tags[1], '') for elem in tasks_all
                        if tags[1] in elem]
        task_states = [elem.replace(tags[2], '') for elem in tasks_all
                       if tags[2] in elem]

        # When communication to server is stalled, all tasks will be
        #  "Ready to report" with a state of 'uploaded', so a forced
        #   Project update in notice_it() may prompt finalizing
        #   the task upload.
        if 'uploaded' in task_states and 'downloaded' not in task_states:
            self.share.note['proj_stalled'].set(True)

        num_running = len(
            [task for task in tasks_active if 'EXECUTING' in task])
        num_suspended_by_boinc = len(
            [task for task in tasks_active if 'SUSPENDED' in task])
        num_suspended_by_user = len(
            [task for task in tasks_all if 'suspended via GUI: yes' in task])

        self.share.data['num_tasks_all'].set(num_tasks_all)
        self.share.note['num_running'].set(num_running)
        self.share.note['num_suspended_by_boinc'].set(num_suspended_by_boinc)
        self.share.note['num_suspended_by_user'].set(num_suspended_by_user)
        self.share.note['no_new_tasks'].set(no_new_tasks)

    def interval_data(self) -> None:
        """
        Run timer and countdown clock to update and analyze regular and
        summary data for task status and times. Set control variables
        for data and notice dictionaries.
        Is threaded as interval_thread; started in Viewer.start_threads()
        Calls to: get_minutes(), log_it().
        """
        ttimes_new = set()
        ttimes_smry = set()
        cycles_max = self.share.setting['cycles_max'].get()
        interval_m = self.share.setting['interval_m'].get()
        reference_time = time()
        tic_nnt = 0
        sumry_intvl_counts = []
        sumry_intvl_ttavgs = []

        for cycle in range(cycles_max):
            if cycle == 1:
                # Need to change button name and function from Start to Interval
                #   after initial cycle[0] completes and intvl data displays.
                #  It might be better if statement were in Viewer, but simpler
                #  to put it here with easy reference to cycle.
                self.share.intvl_b.grid(row=0, column=1,
                                        padx=(16, 0), pady=(8, 4))
                self.share.starting_b.grid_forget()
            # Need to sleep between counts while displaying a countdown timer.
            # Need to limit total time of interval to target_elapsed_time,
            #   in Epoch seconds, b/c each interval sleep cycle will run longer
            #   than the intended interval. Realized interval time should thus
            #   not drift by more than 1 second during count_max cycles.
            #   Without this time limit, each 1h interval would gain ~4s.
            interval_sec = interval_m*60
            target_elapsed_time = reference_time + (interval_sec * (cycle + 1))
            for _sec in range(interval_sec):
                if cycle == cycles_max:
                    break
                if time() > target_elapsed_time:
                    self.share.data['time_next_cnt'].set('00:00')
                    break
                interval_sec -= 1
                # Need to show the time remaining in clock time format.
                self.share.data['time_next_cnt'].set(
                    T.sec_to_format(interval_sec, 'clock'))
                sleep(1.0)

            # NOTE: Starting tasks are not included in interval and summary
            #   counts, but starting task times are used here to determine
            #   "new" tasks.
            # Need to add all prior tasks to the "used" set.
            #  "new" task times are carried over from the prior interval cycle.
            #  For cycle[0], ttimes_used is starting tasks from start_data()
            #    and ttimes_new is empty.
            with self.thread_lock:
                self.ttimes_used.update(ttimes_new)
                ttimes_reported = set(BC.get_reported('elapsed time'))

                # Need to reset prior ttimes_new, then repopulate it with only
                #   newly reported tasks.
                ttimes_new.clear()
                ttimes_new = ttimes_reported - self.ttimes_used

                task_count_new = len(ttimes_new)
                self.share.data['task_count'].set(task_count_new)
                # Add new tasks to summary set for later analysis.
                ttimes_smry.update(ttimes_new)

                cycles_remain = int(self.share.data['cycles_remain'].get()) - 1
                self.share.data['cycles_remain'].set(cycles_remain)
                # Display weekday with time of previous interval to aid the user.
                self.share.data['time_prev_cnt'].set(
                    datetime.now().strftime(DAY_STRFTIME))
                # Capture full ending time here, instead of in log_it(),
                #   so that the logged time matches displayed time.
                self.share.data['intvl_count_t'].set(
                    datetime.now().strftime(LONG_STRFTIME))

                # Track when no new tasks were reported in past interval;
                #   tic_nnt used in log_it().
                # Need to update num_running value from task_states().
                self.task_states()
                num_running = self.share.note['num_running'].get()

                if task_count_new == 0:
                    tic_nnt += 1
                elif task_count_new > 0 and num_running > 0:
                    tic_nnt = 0
                self.share.note['tic_nnt'].set(tic_nnt)

                intervaldict = T.boinc_ttimes_stats(ttimes_new)
                self.share.data['tt_avg'].set(intervaldict['tt_avg'])
                self.share.data['tt_sd'].set(intervaldict['tt_sd'])
                self.share.data['tt_range'].set(
                    f"{intervaldict['tt_min']} -- {intervaldict['tt_max']}")
                self.share.data['tt_total'].set(intervaldict['tt_total'])

                # Need to gather interval times and counts for ea. interval in
                #   a summary segment to calc weighted mean times. This sumry
                #   list has a different function than the ttimes_smry set.
                sumry_intvl_counts.append(task_count_new)
                sumry_intvl_ttavgs.append(self.share.data['tt_avg'].get())

                # SUMMARY DATA #########################################
                # NOTE: Starting data are not included in summary tabulations.
                summary_m = T.string_to_min(self.share.setting['summary_t'].get())
                # When summary interval is >= 1 week, need to provide date of
                #   prior summary rather than weekday, as above (%A %H:%M).
                if summary_m >= 10080:
                    self.share.data['time_prev_cnt'].set(
                        datetime.now().strftime(SHORTER_STRFTIME))
                summary_time = self.share.data['time_prev_cnt'].get()

                if (cycle + 1) % (summary_m // interval_m) == 0 and num_running > 0:
                    # Flag used in log_it() to log summary data.
                    self.share.data['log_summary'].set(True)
                    # Need to deactivate tooltip and activate the Summary
                    #  data button now; only need these statements for
                    #  1st summary, but, oh well, here we go again...
                    Tooltip(self.share.sumry_b, '', 'disabled')
                    self.share.sumry_b.config(state=tk.NORMAL)

                    # Set time and stats of summary count.
                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(len(ttimes_smry))
                    summarydict = T.boinc_ttimes_stats(ttimes_smry)
                    self.share.data['tt_sd_sumry'].set(summarydict['tt_sd'])
                    self.share.data['tt_range_sumry'].set(
                        f"{summarydict['tt_min']} -- {summarydict['tt_max']}")
                    self.share.data['tt_total_sumry'].set(summarydict['tt_total'])

                    # Need the weighted mean summary task time, not the average
                    #   (arithmetic mean) value.
                    tt_wtmean = T.logtimes_stat(
                        sumry_intvl_ttavgs, 'wtmean', sumry_intvl_counts)
                    self.share.data['tt_mean_sumry'].set(tt_wtmean)

                    # Need to reset data set for the next summary interval.
                    ttimes_smry.clear()
                    sumry_intvl_counts.clear()
                    sumry_intvl_ttavgs.clear()

                elif (cycle + 1) % (summary_m // interval_m) == 0 and num_running == 0:
                    self.share.data['log_summary'].set(True)
                    Tooltip(self.share.sumry_b, '', 'disabled')
                    self.share.sumry_b.config(state=tk.NORMAL)

                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(0)
                    self.share.data['tt_mean_sumry'].set('n/a')
                    self.share.data['tt_sd_sumry'].set('n/a')
                    self.share.data['tt_range_sumry'].set('n/a')
                    self.share.data['tt_total_sumry'].set('n/a')

            # Call to log_it() needs to be outside the thread lock.
            app.update_idletasks()
            if self.share.setting['do_log'].get():
                self.log_it('interval')

    def notice_it(self) -> None:
        """
        Notices for BOINC task state information should run on short
        time intervals. A NOTICE_INTERVAL of 15 works well.
        Is threaded as notice_thread; started in Viewer.start_threads().
        Calls to: check_boinc_tk(), task_states(), and log_it().
        """
        notice_cycle_number = 0
        while self.share.data['cycles_remain'].get() > 0:
            sleep(NOTICE_INTERVAL)
            with self.thread_lock:
                # Need to quit app if boinc-client is no longer running.
                check_boinc_tk()

                # Need to keep track of cycles for regulate Utils.beep() calls.
                notice_cycle_number += 1

                self.task_states()
                num_running = self.share.note['num_running'].get()
                num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
                num_suspended_by_boinc = self.share.note['num_suspended_by_boinc'].get()
                num_tasks_all = self.share.data['num_tasks_all'].get()
                tic_nnt = self.share.note['tic_nnt'].get()
                proj_stalled = self.share.note['proj_stalled'].get()
                no_new_tasks = self.share.note['no_new_tasks'].get()
                cycles_max = self.share.setting['cycles_max'].get()
                cycles_remain = self.share.data['cycles_remain'].get()
                interval_m = self.share.setting['interval_m'].get()

                # Need to change to notice fg color from "All is well" row_fg color.
                self.share.notice_l.config(fg=self.share.highlight)

                # Need notices for task status that might need user attention,
                #   conditioned in descending priority.
                if num_running > 0:
                    if num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'{num_suspended_by_user} tasks are suspended by user.\n'
                            'BOINC will not upload while tasks are suspended.')
                    elif num_running >= (num_tasks_all - 1):
                        self.share.note['notice_txt'].set(
                            'BOINC client is about to run out of tasks.\n'
                            'Check BOINC Manager.')
                    elif tic_nnt > 0:
                        nnt_time = T.sec_to_format(
                            (tic_nnt * interval_m * 60), 'short')
                        self.share.note['notice_txt'].set(
                            f'NO TASKS reported in past {nnt_time}\n'
                            f'for the prior {tic_nnt} counting interval(s).')
                    else:
                        # Everything is fine, remove any prior notice.
                        # Use a de-emphasized color for this non-notice status text.
                        self.share.notice_l.config(fg=self.share.row_fg)
                        self.share.note['notice_txt'].set(
                            f'All is well (updates every {NOTICE_INTERVAL} seconds)')

                if num_running == 0:
                    if proj_stalled:
                        if self.share.setting['proj_update'].get():
                            # Note: this will sleep notice_it() for 70 seconds.
                            self.update_project()
                        else:
                            self.share.note['notice_txt'].set(
                                'A PROJECT UPDATE MAY BE NEEDED.\n'
                                'Check BOINC Manager.')
                    elif num_tasks_all == 0:
                        self.share.note['notice_txt'].set(
                            'BOINC client has no tasks to run!\n'
                            'Check BOINC Manager.')
                        if no_new_tasks:
                            self.share.note['notice_txt'].set(
                                'BOINC client has no tasks to run!\n'
                                'Project is set to receive no new tasks.\n'
                                'Check BOINC Manager Projects.')
                    elif num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'NO TASKS running; {num_suspended_by_user} tasks suspended by user.\n'
                            'You may want to resume them.')
                        if self.share.setting['sound_beep'].get() and tic_nnt > 1:
                            # Call beep() every other notice cycle. If
                            # change the modulo, then also change the
                            # Settings window Tooltip text for beep timing.
                            if notice_cycle_number % 2 == 0:
                                Utils.beep(2)
                    elif num_suspended_by_boinc > 0:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running.\n'
                            'A BOINC Manager "When to suspend" condition was met.\n'
                            'Edit BOINC Manager Computing preferences if this is a problem.')
                    else:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running; reason unknown\nCheck BOINC Manager.')
                        if self.share.setting['sound_beep'].get() and tic_nnt > 1:
                            # Call beep() every other notice cycle. If
                            # change the modulo, then also change the
                            # Settings window Tooltip text for beep timing.
                            if notice_cycle_number % 2 == 0:
                                Utils.beep(2)

                if cycles_remain == 0:
                    prior_note = self.share.note['notice_txt'].get()
                    if prior_note:
                        self.share.note['notice_txt'].set(
                            f'{prior_note}\n'
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    else:
                        self.share.note['notice_txt'].set(
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    print(f'\n*** {cycles_max} of {cycles_max} counting cycles have ended. ***\n')

            app.update_idletasks()
            # Call to log_it() here needs to be outside the thread lock.
            if self.share.setting['do_log'].get():
                self.log_it('notice')

    def log_it(self, called_from: str) -> None:
        """
        Write interval and summary metrics for recently reported
        BOINC tasks. Provide information on aberrant task status.
        Called from interval_data() and notice_it().
        Is threaded as log_thread; started in Viewer.start_threads().

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """

        # Var used for log text formatting:
        indent = ' ' * 22
        bigindent = ' ' * 33

        # NOTE: any change to log text format or structure needs to be tracked
        #   by data extraction regex in Logs.analyze_logfile().
        # Note: Lots of local variables are used here to make the notice text
        #   statements easier to read.
        # Var outside of thread lock are set in settings() and thus invariant.
        cycles_max = self.share.setting['cycles_max'].get()
        interval_t = self.share.setting['interval_t'].get()
        summary_t = self.share.setting['summary_t'].get()
        with self.thread_lock:
            intvl_count_t = self.share.data['intvl_count_t'].get()
            if called_from == 'start':
                self.task_count_start = self.share.data['task_count'].get()
            elif called_from == 'interval':
                self.task_count_new = self.share.data['task_count'].get()
            tt_avg = self.share.data['tt_avg'].get()
            tt_sd = self.share.data['tt_sd'].get()
            tt_range = self.share.data['tt_range'].get()
            tt_total = self.share.data['tt_total'].get()
            num_tasks_all = self.share.data['num_tasks_all'].get()
            cycles_remain = self.share.data['cycles_remain'].get()
            num_running = self.share.note['num_running'].get()
            num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
            no_new_tasks = self.share.note['no_new_tasks'].get()
            tic_nnt = self.share.note['tic_nnt'].get()

            if called_from == 'start' and cycles_max > 0:
                report = (
                    f'\n>>> START GUI TASK COUNTER v.{__version__}, SETTINGS: <<<\n'
                    f'{self.share.long_time_start};'
                    ' Number of tasks in the most recent BOINC report:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}Number of scheduled count intervals: {cycles_max}\n'
                    f'{indent}Counts every {interval_t}, summaries every {summary_t}.\n'
                    f'{indent}BOINC status evaluations every {NOTICE_INTERVAL}s.\n'
                    f'{indent}Project auto-update:'
                    f" {self.share.setting['proj_update'].get()}\n\n"
                    'Timed intervals beginning now...\n')
                logging.info(report)
            # Need to provide a truncated report for one-off "status" runs.
            elif called_from == 'start' and cycles_max == 0:
                report = (
                    f'\n{self.share.long_time_start}; STATUS REPORT\n'
                    f'{indent}Number of tasks recently reported by BOINC:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n')
                logging.info(report)

            # Note: Two timestamps are used: self.share.data['intvl_count_t']
            #   is defined in interval_data() at end of each count cycle,
            #   self.share.status_time is defined in task_states().
            if called_from == 'notice' and num_running > 0:
                # A Notice for no new tasks reported, tic_nnt, is issued in
                #   interval_data() instead of here.
                if num_running == num_tasks_all:
                    report = (f'\n{self.share.status_time};'
                              'BOINC client is about to run out of tasks.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'\n{self.share.status_time}; '
                              f'{num_suspended_by_user} tasks are suspended by user.')
                    logging.info(report)
            elif called_from == 'notice' and num_running == 0:
                report = (f'\n{self.share.status_time};'
                          ' *** NO TASKS RUNNING. Check BOINC Manager.***')
                logging.info(report)
                if self.share.note['proj_stalled'].get():
                    report = (
                        f' *** PROJECT AUTO-UPDATE REQUESTED for {self.share.first_project}. ***\n'
                        '  All tasks were "Ready to report" and waiting to upload.\n'
                        '  If Project auto-update is allowed, tasks should now be uploaded.\n'
                        '  Verify in BOINC Manager.')
                    logging.info(report)
                if num_tasks_all == 0:
                    report = f'{indent}BOINC client has no tasks!\n'
                    logging.info(report)
                if self.share.note['num_suspended_by_boinc'].get() > 0:
                    report = (f'{indent}BOINC Manager has suspended tasks;\n'
                              f'{indent}A "When to suspend" condition was met\n'
                              f'{indent}in BOINC Manager Computing preferences.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'{indent}'
                              f'{num_suspended_by_user} tasks suspended by user.')
                    logging.info(report)
                if no_new_tasks:
                    report = (f'{indent}Not receiving new tasks.\n'
                              f'{indent}Check BOINC Manager Projects.')
                    logging.info(report)

            if called_from == 'interval' and tic_nnt > 0:
                report = (f'\n{intvl_count_t}; NO TASKS reported in the past'
                          f' {tic_nnt} counting intervals.\n'
                          f'{indent}{cycles_remain} counts remain.')
                logging.info(report)

            # This tic condition is equivalent to: task_count_new > 0 and
            #   num_running > 0; that is, everything normal.
            elif called_from == 'interval' and tic_nnt == 0:
                report = (
                    f'\n{intvl_count_t}; Tasks reported in the past {interval_t}:'
                    f' {self.task_count_new}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}{cycles_remain} counts remain.'
                )
                logging.info(report)

            if called_from == 'interval' and self.share.data['log_summary'].get():
                report = (
                    f'\n{intvl_count_t}; >>> SUMMARY: Count for the past'
                    f" {summary_t}: {self.share.data['task_count_sumry'].get()}\n"
                    f"{indent}Task Time: mean {self.share.data['tt_mean_sumry'].get()},\n"
                    f"{bigindent}range [{self.share.data['tt_range_sumry'].get()}],\n"
                    f"{bigindent}stdev {self.share.data['tt_sd_sumry'].get()},"
                    f" total {self.share.data['tt_total_sumry'].get()}")
                logging.info(report)

                # Need to reset flag to toggle summary logging.
                self.share.data['log_summary'].set(False)

            if called_from == 'interval' and cycles_remain == 0:
                report = f'\n### {cycles_max} counting cycles have ended. ###\n'
                logging.info(report)

    def update_project(self) -> None:
        """
        Called from notice_it() when auto-update project setting is True.
        """
        # I'm not sure how to handle multiple concurrent Projects.
        # B/c of how BC.project_action is structured, here I use the
        #  url to get the Project name ID which is used to get the
        #  url needed for the project cmd.  Silly, but uses existing
        #  boinc_commands.py methods. Is there a better way?
        first_local_url = BC.get_project_url()[0]
        self.share.first_project = list(BC.project_url().keys())[
            list(BC.project_url().values()).index(first_local_url)]
        BC.project_action(self.share.first_project, 'update')
        self.share.note['notice_txt'].set(
            'Project auto-update in progress for'
            f' {self.share.first_project}...')

        if self.share.setting['do_log'].get():
            self.log_it('notice')
        # Need to provide time for BOINC Project server to respond before
        #   continuing with notice_it() thread.
        sleep(70)


# ###### MVC Viewer: the tkinter GUI engine; runs in main thread. ######
class CountViewer(tk.Frame):
    """
    The MVC Viewer represents the master Frame for the main window.
    All main window GUI and data widgets are defined here. Communication
    with the Modeler Class for data manipulation occurs via the 'share'
    parameter.
    """

    def __init__(self, share):
        super().__init__()
        self.share = share
        self.dataframe = tk.Frame()
        self.menubar = tk.Menu()
        # self.master is an implicit internal attribute.

        # Set colors for row labels and data display.
        # These colors are compatible with red-green color-blindness.
        self.share.row_fg = 'LightYellow'  # Row header label fg.
        self.master_bg = 'SteelBlue4'  # app and header label bg.
        self.data_bg = 'grey40'  # Data labels and data frame bg.
        self.share.highlight = 'gold1'  # Notices, compliments, highlight fg.
        self.emphasize = 'grey90'  # Lighter data label fg, use for grey-out.
        self.deemphasize = 'grey60'  # Darker data label fg.

        # Need to grey-out menu bar headings and View log button when
        #   another application has focus.
        #   source: https://stackoverflow.com/questions/18089068/
        #   tk-tkinter-detect-application-lost-focus
        self.bind_all('<FocusIn>', self.app_got_focus)
        self.bind_all('<FocusOut>', self.app_lost_focus)

        # settings() window widgets:
        self.settings_win = tk.Toplevel()
        self.share.intvl_choice = ttk.Combobox(self.settings_win)
        self.sumry_value_entry = ttk.Entry(self.settings_win)
        self.share.sumry_unit_choice = ttk.Combobox(self.settings_win)
        self.cycles_max_entry = ttk.Entry(self.settings_win)
        self.countnow_button = ttk.Button(self.settings_win)
        self.log_choice = tk.Checkbutton(self.settings_win)
        self.update_choice = tk.Checkbutton(self.settings_win)
        self.beep_choice = tk.Checkbutton(self.settings_win)

        # Control variables for basic run parameters/settings passed
        #    between Viewer and Modeler.
        self.share.setting = {
            'interval_t': tk.StringVar(),
            'interval_m': tk.IntVar(),
            'sumry_t_value': tk.StringVar(),
            'sumry_t_unit': tk.StringVar(),
            'summary_t': tk.StringVar(),
            'cycles_max': tk.IntVar(),
            'do_log': tk.BooleanVar(),
            'proj_update': tk.BooleanVar(),
            'sound_beep': tk.BooleanVar()
        }

        # Control variables for display in master; data passed between
        #    Viewer and Modeler.
        self.share.data = {
            # Start and Interval data
            'task_count': tk.IntVar(),
            'tt_avg': tk.StringVar(),
            'tt_sd': tk.StringVar(),
            'tt_range': tk.StringVar(),
            'tt_total': tk.StringVar(),
            'intvl_count_t': tk.StringVar(),
            # General data
            'time_prev_cnt': tk.StringVar(),
            'cycles_remain': tk.IntVar(),
            'time_next_cnt': tk.StringVar(),
            'num_tasks_all': tk.IntVar(),
            # Summary data
            'time_prev_sumry': tk.StringVar(),
            'task_count_sumry': tk.IntVar(),
            'tt_mean_sumry': tk.StringVar(),
            'tt_sd_sumry': tk.StringVar(),
            'tt_range_sumry': tk.StringVar(),
            'tt_total_sumry': tk.StringVar(),
            'log_summary': tk.BooleanVar()
        }

        # Control variables for notices and logging passed between
        #   Viewer and Modeler and between Modeler threads.
        self.share.note = {
            'notice_txt': tk.StringVar(),
            'num_running': tk.IntVar(),
            'tic_nnt': tk.IntVar(),
            'proj_stalled': tk.BooleanVar(),
            'no_new_tasks': tk.BooleanVar(),
            'num_suspended_by_user': tk.IntVar(),
            'num_suspended_by_boinc': tk.IntVar(),
        }

        # Labels for settings values; gridded in master_layout(). They are
        #   fully configured here simply to reduce number of lines in code.
        # NOTE: self.time_start_l label is initially configured for text to
        #   show a startup message, then reconfigured in emphasize_start_data()
        #   for the time_start.
        self.time_start_l = tk.Label(
            self.dataframe, bg=self.data_bg, fg='grey90')
        self.interval_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['interval_t'],
            relief='groove', bg=self.data_bg)
        self.summary_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['summary_t'],
            relief='groove', bg=self.data_bg)
        self.cycles_max_l = tk.Label(
            textvariable=self.share.setting['cycles_max'],
            bg=self.master_bg, fg=self.share.row_fg)

        # Labels for BOINC data.
        self.task_count_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count'])
        self.tt_avg_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_avg'])
        self.tt_sd_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd'])
        self.tt_range_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range'])
        self.tt_total_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total'])
        self.task_count_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count_sumry'])
        self.ttmean_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_mean_sumry'])
        self.ttsd_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd_sumry'])
        self.ttrange_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range_sumry'])
        self.ttsum_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total_sumry'])

        # Master data labels (self.master is implicit as the parent).
        self.time_prev_cnt_l = tk.Label(
            textvariable=self.share.data['time_prev_cnt'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_prev_sumry_l = tk.Label(
            textvariable=self.share.data['time_prev_sumry'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_next_cnt_l = tk.Label(
            textvariable=self.share.data['time_next_cnt'],
            bg=self.master_bg, fg=self.share.highlight)
        self.cycles_remain_l = tk.Label(
            textvariable=self.share.data['cycles_remain'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.num_tasks_all_l = tk.Label(
            textvariable=self.share.data['num_tasks_all'],
            bg=self.master_bg, fg=self.share.row_fg)
        # Text for compliment_l is configured in compliment_me()
        self.share.compliment_l = tk.Label(
            bg=self.master_bg, fg=self.share.highlight)
        self.share.notice_l = tk.Label(
            textvariable=self.share.note['notice_txt'],
            fg=self.share.highlight, bg=self.master_bg,
            relief='flat', border=0)

        # This style is used only to configure viewlog_b color in
        #   app_got_focus() and app_lost_focus().
        #   self.master is implicit as the parent.
        self.view_button_style = ttk.Style()

        # Need to define image as a class variable, not a local var in methods.
        self.info_button_img = tk.PhotoImage(
            file=Utils.absolute_path_to('images/info_button20.png'))

        self.master_widgets()
        self.master_layout()
        self.share.defaultsettings()
        self.settings()

    def master_widgets(self) -> None:
        """
        Master app menus and buttons.
        """

        # Note that self.master is an internal attribute and refers to
        #   the CountController() Tk mainloop toplevel window. May use
        #   'app' in place of self.master for lambda functions here, but
        #   outside CountViewer, must use 'app' to reference mainloop.

        self.master.config(menu=self.menubar)

        # Add pull-down menus
        file = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='File', menu=file)
        file.add_command(
            label='Backup log file',
            command=lambda: Files.save_as(Logs.LOGFILE))
        file.add_command(
            label='Backup analysis file',
            command=lambda: Files.save_as(Logs.ANALYSISFILE))
        file.add_separator()
        file.add_command(label='Quit', command=quit_gui,
                         accelerator='Ctrl+Q')
        # ^^ Note: use Ctrl+Q for macOS also to call quit_gui; Cmd+Q still works.

        view = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='View', menu=view)
        view.add_command(label='Log file',
                         command=lambda: Logs.view(Logs.LOGFILE, app),
                         # MacOS: can't display 'Cmd+L' b/c won't override native cmd.
                         accelerator='Ctrl+L')
        view.add_command(label='Analysis of log data',
                         command=lambda: Logs.show_analysis(app),
                         accelerator='Ctrl+Shift+L')
        view.add_command(label='Saved Analyses',
                         command=lambda: Logs.view(Logs.ANALYSISFILE, app),
                         accelerator='Ctrl+Shift+A')

        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='Help', menu=help_menu)
        help_menu.add_command(label='Information', command=self.share.info)
        help_menu.add_command(label='Compliment',
                              command=self.share.compliment,
                              accelerator='Ctrl+Shift+C')
        help_menu.add_command(label='File paths',
                              command=lambda: self.share.filepaths(app))
        help_menu.add_command(label='About', command=self.share.about)

        # For Button constructors, self.master is implicit as the parent.
        self.share.viewlog_b = ttk.Button(
            text='View log file',
            command=lambda: Logs.view(Logs.LOGFILE, app),
            takefocus=False)
        # Set interval & summary focus button attributes with *.share.* b/c need
        #   to reconfigure them in Modeler.
        # starting_b will be replaced with an active ttk intvl_b after first
        #   interval completes; it is re-gridded in interval_data().
        # starting_b is tk.B b/c ttk.B doesn't use disabledforeground keyword.
        self.share.starting_b = tk.Button(
            text='Starting data', width=18,
            disabledforeground='grey10', state=tk.DISABLED,
            takefocus=False)
        self.share.intvl_b = ttk.Button(
            text='Interval data', width=18,
            command=self.emphasize_intvl_data,
            takefocus=False)
        self.share.sumry_b = ttk.Button(
            text='Summary data', width=20,
            command=self.emphasize_sumry_data,
            takefocus=False)

    def master_layout(self) -> None:
        """
        Master and dataframe configuration, keybindings, row headers,
        separators, and grids.
        """

        # OS-specific window size ranges set in Controller __init__
        # Need to color in all the master Frame and use near-white border;
        #   bd changes to darker shade for click-drag and loss of focus.
        self.master.config(bg=self.master_bg,
                           highlightthickness=3,
                           highlightcolor='grey95',
                           highlightbackground='grey75'
                           )
        # Need to provide exit info to Terminal and log.
        self.master.protocol('WM_DELETE_WINDOW', quit_gui)

        self.master.bind_all('<Escape>', quit_gui)
        self.master.bind('<Control-q>', quit_gui)
        # ^^ Note: macOS Command-q will quit program without quit_gui info msg.
        # Note: Toplevel key bindings are set with module Binds.keyboard().
        self.master.bind('<Control-l>',
                         lambda _: Logs.view(Logs.LOGFILE, app))
        self.master.bind('<Shift-Control-L>', lambda _: Logs.show_analysis(app))
        self.master.bind('<Shift-Control-A>',
                         lambda _: Logs.view(Logs.ANALYSISFILE, app))
        self.master.bind('<Shift-Control-C>', lambda _: self.share.compliment())

        # Need to specify Ctrl-a for Linux b/c in tkinter that key is
        #   bound to the tkinter predefined virtual event <<LineStart>>,
        #   not <<SelectAll>>, for some reason? And  Shift-Control-A
        #   will select text from cursor to <<LineStart>>.
        if MY_OS in 'lin':
            def select_all():
                app.focus_get().event_generate('<<SelectAll>>')

            self.master.bind_all('<Control-a>', lambda _: select_all())

            def select_none():
                app.focus_get().event_generate('<<SelectNone>>')

            self.master.bind_all('<Shift-Control-A>', lambda _: select_none())

        # Theme controls entire window theme, but only for ttk.Style objects.
        # Options: classic, alt, clam, default, aqua(MacOS only)
        ttk.Style().theme_use('alt')

        self.master.columnconfigure(1, weight=1)
        self.master.columnconfigure(2, weight=1)

        self.dataframe.configure(borderwidth=3, relief='sunken',
                                 bg=self.data_bg)
        self.dataframe.grid(row=2, column=1, rowspan=7, columnspan=2,
                            padx=(5, 10), sticky=tk.NSEW)
        self.dataframe.columnconfigure(1, weight=1)
        self.dataframe.columnconfigure(2, weight=1)

        # Fill in headers for all data rows.
        row_header = {
            #'Counting since': 2,
            'Count interval, t': 3,
            '# tasks reported': 4,
            'Task times:  avg': 5,
            'stdev': 6,
            'range': 7,
            'total': 8,
            'Datetime, interval:': 10,
            'Next count in:': 11,
            'Tasks in queue:': 12,
            'Notices:': 13
        }

        for header, rownum in row_header.items():
            tk.Label(
                text=f'{header}', bg=self.master_bg, fg=self.share.row_fg
            ).grid(row=rownum, column=0, padx=(5, 0), pady=(0, 1), sticky=tk.NE)
            # ^^ Grid to N or NE to prevent Notices label from shifting down
            #    when more than one row of notice_it() text appears.
            #    For all Label constructors, self.master parent is implicit.

        # Pady first row to better align headers with data in dataframe.
        tk.Label(
            text='Counting since', bg=self.master_bg, fg=self.share.row_fg
        ).grid(row=2, column=0, padx=(5, 0), pady=(3, 0), sticky=tk.NE)

        # Need to accommodate cases of two headers in same row.
        tk.Label(text='summary:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=10, column=2, sticky=tk.W)
        tk.Label(text='Counts until exit:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=12, column=2, sticky=tk.W)

        # For colored separators, use ttk.Frame instead of ttk.Separator.
        # Initialize then configure style for separator color.
        style_sep = ttk.Style()
        style_sep.configure('Sep.TFrame', background=self.master_bg)
        sep1 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)
        sep2 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)

        # %%%%%%%%%%%%%%%%%%% grid: sorted by row number %%%%%%%%%%%%%%%%%%%%%%
        self.share.viewlog_b.grid(
            row=0, column=0, padx=5, pady=(8, 4))
        self.share.starting_b.grid(
            row=0, column=1, padx=(16, 0), pady=(6, 4))
        self.share.sumry_b.grid(
            row=0, column=2, padx=(0, 20), pady=(8, 4))
        sep1.grid(
            row=1, column=0, columnspan=5, padx=5, pady=(2, 5), sticky=tk.EW)
        self.time_start_l.grid(  # No padx + sticky EW = centered.
            row=2, column=1, columnspan=2, sticky=tk.EW)
        self.interval_t_l.grid(
            row=3, column=1, padx=(10, 8), sticky=tk.EW)
        self.summary_t_l.grid(
            row=3, column=2, padx=(0, 12), sticky=tk.EW)
        self.task_count_l.grid(
            row=4, column=1, padx=12, sticky=tk.EW)
        self.task_count_sumry_l.grid(
            row=4, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_avg_l.grid(
            row=5, column=1, padx=12, sticky=tk.EW)
        self.ttmean_sumry_l.grid(
            row=5, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_sd_l.grid(
            row=6, column=1, padx=12, sticky=tk.EW)
        self.ttsd_sumry_l.grid(
            row=6, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_range_l.grid(
            row=7, column=1, padx=12, sticky=tk.EW)
        self.ttrange_sumry_l.grid(
            row=7, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_total_l.grid(
            row=8, column=1, padx=12, sticky=tk.EW)
        self.ttsum_sumry_l.grid(
            row=8, column=2, padx=(0, 12), sticky=tk.EW)
        sep2.grid(
            row=9, column=0, columnspan=5, padx=5, pady=(6, 6), sticky=tk.EW)
        self.time_prev_cnt_l.grid(
            row=10, column=1, columnspan=2, padx=3, sticky=tk.W)
        self.time_prev_sumry_l.grid(
            row=10, column=2, padx=(73, 0), sticky=tk.W)
        self.time_next_cnt_l.grid(
            row=11, column=1, padx=3, sticky=tk.W)
        self.num_tasks_all_l.grid(
            row=12, column=1, padx=3, sticky=tk.W)

        # Place cycles_remain value in same cell as its header, but shifted right.
        if MY_OS in 'lin, dar':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(123, 0), sticky=tk.W)
        elif MY_OS == 'win':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(110, 0), sticky=tk.W)

        #   Need pady for alignment with the row header.
        self.share.notice_l.grid(
            row=13, column=1, columnspan=2, rowspan=2, padx=5, pady=(1, 0),
            sticky=tk.NW)
        self.share.compliment_l.grid(
            row=14, column=1, columnspan=2, padx=5, sticky=tk.W)

        # Some control variables have default or initial start values,
        #   so make labels invisible in pre-settings dataframe by matching
        #   them to the background color.
        self.interval_t_l.config(foreground=self.data_bg)
        self.summary_t_l.config(foreground=self.data_bg)
        self.task_count_l.config(foreground=self.data_bg)
        self.task_count_sumry_l.config(foreground=self.data_bg)

    def settings(self) -> None:
        """
        Configures the Toplevel window that appears at startup.
        Confirms default parameters or sets new ones for count and
        summary interval times, counting limit, and log file option.
        """
        # Toplevel window basics
        self.settings_win.title('Set run settings')
        self.settings_win.resizable(False, False)
        self.settings_win.config(relief='raised', bg=self.master_bg,
                                 highlightthickness=3,
                                 highlightcolor=self.share.highlight,
                                 highlightbackground=self.deemphasize)

        # Need to make settings window topmost to place it above the
        #   app window.
        if MY_OS in 'lin, win':
            self.settings_win.attributes('-topmost', True)
        # In macOS, topmost places Combobox selections BEHIND the window,
        #    but focus_force() makes it visible; must be a tkinter bug?
        elif MY_OS == 'dar':
            self.settings_win.focus_force()

        settings_style = ttk.Style()
        settings_style.configure('Set.TLabel', background=self.master_bg,
                                 foreground=self.share.row_fg)

        # Need text in master window to prompt user to enter settings.
        #   The message text may be covered by the settings_win, but is
        #   seen if user drags settings_win away.
        self.time_start_l.configure(text='Waiting for run settings...')

        # Inner functions for window and selection control and user FYI:

        # Need to disable default window Exit; only allow exit from active
        #   Confirm button.
        def no_exit_on_x():
            messagebox.showinfo(
                parent=self.settings_win,
                title='Invalid exit',
                detail='"Count now" button closes window and begins'
                       ' counting. Or you can quit program from the main'
                       ' window (or "Esc" key) without starting counts.')

        self.settings_win.protocol('WM_DELETE_WINDOW', no_exit_on_x)

        def update_intvl():
            self.share.intvl_choice['values'] = sumry_unit[self.share.sumry_unit_choice.get()]

        def update_sumry_unit():
            self.share.sumry_unit_choice['values'] = interval_t[self.share.intvl_choice.get()]

        # Settings widget construction and configurations.
        intvl_label = ttk.Label(self.settings_win, text='Count time interval',
                                style='Set.TLabel')
        interval_t = {'1h': ('day', 'hr'),
                      '30m': ('day', 'hr'),
                      '20m': ('hr', 'min'),
                      '15m': ('hr', 'min'),
                      '10m': ('hr', 'min'),
                      }
        self.share.intvl_choice.configure(
            state='readonly', width=4, height=5,
            textvariable=self.share.setting['interval_t'],
            values=tuple(interval_t.keys()))
        self.share.intvl_choice.bind(
            '<<ComboboxSelected>>', lambda _: update_sumry_unit())
        self.share.setting['interval_t'].set(self.share.intvl_choice.get())

        sumry_label1 = ttk.Label(
            self.settings_win, text='Summary interval: time value',
            style='Set.TLabel')
        self.sumry_value_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['sumry_t_value'],
            validatecommand=(
                self.sumry_value_entry.register(Utils.enter_only_digits), '%P', '%d'))

        sumry_label2 = ttk.Label(
            self.settings_win, text='time unit', style='Set.TLabel')
        sumry_unit = {'day': ('1h', '30m'),
                      'hr': ('30m', '20m', '15m', '10m'),
                      'min': ('20m', '15m', '10m')
                      }
        self.share.sumry_unit_choice.configure(
            state='readonly', width=4,
            textvariable=self.share.setting['sumry_t_unit'],
            values=tuple(sumry_unit.keys()))
        self.share.sumry_unit_choice.bind(
            '<<ComboboxSelected>>', lambda _: update_intvl())
        self.share.setting['sumry_t_unit'].set(self.share.sumry_unit_choice.get())

        # Specify number limit of counting cycles to run.
        cycles_label = ttk.Label(self.settings_win, text='# Count cycles',
                                 style='Set.TLabel')
        self.cycles_max_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['cycles_max'],
            validatecommand=(
                self.cycles_max_entry.register(Utils.enter_only_digits), '%P', '%d'))

        # Provide user options for logging results to file and using auto-update.
        log_label = ttk.Label(self.settings_win,
                              text='Log results to file',
                              style='Set.TLabel')
        self.log_choice.configure(variable=self.share.setting['do_log'],
                                  bg=self.master_bg, borderwidth=0)

        update_label = ttk.Label(self.settings_win,
                                 text='Use Project auto-update',
                                 style='Set.TLabel')
        self.update_choice.configure(variable=self.share.setting['proj_update'],
                                     bg=self.master_bg, borderwidth=0)

        beep_label = ttk.Label(self.settings_win,
                               text='No tasks running alarm',
                               style='Set.TLabel')
        self.beep_choice.configure(variable=self.share.setting['sound_beep'],
                                   bg=self.master_bg, borderwidth=0)

        default_button = ttk.Button(self.settings_win, text='Use defaults',
                                    command=self.share.defaultsettings)
        self.countnow_button.configure(text='Count now',
                                       command=self.start_when_confirmed)

        # Grid settings widgets; generally sorted by row.
        intvl_label.grid(row=0, column=0, padx=5, pady=10, sticky=tk.E)
        self.share.intvl_choice.grid(row=0, column=1)
        default_button.grid(row=0, column=3, padx=10, pady=(10, 0), sticky=tk.E)
        sumry_label1.grid(row=1, column=0, padx=(10, 5), pady=10, sticky=tk.E)
        self.sumry_value_entry.grid(row=1, column=1)
        sumry_label2.grid(row=1, column=2, padx=5, pady=10, sticky=tk.E)
        self.share.sumry_unit_choice.grid(row=1, column=3, padx=5, pady=10, sticky=tk.W)
        cycles_label.grid(row=2, column=0, padx=5, pady=10, sticky=tk.E)
        self.cycles_max_entry.grid(row=2, column=1)
        log_label.grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.log_choice.grid(row=3, column=1, padx=0, pady=5, sticky=tk.W)
        update_label.grid(row=4, column=0, padx=5, pady=0, sticky=tk.E)
        self.update_choice.grid(row=4, column=1, padx=0, pady=0, sticky=tk.W)
        beep_label.grid(row=5, column=0, padx=5, pady=0, sticky=tk.E)
        self.beep_choice.grid(row=5, column=1, padx=0, pady=0, sticky=tk.W)
        self.countnow_button.grid(
            row=5, column=3, padx=10, pady=(0, 10), sticky=tk.E)

        # Add tooltips that explain entries and selections.
        self.settings_tooltips()

    def settings_tooltips(self) -> None:
        """
        Calls to Tooltips module, for mouseover of info Button icons, to
        explain usage of entries and selections in the settings window.
        """

        # Need to use ttk.Button and styles on macOS to avoid square button img.
        #  Provides the same look on Linux, Windows, macOS. For Linux and
        #  Windows, works the same as tk.Button if configure with same options.
        _s = ttk.Style()
        _s.configure('Tooltip.TButton',
                     image=self.info_button_img,
                     background=self.master_bg,
                     highlightthickness=0,
                     highlightcolor=self.master_bg,
                     highlightbackground=self.master_bg,
                     activebackground=self.master_bg
                     )
        _s.map('Tooltip.TButton',
               background=[('pressed', '!focus', self.master_bg),
                           ('active', self.master_bg)],
               relief=[('pressed', tk.FLAT),
                       ('!pressed', tk.FLAT)]
               )
        intvl_tip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)
        cycles_tip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)
        update_tip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)
        beep_tip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)

        intvl_tip_txt = (
            'If the desired pull-down time values do not appear, then'
            ' either select a different summary time (or a different'
            ' interval time if do not see a desired summary time unit)'
            ' or click "Use defaults" and try again.')
        cycles_tip_txt = (
            'Interval counting stops after number of cycles'
            ' entered. Enter 0 (zero) for a one-off status report.')
        update_tip_txt = (
            'Allows an automatic Project update to re-establish communication'
            ' with the BOINC server when no tasks are running and'
            ' all tasks in the BOINC Manager are "Ready to report".'
            ' This may have unwanted effects if communication is lost'
            " because of loss of the host's internet connection."
            ' Has not been tested with multiple concurrent Projects.')

        beep_interval = NOTICE_INTERVAL * 2
        beep_tip_txt = (
            f'Provide an audible notification when no tasks are running'
            ' because tasks or Project are suspended by user or because'
            ' of an unexpected event. Occurs after the first full' 
            ' interval cycle elapses with no tasks running; beeps then'
            f' occur every {beep_interval} seconds.')

        Tooltip(intvl_tip_btn, intvl_tip_txt)
        Tooltip(cycles_tip_btn, cycles_tip_txt)
        Tooltip(update_tip_btn, update_tip_txt)
        Tooltip(beep_tip_btn, beep_tip_txt)

        # Need OS-specific grids for proper padding and alignments:
        if MY_OS == 'lin':
            intvl_tip_btn.grid(row=0, column=0, padx=(50, 0), sticky=tk.W)
            cycles_tip_btn.grid(row=2, column=0, padx=(75, 0), sticky=tk.W)
            update_tip_btn.grid(row=4, column=0, padx=(15, 0), sticky=tk.W)
            beep_tip_btn.grid(row=5, column=0, padx=(15, 0), sticky=tk.W)
        elif MY_OS == 'win':
            intvl_tip_btn.grid(row=0, column=0, padx=(35, 0), sticky=tk.W)
            cycles_tip_btn.grid(row=2, column=0, padx=(60, 0), sticky=tk.W)
            update_tip_btn.grid(row=4, column=0, padx=(5, 0), sticky=tk.W)
            beep_tip_btn.grid(row=5, column=0, padx=(5, 0), sticky=tk.W)
        elif MY_OS == 'dar':
            intvl_tip_btn.grid(row=0, column=0, padx=(45, 0), sticky=tk.W)
            cycles_tip_btn.grid(row=2, column=0, padx=(70, 0), sticky=tk.W)
            update_tip_btn.grid(row=4, column=0, padx=(8, 0), sticky=tk.W)
            beep_tip_btn.grid(row=5, column=0, padx=(8, 0), sticky=tk.W)

    def confirm_settings(self) -> bool:
        """
        Confirm validity of summary and interval times,
        set all to valid control variable dictionary values,
        and set up logging of data, if optioned.
        Called from start_when_confirmed().

        :return: True if settings are all valid.
        """
        # Need to set to True when interval and summary times are
        #   confirmed as valid. All other settings are self-validating.
        good_settings = False

        # Note: self.share.setting['interval_t'] and self.sumry_t_value
        #    are set in settings() or in Modeler.default_settings().
        if not self.share.setting['interval_t'].get():
            self.share.defaultsettings()

        if self.share.setting['interval_t'].get() != '1h':
            interval_m = int(self.share.setting['interval_t'].get()[:-1])
        else:
            # Need to convert 1h to minutes for comparisons.
            interval_m = 60

        self.share.setting['interval_m'].set(interval_m)

        if not self.share.setting['sumry_t_value'].get():
            msg = "Summary value cannot be blank. A default of '1' will be used."
            messagebox.showerror(title='Invalid entry', detail=msg,
                                 parent=self.settings_win)
            self.share.setting['sumry_t_value'].set(1)

        # If sumry_value = 0, it will be caught by interval_m comparison below.
        sumry_value = self.share.setting['sumry_t_value'].get()

        # Need to set summary_t here as concat of the two sumry_t element strings,
        #   then convert it to minutes for use in comparisons.
        summary_t = f"{sumry_value}{self.share.sumry_unit_choice.get()[:1]}"
        self.share.setting['summary_t'].set(summary_t)

        summary_m = T.string_to_min(summary_t)

        if interval_m >= summary_m or summary_m % interval_m != 0:
            info = "Summary time must be greater than, and a multiple of, interval time"
            messagebox.showerror(title='Invalid entry', detail=info,
                                 parent=self.settings_win)
            # Need to offer user valid alternatives to bad times entered.
            if self.share.setting['sumry_t_unit'].get() == 'min':
                self.share.setting['sumry_t_value'].set(2 * interval_m)
            elif self.share.setting['sumry_t_unit'].get() == 'hr':
                self.share.setting['sumry_t_value'].set(2 * sumry_value)
        elif interval_m < summary_m and summary_m % interval_m == 0:
            good_settings = True

        # Need to remove leading zeros, but allow a zero entry.
        #   Replace empty Entry with default values.
        cycles_max = self.cycles_max_entry.get()
        if cycles_max == '':
            self.share.setting['cycles_max'].set(1008)
        elif cycles_max != '0':
            self.share.setting['cycles_max'].set(int(cycles_max.lstrip('0')))
        # Allow zero entry for 1-off status report of task data.
        elif cycles_max == '0':
            self.share.setting['cycles_max'].set(0)

        # Need to set initial cycles_remain to cycles_max.
        self.share.data['cycles_remain'].set(self.share.setting['cycles_max'].get())

        # Note: logging module is used only to lazily manage the data log file.
        if self.share.setting['do_log'].get():
            logging.basicConfig(filename=str(Logs.LOGFILE), level=logging.INFO,
                                filemode="a", format='%(message)s')
        else:
            app.title(f'Count BOINC tasks on {gethostname()}'
                      ' (not logging data)')

        # Need to provide a unique name of app window for concurrent instances.
        if good_settings and not self.share.setting['do_log'].get():
            app.title(f'Count BOINC tasks on {gethostname()}'
                      f' (Parallel run, not logging data)')

        return good_settings

    def start_when_confirmed(self) -> None:
        """
        Main gatekeeper for settings().
        Calls confirm_settings(); if all is good then starts threads,
        calls emphasize_start_data(), and closes settings() window,
        which ends the startup sequence.
        Called from settings() countnow_button.
        """
        # Either run a 1-off status report or begin interval counts:
        if self.confirm_settings():
            if self.share.setting['cycles_max'].get() == 0:
                self.share.data['cycles_remain'].set(0)
                self.share.setting['interval_t'].set('DISABLED')
                self.share.setting['summary_t'].set('DISABLED')
                self.share.note['notice_txt'].set('STATUS REPORT ONLY')
            else:
                self.start_threads()

            self.emphasize_start_data()
            self.share.startdata()
            self.settings_win.destroy()

    def start_threads(self) -> None:
        """
        Set up and start threads for intervals, notices, and logging.
        Called from start_when_confirmed() as part of startup sequence.
        """
        # There are no thread.join(), so use daemon for clean exits.
        intvl_thread = threading.Thread(
            target=self.share.intervaldata, daemon=True)

        notice_thread = threading.Thread(
            target=self.share.taskstatenotices, daemon=True)

        log_thread = threading.Thread(
            target=self.share.logit, daemon=True, args=(None,))

        intvl_thread.start()
        notice_thread.start()
        log_thread.start()

    def emphasize_start_data(self) -> None:
        """
        Config data labels in master window for starting data emphasis.
        Establish start time.
        Called from start_when_confirmed() from 'Count now' button.
        """
        time_start = datetime.now().strftime(SHORT_STRFTIME)
        self.time_start_l.config(text=time_start)
        self.share.long_time_start = datetime.now().strftime(LONG_STRFTIME)

        # Need to keep sumry_b button disabled until after 1st summary interval.
        self.share.sumry_b.config(state=tk.DISABLED)

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)
        self.task_count_l.config(foreground=self.share.highlight)

        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

        if not self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)

        if self.share.setting['cycles_max'].get() > 0:
            self.starting_tooltips()

    def starting_tooltips(self):
        """
        Provide mouseover tooltips for data emphasis buttons.
        Tips will not be active once the first interval posts.
        """

        starting_tip_txt = (
            'This data column is now showing task data retrieved'
            ' from the most recent boinc-client report before'
            f' {__program_name__} started. Once the first count'
            ' interval time has elapsed, data for that interval will'
            ' display and this button will become "Interval data".'
        )
        Tooltip(self.share.starting_b, starting_tip_txt)

        summary_tip_txt = (
            'This button will activate and allow switching of visual'
            ' emphasis between interval and summary data columns'
            ' once the first summary count interval time has elapsed.'
        )
        Tooltip(self.share.sumry_b, summary_tip_txt)

    def emphasize_intvl_data(self) -> None:
        """
        Switches font emphasis from Summary data to Interval data.
        Called from 'Interval data' button.
        """

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)

        # Interval data, column1
        self.task_count_l.configure(foreground=self.share.highlight)
        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        # Summary data, column2, de-emphasize font color
        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_sumry_data(self) -> None:
        """
        Switches font emphasis from Interval data to Summary data.
        Called from 'Summary data' button.
        """
        self.interval_t_l.config(foreground=self.deemphasize)
        self.summary_t_l.config(foreground=self.emphasize)

        # Interval data, column1, de-emphasize font color
        self.task_count_l.configure(foreground=self.deemphasize)
        self.tt_avg_l.configure(foreground=self.deemphasize)
        self.tt_sd_l.configure(foreground=self.deemphasize)
        self.tt_range_l.configure(foreground=self.deemphasize)
        self.tt_total_l.configure(foreground=self.deemphasize)

        # Summary data, column2, emphasize font color
        self.task_count_sumry_l.configure(foreground=self.share.highlight)
        self.ttmean_sumry_l.configure(foreground=self.share.highlight)
        self.ttsd_sumry_l.configure(foreground=self.emphasize)
        self.ttrange_sumry_l.configure(text=self.share.data['tt_range'].get(),
                                       foreground=self.emphasize)
        self.ttsum_sumry_l.configure(foreground=self.emphasize)

    def app_got_focus(self, focus_event) -> None:
        """Give menu bar headings normal color when app has focus.

        :param focus_event: Implicit event passed from .bind_all()
        """
        self.menubar.entryconfig("File", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("View", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("Help", foreground='black', state=tk.NORMAL)
        self.view_button_style.configure('View.TButton', foreground='black',
                                         background='grey75')
        if self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.NORMAL)
        return focus_event

    def app_lost_focus(self, focus_event) -> None:
        """Give menu bar headings grey-out color when app looses focus.

        :param focus_event: Implicit event passed from .bind_all()
        """
        self.menubar.entryconfig("File", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("View", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("Help", foreground='grey', state=tk.DISABLED)
        self.view_button_style.configure('View.TButton', foreground='grey')
        self.share.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)
        return focus_event


# ##################### User information methods #######################
class CountFyi:
    """
    Methods to provide user with information and help.
    """

    def __init__(self, share):
        self.share = share

    @staticmethod
    def about() -> None:
        """
        Toplevel display of program metadata.
        Called from Viewer.master_widgets() Help menu bar.
        """
        # Have highlightcolor match self.master_bg of the app main window.
        aboutwin = tk.Toplevel(highlightthickness=5,
                               highlightcolor='SteelBlue4',
                               highlightbackground='grey75')
        aboutwin.geometry(Utils.position_wrt_window(app, 30, 20))
        aboutwin.resizable(False, False)
        aboutwin.title(f'About {__program_name__}')
        aboutwin.focus_set()

        insert_txt = (f'{__doc__}\n'
                      f'{"Author:".ljust(13)}{__author__}\n'
                      f'{"Credits:".ljust(13)}{__credits__}\n'
                      f'{"License:".ljust(13)}{__license__}\n'
                      f'{"Program:".ljust(13)}{__program_name__}\n'
                      f'{"Version:".ljust(13)}{__version__}\n'
                      f'{"Dev. Env.:".ljust(13)}{__dev_environment__}\n'
                      f'{"URL:".ljust(13)}{__project_url__}\n'
                      f'{"Maintainer:".ljust(13)}{__maintainer__}\n'
                      f'{"Status:".ljust(13)}{__status__}\n'
                      )

        max_line = len(max(insert_txt.splitlines(), key=len))

        abouttxt = tk.Text(aboutwin, font='TkFixedFont',
                           width=max_line, height=insert_txt.count('\n') + 2,
                           relief='groove', borderwidth=5, padx=25)
        abouttxt.insert(1.0, insert_txt)
        abouttxt.pack()
        # Need to not have cursor appear in Text, but allow
        #   rt-click edit commands to work if needed.
        abouttxt.configure(state=tk.DISABLED)

        Binds.keyboard('close', aboutwin)
        Binds.click('right', abouttxt)

    def compliment_me(self) -> None:
        """A silly diversion; called from Help menu bar and keybinding.
        """
        compliments = [
            "Hey there good lookin'!", 'I wish we had met sooner.',
            'You are the smartest person I know.', 'I like your hair.',
            'You have such a nice smile.', 'Smart move!',
            'Blue is your color.', 'Good choice!',
            "That's very kind of you.", "Stop! You're making me blush.",
            'I just love what you did.', 'How witty you are!', 'Awesome!',
            'Your tastes are impeccable.', "You're incredible!",
            'You are so talented!', "I wish I'd thought of that.",
            'This is fun!', 'Get back to work.', 'Nice!', 'You saved me.',
            'You are an inspiration to us all.', "That's so funny!",
            'Show me how you do that.', "I've always looked up to you.",
            'You sound great!', 'You smell nice.', 'Great job!',
            'You are a role model.', 'I wish more people were like you.',
            'We appreciate what you did.', 'I hear people look up to you.',
            'You are a really good dancer.', 'What makes you so successful?',
            'When you speak, people listen.', 'You are a superb person.',
            'You rock!', 'You nailed it!', 'That was really well done.',
            'You are amazing!', 'We need more folks like you around here.',
            'Excuse me, are you a model?', 'What a lovely laugh you have.',
            "I'm jealous of your ability.", "You're the stuff of legends.",
            'This would not be possible without you.', 'Way to go! Yay!',
            'Did you make that? I love it!', 'You are the best!',
            'I like what you did.', 'Whoa. Have you been working out?',
            "We can't thank you enough.", 'No, really, you have done enough.',
            "That's a good look for you.", 'I could not have done it better.',
            'Congratulations!', 'Try not. Do or do not. There is no try.',
            "Well, THAT's impressive.", 'I hear that you are the one.',
            'You excel at everything.', 'Your voice is very soothing.',
            'Is it true what people say?', 'The word is, you got it!',
            'The Nobel Committee has been trying to reach you.',
            'The Academy is asking for your CV.', 'You look great!',
            'The President seeks your council.', 'Thank you so much!',
            'The Prime Minister seeks your council.', 'Crunchers rule!',
            'Crunchers are the best sort of people.',
            "I can't think of anything to say. Sorry.",
        ]
        praise = choice(compliments)
        self.share.compliment_l.config(text=praise)
        self.share.notice_l.grid_remove()
        # Need to re-grid initial master_widgets() grids b/c its grid may
        #   have been removed by a notice_l call. Original grid coordinates
        #   are set in master_widgets().
        self.share.compliment_l.grid()

        def refresh():
            self.share.compliment_l.grid_remove()
            # Re-grid notice to return to current Notice text.
            self.share.notice_l.grid()
            app.update_idletasks()

        self.share.compliment_l.after(3333, refresh)

    @staticmethod
    def file_paths(window: tk.Toplevel) -> None:
        """
        Toplevel display of full paths for program-generated files.

        :param window: The tk Toplevel window object over which this
            Toplevel is to appear.
        """

        # The *window* parameter is used here, but not in other Fyi methods,
        #   b/c file_paths() is called from toplevels other than just
        #   the app main window.

        # Have highlightcolor match self.master_bg of the app main window.
        pathswin = tk.Toplevel(highlightthickness=5,
                               highlightcolor='SteelBlue4',
                               highlightbackground='grey75')

        # Need to position window over the window from which it is called.
        pathswin.geometry(Utils.position_wrt_window(window, 30, 20))
        pathswin.resizable(False, False)
        pathswin.title(f'Program-generated files on {gethostname()}')
        pathswin.focus_set()

        insert_txt = (
            f'Full file paths created by {__program_name__}\n\n'
            f'Data log (file exists: {Path.exists(Logs.LOGFILE)})\n'
            f'   ...do not alter this file while program is running\n'
            f'   {Logs.LOGFILE}\n\n'
            f'Saved log analyses (file exists: {Path.exists(Logs.ANALYSISFILE)})\n'
            f'   {Logs.ANALYSISFILE}\n'
        )

        # Need to add OS-specific instance management file path.
        if MY_OS == 'win':
            insert_txt = (f'{insert_txt}\nSentinel file for this instance'
                          f' (is deleted on exit)\n'
                          f'   {sentinel.name}\n')
        else:
            insert_txt = (f'{insert_txt}\nLockfile (hidden):\n'
                          f'   {lockfile_fullpath}\n')

        max_line = len(max(insert_txt.splitlines(), key=len))

        pathstxt = tk.Text(pathswin, font='TkFixedFont',
                           height=insert_txt.count('\n') + 1,
                           width=max_line,
                           relief='groove', borderwidth=5,
                           padx=10, pady=10)
        pathstxt.insert(1.0, insert_txt)

        # Need to center the header lines.
        pathstxt.tag_configure("header", justify='center')
        pathstxt.tag_add("header", "1.0", "3.0")
        pathstxt.pack()

        Binds.keyboard('close', pathswin)
        Binds.click('right', pathstxt)

    @staticmethod
    def information() -> None:
        """
        Toplevel display of basic information for usage and actions.
        Called from Viewer.master_widgets() Help menu bar.
        """

        # Have highlightcolor match self.master_bg of the app main window.
        infowin = tk.Toplevel(highlightthickness=5,
                              highlightcolor='SteelBlue4',
                              highlightbackground='grey75')
        infowin.geometry(Utils.position_wrt_window(app, 30, 20))
        infowin.resizable(False, False)
        infowin.title('Usage information')
        infowin.focus_set()

        insert_txt = ("""
        - Counting begins once "Count now" is clicked in settings window.\n
        - Interval and Summary data buttons switch visual emphasis;
                ...those buttons activate once their data post.
                The Summary task time "avg" is the weighted mean.\n
        - At start, '# tasks reported' and 'Interval time' are from
                the most recent hourly BOINC report.\n
        - Number of tasks in queue and Notices update every"""
                      f' {NOTICE_INTERVAL} seconds.\n'
                      """
        - Displayed countdown clock time is approximate.\n
        - Counts and Notices histories are in the log file.\n
        - While not recommended, multiple program instances can be run
                from separate directories with command line execution.
                Only one stand-alone app instance is allowed.\n
        - When analysis of logged hours is "cannot determine"...
                Quick fix: backup then delete log file, restart program.\n
        - Right-click actions only affect on-screen text, not file content,
                except edits in the log analysis window, such as notations,
                can be saved to the log analysis file.\n
        - Most common key commands work as expected.
        """)

        # OS-specific Text widths were empirically determined for TkTextFont.
        os_width = 0
        if MY_OS in 'lin, win':
            os_width = 64
        elif MY_OS == 'dar':
            os_width = 56

        infotxt = tk.Text(infowin, font='TkTextFont',
                          width=os_width, height=insert_txt.count('\n') + 2,
                          relief='groove', padx=15)
        infotxt.insert(1.0, insert_txt)
        infotxt.pack()

        # Need to not have cursor appear in Text, but allow
        #   rt-click edit commands to work if needed.
        infotxt.configure(state=tk.DISABLED)

        Binds.keyboard('close', infowin)
        Binds.click('right', infotxt)


# ################## MVC Controller; is app mainloop ###################
class CountController(tk.Tk):
    """
    The MVC controller represents the tkinter main window and main thread.
    Other MVC Classes can interact through the Controller via the
    'share' parameter.
    Architecture based on https://stackoverflow.com/questions/32864610/.
    """

    def __init__(self):
        super().__init__()

        # Need window sizes to provide room for multi-line notices,
        #    but not get minimized enough to exclude notices row.
        # Main window sizes need to be OS-specific b/c of different
        #    default OS text font widths.
        if MY_OS == 'lin':
            self.minsize(594, 370)
            self.maxsize(780, 400)
        elif MY_OS == 'win':
            self.minsize(544, 380)
            self.maxsize(720, 400)
        elif MY_OS == 'dar':
            self.minsize(615, 390)
            self.maxsize(780, 425)

        CountViewer(share=self)

    def defaultsettings(self) -> None:
        """
        Starting settings of: report interval, summary interval,
        counting limit, and log file option.
        """
        CountModeler(share=self).default_settings()

    def startdata(self) -> None:
        """
        Is called from Viewer.startup().
        """
        CountModeler(share=self).start_data()

    def intervaldata(self) -> None:
        """
        Is called from Viewer.start_threads().
        """
        CountModeler(share=self).interval_data()

    def taskstatenotices(self) -> None:
        """
        Is called from Viewer.start_threads().
        """
        CountModeler(share=self).notice_it()

    def logit(self, called_from: str) -> None:
        """Send data to log file.
        Is called from Viewer.start_threads()

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """
        CountModeler(share=self).log_it(called_from)

    def about(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        """
        CountFyi(share=self).about()

    def compliment(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar and
        keybind. A silly diversion.
        """
        CountFyi(share=self).compliment_me()

    def filepaths(self, window: tk.Toplevel) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        """
        CountFyi(share=self).file_paths(window)

    def info(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        """
        CountFyi(share=self).information()


if __name__ == "__main__":
    parse_args()

    # Need to confirm that the boinccmd path exists.
    BC.set_boincpath()

    # Need to set up conditions to control multiple instances.
    # Must not allow multiple instances to write to the same log file,
    #   so best to exit program to prevent that.
    # In Class Logs, LOGFILE path constants are different
    #   for stand-alone and Terminal executions.
    # Multiple instances of Terminal executions can run when from
    #   different directories.
    exit_msg = (f'\nNOTICE: {__program_name__} is already running from'
                f' {Path.cwd()}. Exiting...\n')

    if getattr(sys, 'frozen', False):  # Is PyInstaller stand-alone app.
        exit_msg = (f'\nNOTICE: {__program_name__}'
                    ' is already running. Exiting...\n')

    if MY_OS == 'win':

        # Can restrict all executions to only one instance if
        #   "with sentinel:" is replaced with these mutex module calls.
        # winstance = Instances.OneWinstance()
        # winstance.exit_twinstance(exit_msg)

        # Using exit_msg in this call will exit program here if
        #   another instance is running from the LOGFILE directory.
        # Note: sentinel_count not currently used in main script b/c
        #    instance management is handled through Instances module.
        sentinel, sentinel_count = Instances.sentinel_or_exit(
            Logs.LOGFILE.parent, exit_msg)

        with sentinel:
            try:
                print(f'{__program_name__} now running...')
                app = CountController()
                app.title(f'Counting BOINC tasks on {gethostname()}')

                # Need absolute path for stand-alone app from PyInstaller.
                img = tk.PhotoImage(
                    file=Utils.absolute_path_to('images/count_icon_512.png'))
                app.iconphoto(True, img)

                app.mainloop()

            except KeyboardInterrupt:
                _msg = (f"\n{datetime.now().strftime(LONG_STRFTIME)};"
                        " *** Keyboard interrupt by user ***\n"
                        f"This instance's temporary file, {sentinel.name},"
                        " has been deleted.\n")
                print(_msg)
                logging.info(msg=_msg)
            except Exception as unknown:
                print(f'An unexpected error: {unknown}\n'
                      f"This instance's temporary file, {sentinel.name},"
                      " has been deleted.\n")

    else:
        lockfile_fullpath = Path(Logs.LOGFILE.parent,
                                 f'.{__program_name__}_lockfile')

        # pylint: disable=consider-using-with
        lockfile = open(lockfile_fullpath, 'w')
        Instances.lock_or_exit(lockfile, exit_msg)

        try:
            print(f'{__program_name__} now running...')
            app = CountController()
            app.title(f'Counting BOINC tasks on {gethostname()}')

            # Need absolute path for stand-alone app from PyInstaller.
            img = tk.PhotoImage(
                file=Utils.absolute_path_to('images/count_icon_512.png'))
            app.iconphoto(True, img)

            app.mainloop()

        except KeyboardInterrupt:
            _msg = (f"\n{datetime.now().strftime(LONG_STRFTIME)};"
                    " *** Keyboard interrupt by user ***\n")
            print(_msg)
            logging.info(msg=_msg)
        except Exception as unknown:
            print(f'\nAn unexpected error: {unknown}\n')
