#!/usr/bin/env python3

"""
gcount-tasks provides task counts and time statistics at timed
intervals for tasks recently reported to BOINC servers. It can be run
on Windows, Linux, and MacOS. It is the tkinter GUI version of
count-tasks. Its MVC architecture is modified from the example provided
by Brian Oakley at https://stackoverflow.com/questions/32864610/
Requires Python 3.6 or later and tkinter (tk/tcl) 8.6 or later.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see https://www.gnu.org/licenses/.
"""
# ^^ Text for --about invocation argument via __doc__.
# Also used in Fyi.about():
__author__ = 'cecht, BOINC ID: 990821'
__copyright__ = 'Copyright (C) 2021 C.S. Echt'
__credits__ = 'Inspired by rickslab-gpu-utils'
__license__ = 'GNU General Public License'
__program_name__ = 'gcount-tasks'
__version__ = '0.8.7'
__dev_environment__ = "Python 3.8 - 3.9"
__project_url__ = 'https://github.com/csecht/CountBOINCtasks'
__maintainer__ = 'cecht'
__docformat__ = 'Markdown'
__status__ = 'Development Status :: 2 - Beta'

import argparse
import logging
import statistics
import sys
import threading
import time
from datetime import datetime, timedelta
from pathlib import Path
# from platform import node
from random import choice
from re import search, findall, MULTILINE
from socket import gethostname

# pylint: disable=import-error
from COUNTmodules import boinc_command, time_convert, files
BC = boinc_command.BoincCommand()
TC = time_convert
File = files

try:
    import tkinter as tk
    from tkinter import messagebox, ttk
    from tkinter.scrolledtext import ScrolledText
except (ImportError, ModuleNotFoundError) as error:
    print('gcount-tasks requires tkinter, which is included with \n'
          'Python 3.7+ distributions.\n'
          'Install the most recent version or re-install Python and include Tk/Tcl.\n'
          '\nOn Linux, you may also need: $ sudo apt-get install python3-tk\n'
          f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

if sys.version_info < (3, 6):
    print('Sorry, but running gcount-tasks requires Python 3.6 or later.\n'
          'Current Python version: '
          f'{sys.version_info.major}.{sys.version_info.minor}\n'
          'Python downloads are available from https://docs.python.org/')
    sys.exit(0)

MY_OS = sys.platform[:3]
SHORT_STRFTIME = '%Y %b %d %H:%M'
LONG_STRFTIME = '%Y-%b-%d %H:%M:%S'
DAY_STRFTIME = '%A %H:%M'
LONGSMRY_STRF = '%b %d %H:%M'
NOTICE_INTERVAL = 15  # <- time.sleep() seconds


# ################ Useful functions, not part of MVC ###################
def check_boinc():
    """
    Check whether BOINC client is running. Called before proceeding to
    implement settings and begin counting and at each notice interval.
    """
    # Note: Any BC boinccmd will return this string (in a list)
    #   if boinc-client is not running; use BC.get_version() b/c it is short.
    #   Could be run with BC.check_boinc(), but only for Terminal output.
    if "can't connect to local host" in BC.get_version():
        okay = messagebox.askokcancel(
            title='BOINC ERROR',
            detail='BOINC commands cannot be executed.\n'
                   'Is the BOINC client running?\nExiting now...')
        if okay:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)
        else:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)


def parse_args() -> None:
    """Allow handling of common execution arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about',
                        help='Provides description, version, GNU license',
                        action='store_true',
                        default=False)
    args = parser.parse_args()
    if args.about:
        print(__doc__)
        print(f'{"Author:".ljust(13)}', __author__)
        print(f'{"Credits:".ljust(13)}', __credits__)
        print(f'{"License:".ljust(13)}', __license__)
        print(f'{"Copyright:".ljust(13)}', __copyright__)
        print(f'{"Program:".ljust(13)}', __program_name__)
        print(f'{"Version:".ljust(13)}', __version__)
        print(f'{"Dev Env:".ljust(13)}', __dev_environment__)
        print(f'{"URL:".ljust(13)}', __project_url__)
        print(f'{"Maintainer:".ljust(13)}', __maintainer__)
        print(f'{"Status:".ljust(13)}', __status__)
        print()
        sys.exit(0)


def app_position(add_x=0, add_y=0) -> tuple:
    """
    Use to set position of a Toplevel child with respect to the
    app (master) window.

    :param add_x: optional pixels added to app's x coordinate.
    :param add_y: optional pixels added to app's y coordinate.
    :return: (x,y) screen geometry coordinates of the app window.
    :rtype: tuple
    """
    app.update_idletasks()
    pos_x = app.winfo_x() + add_x
    pos_y = app.winfo_y() + add_y
    return pos_x, pos_y


def enter_only_digits(entry_string, action_type) -> bool:
    """
    Only digits are accepted and displayed in Entry field.
    Used with .register() to configure Entry kw validatecommand.

    :param entry_string: value entered into an Entry() widget (%P).
    :param action_type: edit action code (%d).
    :return: True, False
    """
    # Need to restrict entries to only digits,
    #   MUST use action type parameter to allow user to delete first number
    #   entered when wants to re-enter following backspace deletion.
    # source: https://stackoverflow.com/questions/4140437/
    # %P = value of the entry if the edit is allowed
    # Desired action type 1 is "insert", %d.
    if action_type == '1' and not entry_string.isdigit():
        return False
    return True


def ttimes_stats(tasktimes: iter) -> dict:
    """
    Sum and run statistics of BOINC task times for reporting in
    master Frame and log file.
    Called from Modeler. Calls to time_convert.sec_to_format().

    :param tasktimes: A list, tuple, or set of times, in seconds as
                      integers or floats.
    :return: Dict keys: tt_total, tt_avg, tt_sd, tt_min, tt_max;
             Dict values as: 00:00:00.
    """
    numtasks = len(tasktimes)
    total = TC.sec_to_format(int(sum(tasktimes)), 'std')
    if numtasks > 1:
        avg = TC.sec_to_format(int(statistics.mean(tasktimes)), 'std')
        stdev = TC.sec_to_format(int(statistics.stdev(tasktimes)), 'std')
        low = TC.sec_to_format(int(min(tasktimes)), 'std')
        high = TC.sec_to_format(int(max(tasktimes)), 'std')
        return {
            'tt_total': total,
            'tt_avg': avg,
            'tt_sd': stdev,
            'tt_min': low,
            'tt_max': high}
    if numtasks == 1:
        return {
            'tt_total': total,
            'tt_avg': total,
            'tt_sd': 'n/a',
            'tt_min': 'n/a',
            'tt_max': 'n/a'}
    # numtasks is 0...
    return {
        'tt_total': '00:00:00',
        'tt_avg': '00:00:00',
        'tt_sd': 'n/a',
        'tt_min': 'n/a',
        'tt_max': 'n/a'}


def str2dt(dt_str: str, str_format: str) -> datetime:
    """
    Convert formatted date string to datetime object.
    Use to compare datetimes in text files.

    :param dt_str: date and time string;
                   ex '1970-Jan-01 00:00:00'.
    :param str_format: datetime.strftime() string;
                       ex '%Y-%b-%d %H:%M:%S'.
    :return: datetime object formatted to str_format.
    """
    dt_obj = datetime.strptime(dt_str, str_format)
    return dt_obj


def interval_stats(distribution: iter, stat=None, weights=None) -> str:
    """
    Calculate statistics for task times from logged interval data.

    :param distribution: List or tuple of avg times, as string formatted
                         00:00:00, or as seconds (floats or integers).
    :param stat: The statistic to run.
                 'wtmean' requires distribution and weights parameters.
                 'range' and 'stdev' require only distribution parameter.
    :param weights: List or tuple of corresponding sample numbers
                    (integers) for each element in distribution.
    :return: The distribution weighted mean OR range OR standard
             deviation, each as string formatted 00:00:00,
             OR 'cannot determine' if invalid stat='wtmean' parameters.
    """
    # algorithm sources:
    # https://towardsdatascience.com/
    #   3-ways-to-compute-a-weighted-average-in-python-4e066de7a719
    # https://stackoverflow.com/questions/10663720/
    #   how-to-convert-a-time-string-to-seconds
    # https://stackoverflow.com/questions/18470627/
    #   how-do-i-remove-the-microseconds-from-a-timedelta-object

    if not stat:
        return 'missing stat param'
    if weights:
        if not all(isinstance(w, int) for w in weights):
            return 'cannot determine'
        if len(distribution) != len(weights):
            return 'cannot determine'

    # Need to convert distribution clock time strings to integer seconds, but
    #    not if distribution times are float or integer seconds.
    if all(isinstance(t, str) for t in distribution):
        dist_sec = [
            sum(x * int(t) for x, t in zip([3600, 60, 1], clk_fmt.split(":")))
            for clk_fmt in distribution]
    else:
        dist_sec = list(distribution)

    #   Need to convert the timedelta clock fmt object to a string for display,
    #   and remove microseconds from the clock fmt string.
    if stat == 'range':
        shortest = str(timedelta(seconds=(min(dist_sec)))).split(".", 1)[0]
        longest = str(timedelta(seconds=(max(dist_sec)))).split(".", 1)[0]
        return f'[{shortest} -- {longest}]'
    if stat == 'wtmean':
        numerator = sum([dist_sec[i] * weights[i] for i in range(len(dist_sec))])
        denominator = sum(weights)
        return str(
            timedelta(seconds=(numerator / denominator))).split(".", 1)[0]
    if stat == 'stdev':
        return str(
            timedelta(seconds=(statistics.stdev(dist_sec)))).split(".", 1)[0]

    return 'unexpected condition'


# noinspection PyBroadException
def quit_gui(*keybind):
    """
    Error-free and informative exit from the program.
    Called from multiple widgets or keybindings.

    :param keybind: Empty parameter to pass implicit keybinding event.
    """

    # Write exit message to an existing log file, even if the settings
    #  do log option was not selected.
    time_now = datetime.now().strftime(LONG_STRFTIME)
    quit_msg = f'\n{time_now}; *** User quit the program. ***\n'
    print(quit_msg)
    if Path.exists(Logs.LOGFILE):
        File.append_txt(Logs.LOGFILE, quit_msg, False)
    try:
        app.update_idletasks()
        app.after(200)
        app.destroy()
    # pylint: disable=broad-except
    except Exception:
        sys.exit(0)
    return keybind


def valid_path_to(relative_path: str) -> Path:
    """
    Get absolute path to files and directories.
    _MEIPASS var is used by distribution programs from
    PyInstaller --onefile; e.g. for images dir.

    :param relative_path: File or dir name path, as string.
    :return: Absolute path as pathlib Path object.
    """
    # Modified from: https://stackoverflow.com/questions/7674790/
    #    bundling-data-files-with-pyinstaller-onefile and PyInstaller manual.
    if getattr(sys, 'frozen', False):  # hasattr(sys, '_MEIPASS'):
        base_path = getattr(sys, '_MEIPASS', Path(Path(__file__).resolve()).parent)
        return Path(base_path) / relative_path
    return Path(relative_path).resolve()


class Logs:
    """
    Methods to analyze and view logged task data.
    """

    # Need Path.home() when running GcountTasks onefile, a frozen executable
    #   from PyInstaller, so that log files do not end up in temp MEI folder.
    # Need Path.cwd() when running gcount-tasks from command line, so that
    #   files end up in parent directory.
    # Need .resolve() to force absolute path and handle possible symlinks.
    if getattr(sys, 'frozen', False):
        LOGFILE = Path(Path.home(), 'gcount-tasks_log.txt').resolve()
        ANALYSISFILE = Path(Path.home(), 'gcount-tasks_analysis.txt').resolve()
    else:
        LOGFILE = Path(Path.cwd(), 'gcount-tasks_log.txt').resolve()
        ANALYSISFILE = Path(Path.cwd(), 'gcount-tasks_analysis.txt').resolve()

    @classmethod
    def analyze_logfile(cls) -> tuple:
        """
        Reads log file and analyses Summary and Interval counts.
        Called from cls.show_analysis().

        :return: text strings to display in show_analysis() Toplevel.
        """
        sumry_dates = []
        sumry_intvl_vals = []
        num_sumry_intvl_vals = 0
        sumry_counts = []
        sumry_cnt_avg = 0.0
        sumry_cnt_range = ''

        intvl_dates = []
        intvl_vals = []
        num_intvl_vals = 0
        intvl_counts = []
        num_tasks = str(sum(intvl_counts))
        intvl_cnt_avg = 0.0
        intvl_cnt_range = ''
        intvl_t_wtavg = ''
        intvl_t_range = ''

        recent_dates = []
        recent_intvl_vals = []
        num_recent_intvl_vals = 0
        recent_counts = []
        recent_intervals = True

        summary_text = ''
        interval_text = ''

        try:
            with open(cls.LOGFILE, encoding='utf-8') as file:
                logtext = file.read()
        except FileNotFoundError:
            info = (f'On {gethostname()}, missing necessary file:\n{cls.LOGFILE}\n'
                    'Was the settings "log results" option used?\n'
                    'Was the log file deleted, moved or renamed?')
            messagebox.showerror(title='FILE NOT FOUND', detail=info)
            return summary_text, interval_text  # <- Empty strings.

        found_sumrys = findall(
            r'^(.*); >>> SUMMARY: .+ (\d+[mhd]): (\d+$)', logtext, MULTILINE)
        found_intvls = findall(
            r'^(.*); Tasks reported .+ (\d+[mhd]): (\d+$)', logtext, MULTILINE)
        found_intvl_avgt = findall(
            r'Tasks reported .+\n.+ avg (\d{2}:\d{2}:\d{2})', logtext, MULTILINE)

        if found_sumrys:
            sumry_dates, sumry_intvl_vals, sumry_cnts = zip(*found_sumrys)
            num_sumry_intvl_vals = len(set(sumry_intvl_vals))
            sumry_counts = list(map(int, sumry_cnts))
            sumry_cnt_avg = round(sum(sumry_counts) / len(sumry_counts), 1)
            sumry_cnt_range = f'[{min(sumry_counts)} -- {max(sumry_counts)}]'

        if found_intvls:
            intvl_dates, intvl_vals, intvl_cnts = zip(*found_intvls)
            num_intvl_vals = len(set(intvl_vals))
            intvl_counts = list(map(int, intvl_cnts))
            intvl_cnt_avg = round(sum(intvl_counts) / len(intvl_counts), 1)
            intvl_cnt_range = f'[{min(intvl_counts)} -- {max(intvl_counts)}]'
            intvl_t_wtavg = interval_stats(found_intvl_avgt, 'wtmean', intvl_counts)
            intvl_t_range = interval_stats(found_intvl_avgt, 'range')

        # Need recent vars when there are interval counts following last summary.
        #   So find the list index for first interval count after the last summary.
        #   If there are no intervals after last summary, then flag and move on.
        if found_sumrys and found_intvls:
            # When there are no intervals after last summary,
            #   the last intvl date is last summary date.
            if intvl_dates[-1] == sumry_dates[-1]:
                recent_intervals = False
            else:
                index = [
                    i for i, date in enumerate(intvl_dates) if date == sumry_dates[-1]]
                index_recent = index[0] + 1  # <- The interval after the last summary.
                recent_dates, recent_intvl_vals, recent_cnts = zip(*found_intvls[index_recent:])
                num_recent_intvl_vals = len(set(recent_intvl_vals))
                recent_counts = list(map(int, recent_cnts))

        # Need to tailor report texts for various counting conditions.
        if not found_sumrys and not found_intvls:
            interval_text = (
                f'\nAs of {datetime.now().strftime(SHORT_STRFTIME)}\n'
                '   There are not enough data to analyze.\n'
                '   Need at least one summary or one\n'
                '   interval count in the log file.\n')
        if not found_sumrys and found_intvls:
            summary_text = '\nNo summary counts are logged yet.\n\n'
            if num_intvl_vals == 1:
                interval_text = (
                    'Analysis of reported tasks logged from\n'
                    f'{intvl_dates[0]} to {intvl_dates[-1]}\n'
                    f'   {cls.uptime(logtext).ljust(11)} hours counting tasks\n'
                    f'   {num_tasks.ljust(11)} tasks in {len(intvl_counts)} count intervals\n'
                    f'   {intvl_t_wtavg.ljust(11)} weighted mean task time\n'
                    f'   {intvl_t_range} range of task times\n\n'
                    f'   {str(intvl_cnt_avg).ljust(11)} tasks per {intvl_vals[0]} count interval\n'
                    f'   {intvl_cnt_range} range of task counts\n'
                )
            else:
                interval_text = (
                    'Analysis of reported tasks logged from\n'
                    f'{intvl_dates[0]} to {intvl_dates[-1]}\n'
                    f'   {cls.uptime(logtext).ljust(11)} hours counting tasks\n'
                    f'   {num_tasks.ljust(11)} tasks in {len(intvl_counts)} count intervals\n'
                    f'   {intvl_t_wtavg.ljust(11)} weighted mean task time\n'
                    f'   {intvl_t_range} range of task times\n\n'
                    f'   {str(intvl_cnt_avg).ljust(11)} tasks per count interval\n'
                    f'   {intvl_cnt_range} range of task counts\n'
                    f'There are {num_intvl_vals} different interval times\n'
                    f'logged, {set(intvl_vals)},\n'
                    'so interpret results with caution.\n\n'
                )
        if found_sumrys:
            if num_sumry_intvl_vals == 1:
                summary_text = (
                    'Analysis of reported tasks logged from\n'
                    f'{intvl_dates[0]} to {intvl_dates[-1]}\n'
                    f'   {cls.uptime(logtext).ljust(11)} hours counting tasks\n'
                    f'   {num_tasks.ljust(11)} tasks in {len(intvl_counts)} count intervals\n'
                    f'   {intvl_t_wtavg.ljust(11)} weighted mean task time\n'
                    f'   {intvl_t_range} range of task times\n\n'
                    'Summary data logged from:\n'
                    f'{sumry_dates[0]} to {sumry_dates[-1]}\n'
                    f'   {str(len(sumry_counts)).ljust(7)} summaries logged\n'
                    f'   {str(sumry_cnt_avg).ljust(7)}'
                    f' tasks per {sumry_intvl_vals[0]} summary interval\n'
                    f'   {sumry_cnt_range} range of task counts\n\n'
                )
            else:
                summary_text = (
                    'Analysis of reported tasks logged from\n'
                    f'{intvl_dates[0]} to {intvl_dates[-1]}\n'
                    f'   {cls.uptime(logtext).ljust(11)} hours counting tasks\n'
                    f'   {num_tasks.ljust(11)} tasks in {len(intvl_counts)} count intervals\n'
                    f'   {intvl_t_wtavg.ljust(11)} weighted mean task time\n'
                    f'   {intvl_t_range} range of task times\n\n'
                    'Summary data logged from:\n'
                    f'{sumry_dates[0]} to {sumry_dates[-1]}\n\n'
                    f'   {str(len(sumry_counts)).ljust(7)} summaries logged\n'
                    f'   {str(sumry_cnt_avg).ljust(7)} tasks per summary\n'
                    f'   {sumry_cnt_range} range of task counts\n'
                    f'There are {num_sumry_intvl_vals} different Summary interval times,\n'
                    f'   {set(sumry_intvl_vals)},\n'
                    '   so interpret results with caution.\n\n'
                )

        if found_sumrys and found_intvls:
            # Summary text has been defined, so now do interval text.
            if recent_intervals:
                if num_recent_intvl_vals == 1:
                    interval_text = (
                        'Since last Summary, additional counts from:\n'
                        f'{recent_dates[0]} to {recent_dates[-1]}\n'
                        f'   {sum(recent_counts)} tasks in {len(recent_counts)} intervals '
                        f'of {recent_intvl_vals[0]}\n'
                    )
                else:
                    interval_text = (
                        'Since last Summary, additional counts from:\n'
                        f'{recent_dates[0]} to {recent_dates[-1]}\n\n'
                        f'   {sum(recent_counts)} tasks in {len(recent_counts)} intervals\n'
                        f'There are {num_recent_intvl_vals} different interval times,\n'
                        f'   {set(recent_intvl_vals)},\n'
                        '   so interpret results with caution.\n'
                    )
            else:
                interval_text = 'No counts logged after last Summary.\n'

        return summary_text, interval_text

    @classmethod
    def show_analysis(cls, *keybind):
        """
        Generate a Toplevel window to display cumulative logged task
        data that have been analyzed by cls.analyze_logfile().
        Button appends displayed results to an analysis log file.
        Called from a Log.view() button or a master keybinding.

        :param keybind: Empty parameter to pass implicit keybind event.
        """

        # NOTE: When the log file is not found by analyze_logfile(), the
        #   returned texts will be empty, so no need to continue.
        summary_text, interval_text = cls.analyze_logfile()
        if not summary_text and not interval_text:
            return keybind

        pos_x, pos_y = app_position(15, 15)
        analysiswin = tk.Toplevel(bg='SteelBlue4')  # <- bg = master_bg)
        analysiswin.title('Analysis of logged data')
        analysiswin.geometry(f'+{pos_x}+{+pos_y}')
        analysiswin.minsize(520, 320)
        analysiswin.focus_set()

        # Separator dash from https://coolsymbol.com/line-symbols.html.
        sep = f'\n{"─" * 46}\n'
        text = summary_text + interval_text + sep
        num_lines = text.count('\n')
        analysistxt = tk.Text(analysiswin, font='TkFixedFont',
                              width=46, height=num_lines,
                              bg='grey85', fg='grey5',
                              relief='groove', bd=4, padx=15, pady=10)
        analysistxt.insert(1.0, text)
        analysistxt.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        ttk.Button(
            analysiswin, text='Save analysis',
            command=lambda: File.append_txt(cls.ANALYSISFILE, text, True, analysiswin)
            ).pack(padx=4)

        return keybind

    @classmethod
    def uptime(cls, logcontent: str) -> str:
        """
        Calculate sum of hours spent counting tasks. Does not include
        time segments with no reported tasks counts.

        :param logcontent: the read log file string.
        :return: total hours elapsed while logging active, as string.
                 Returns 'cannot determine' if negative time calculated.
        """
        start2intvl = []
        start2quit = []
        start2interrupt = []
        has_interval = False

        # *_dt vars are datetime.timedelta objects, so initialize with
        #    formatted Epoch origin time.
        start_dt = str2dt('1970-Jan-01 00:00:00', LONG_STRFTIME)
        interval_dt = str2dt('1970-Jan-01 00:00:00', LONG_STRFTIME)
        final_interval_hr = 0.0

        def calc_uptime_hr(start_datetime, end_datetime) -> float:
            """Convert datetime start and end difference to hours.
            """
            # Cannot calculate running time from the log file when have
            #   negative time diff between start and end times.
            if (end_datetime - start_datetime) / timedelta(hours=1) < 0:
                return -1.0
            return (end_datetime - start_datetime) / timedelta(hours=1)

        # Need to calc and sum uptime only for start-stop segments that have
        #   counted tasks for one or more intervals. LONG_STRFTIME is the
        #   time format used in the log file. Times recorded for each log
        #   entry begin the entry formatted as, '2021-Dec-05 16:33:49; ...'
        for line in logcontent.split('\n'):
            if 'most recent BOINC report' in line:
                starttime_match = search(
                    r'^(.+); .+ most recent BOINC report', line).group(1)
                start_dt = str2dt(starttime_match, LONG_STRFTIME)
                has_interval = False

            if 'Tasks reported' in line:
                intvltime_match = search(
                    r'^(.+); Tasks reported', line).group(1)
                interval_dt = str2dt(intvltime_match, LONG_STRFTIME)
                # Note: start2intvl list is used only to eval presence of a
                #   negative timedelta interval somewhere in the log file.
                start2intvl.append(calc_uptime_hr(start_dt, interval_dt))
                has_interval = True

            if 'quit' in line:
                quittime_match = search(
                    r'^(.+); .+ quit', line).group(1)
                quit_dt = str2dt(quittime_match, LONG_STRFTIME)
                if has_interval:
                    start2quit.append(calc_uptime_hr(start_dt, quit_dt))

            if 'interrupt' in line:
                interrupttime_match = search(
                    r'^(.+); .+ interrupt', line).group(1)
                interrupt_dt = str2dt(interrupttime_match, LONG_STRFTIME)
                if has_interval:
                    start2interrupt.append(calc_uptime_hr(start_dt, interrupt_dt))

        if -1.0 in start2quit + start2interrupt + start2intvl:
            return 'cannot determine'

        # The log text has been read, so now need to get uptime of the
        #   final start_dt -> final interval_dt segment.
        if has_interval:
            final_interval_hr = calc_uptime_hr(start_dt, interval_dt)

        return str(round(
            sum(start2quit) + sum(start2interrupt) + final_interval_hr, 1))

    @classmethod
    def view(cls, filepath: Path) -> None:
        """
        Create a separate window to view a text file as scrolled text.
        Called from View menu bar or keybinding.

        :param filepath: A Path object of the file to view.
        """
        # Need to set messages and sizes specific to OS and files.
        fnf_query = ''
        text_width = 79
        text_height = 46
        minsize_h = 0
        minsize_w = 0
        if filepath == cls.LOGFILE:
            fnf_query = 'Was the settings log option used?'
            minsize_h = 800
            minsize_w = 220
            if MY_OS == 'win':
                minsize_w = 200
            if MY_OS == 'dar':
                text_width = 72
        if filepath == cls.ANALYSISFILE:
            fnf_query = 'Have any analysis results been saved yet?'
            text_width = 46
            minsize_w = 450
            minsize_h = 420
            if MY_OS == 'win':
                minsize_h = 400

        if not Path.exists(filepath):
            info = (f'On {gethostname()}, file is missing:\n{filepath}\n'
                    f'{fnf_query}\n'
                    'Was file deleted, moved or renamed?')
            messagebox.showerror(title='FILE NOT FOUND', detail=info)
            return

        with open(filepath, encoding='utf-8') as file:
            logwin = tk.Toplevel(bg='SteelBlue4')  # <- bg = master_bg
            # Need to show working dir and file name in the Toplevel title.
            if MY_OS == 'win':
                dir_file = f'{filepath.parts[-2]}\\{filepath.parts[-1]}'
                logwin.title(f'{dir_file} on {gethostname()}')

            else:
                dir_file = f'{filepath.parts[-2]}/{filepath.parts[-1]}'
                logwin.title(f'{dir_file} on {gethostname()}')

            logwin.minsize(minsize_h, minsize_w)
            logwin.focus_set()
            # Use a "dark" background/foreground theme for log text.
            logtext = ScrolledText(logwin, font='TkFixedFont',
                                   width=text_width, height=text_height,
                                   bg='grey20', fg='grey80',
                                   relief='groove', bd=4, padx=12)
            logtext.insert(tk.INSERT, file.read())
            logtext.see('end')
            logtext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        ttk.Button(
            logwin, text='Update',
            command=(lambda: File.update(logtext, filepath, logwin))
        ).pack(padx=4)

        if filepath == cls.LOGFILE:
            ttk.Button(
                logwin, text='Backup',
                command=lambda: File.backup(filepath, logwin)
            ).pack(padx=4)
            ttk.Button(logwin, text='Analysis',
                       command=cls.show_analysis).pack(padx=4)

        if filepath == cls.ANALYSISFILE:
            ttk.Button(
                logwin, text='Erase',
                command=lambda: File.erase(cls.ANALYSISFILE, logtext, logwin)
            ).pack(padx=4)


# ############ A MVC add-on; independent of data functions #############
class CountFyi:
    """
    Methods to provide user with information and help.
    """

    def __init__(self, share):
        self.share = share

    @staticmethod
    def about() -> None:
        """
        Basic information for gcount-tasks.
        Toplevel window called from Help menu bar.
        """
        pos_x, pos_y = app_position(15, 15)
        aboutwin = tk.Toplevel()
        aboutwin.geometry(f'+{pos_x}+{+pos_y}')
        aboutwin.resizable(False, False)
        aboutwin.title('About count-tasks')
        num_doc_lines = __doc__.count('\n') + 2
        abouttxt = tk.Text(aboutwin, font='TkFixedFont',
                           width=74, height=num_doc_lines + 9,
                           bg='grey20', fg='grey85',
                           relief='groove', borderwidth=5, padx=25)
        abouttxt.insert(1.0,
                        f'{__doc__}\n'
                        f'{"Author:".ljust(13)}{__author__}\n'
                        f'{"Credits:".ljust(13)}{__credits__}\n'
                        f'{"License:".ljust(13)}{__license__}\n'
                        f'{"Program:".ljust(13)}{__program_name__}\n'
                        f'{"Version:".ljust(13)}{__version__}\n'
                        f'{"Dev. Env.:".ljust(13)}{__dev_environment__}\n'
                        f'{"URL:".ljust(13)}{__project_url__}\n'
                        f'{"Maintainer:".ljust(13)}{__maintainer__}\n'
                        f'{"Status:".ljust(13)}{__status__}\n')
        abouttxt.pack()

    def compliment_me(self) -> None:
        """A silly diversion; called from Help menu bar and keybinding.
        """
        compliments = [
            "Hey there good lookin'!", 'I wish we had met sooner.',
            'You are the smartest person I know.', 'I like your hair.',
            'You have such a nice smile.', 'Smart move!',
            'Blue is your color.', 'Good choice!',
            "That's very kind of you.", "Stop! You're making me blush.",
            'I just love what you did.', 'How witty you are!', 'Awesome!',
            'Your tastes are impeccable.', "You're incredible!",
            'You are so talented!', "I wish I'd thought of that.",
            'This is fun!', 'Get back to work.', 'Nice!', 'You saved me.',
            'You are an inspiration to us all.', "That's so funny!",
            'Show me how you do that.', "I've always looked up to you.",
            'You sound great!', 'You smell nice.', 'Great job!',
            'You are a role model.', 'I wish more people were like you.',
            'We appreciate what you did.', 'I hear people look up to you.',
            'You are a really good dancer.', 'What makes you so successful?',
            'When you speak, people listen.', 'You are a superb person.',
            'You rock!', 'You nailed it!', 'That was really well done.',
            'You are amazing!', 'We need more folks like you around here.',
            'Excuse me, are you a model?', 'What a lovely laugh you have.',
            "I'm jealous of your ability.", "You're the stuff of legends.",
            'This would not be possible without you.', 'Way to go! Yay!',
            'Did you make that? I love it!', 'You are the best!',
            'I like what you did.', 'Whoa. Have you been working out?',
            "We can't thank you enough.", 'No, really, you have done enough.',
            "That's a good look for you.", 'I could not have done it better.',
            "I can't think of anything to say. Sorry.", 'Congratulations!',
            "Well, THAT's impressive.", 'I hear that you are the one.',
            'You excel at everything.', 'Your voice is very soothing.',
            'Is it true what people say?', 'The word is, you got it!',
            'The Nobel Committee has been trying to reach you.',
            'The Academy is asking for your CV.', 'You look great!',
            'The President seeks your council.', 'Thank you so much!',
            'The Prime Minister seeks your council.', 'Crunchers rule!',
            'Crunchers are the best sort of people.'
        ]
        praise = choice(compliments)
        self.share.compliment_l.config(text=praise)
        self.share.notice_l.grid_remove()
        # Need to re-grid initial master_widgets gridding b/c its grid may
        #   have been removed by a notice_l call. Original grid coordinates
        #   are set in master_widgets().
        self.share.compliment_l.grid()

        def refresh():
            self.share.compliment_l.grid_remove()
            # Re-grid notice to return to current Notice text.
            self.share.notice_l.grid()
            app.update_idletasks()

        self.share.compliment_l.after(3333, refresh)

    @staticmethod
    def information() -> None:
        """
        Basic information, usage, and actions.
        Toplevel window called from Help menu bar.
        """

        # Make call to app_position() before Toplevel() to avoid noticeable
        #   shift of the info window.
        pos_x, pos_y = app_position(15, 15)
        infowin = tk.Toplevel()
        infowin.geometry(f'+{pos_x}+{+pos_y}')
        infowin.resizable(False, False)
        infowin.title('Usage information')
        information = ("""
            - Counting begins once "Count now" is clicked in settings window.\n
            - Interval and Summary data buttons switch visual emphasis;
                    ...those buttons activate once their data post.\n
            - At start, # tasks reported and time of last count are from
                    the most recent hourly BOINC report.\n
            - Number of tasks in queue and Notices update every"""
                       f' {NOTICE_INTERVAL} seconds.\n'
                       """
            - Displayed countdown clock time is approximate.\n
            - Counts and Notices histories are in the log file.\n
            - File>'Backup log file', copy log to location of user's choice.\n
            - When analysis of logged hours is "cannot determine"...\n
                    Quick fix: backup then delete log file, restart program.
            """)

        num_doc_lines = information.count('\n')
        os_width = 0
        if MY_OS in 'lin, win':
            os_width = 64
        elif MY_OS == 'dar':
            os_width = 56
        infotxt = tk.Text(infowin, font='TkTextFont',
                          width=os_width, height=num_doc_lines + 2,
                          bg='grey20', fg='grey85',
                          relief='groove', padx=15)
        infotxt.insert(1.0, information)
        infotxt.pack()


# ############################ MVC Classes #############################
# MVC Modeler: The engine that gets BOINC data and runs count intervals.
class CountModeler:
    """
    Counting, statistical analysis, and formatting of BOINC task data.
    """
    # Need to have these vars as Class attributes, so they will not be
    # reset when interval_data() is called. ttimes_smry would be okay
    # in __init__, but is here for clarity.
    ttimes_used = set()
    ttimes_smry = set()

    def __init__(self, share):
        self.share = share
        self.thread_lock = threading.Lock()
        self.task_count_start = 0
        self.task_count_new = 0

    def default_settings(self) -> None:
        """
        Set or reset default run parameters in the setting dictionary.
        """
        self.share.setting['interval_t'].set('1h')
        self.share.setting['interval_m'].set(60)
        self.share.intvl_choice['values'] = ('1h', '30m', '20m', '15m', '10m')
        self.share.intvl_choice.select_clear()
        self.share.setting['summary_t'].set('1d')
        self.share.setting['sumry_t_value'].set(1)
        self.share.setting['sumry_t_unit'].set('day')
        self.share.sumry_unit_choice['values'] = ('day', 'hr', 'min')
        self.share.sumry_unit_choice.select_clear()
        self.share.setting['cycles_max'].set(1008)
        self.share.setting['do_log'].set(True)
        self.share.setting['proj_update'].set(False)

    def start_data(self):
        """
        Gather initial task data and times; set data dictionary
        control variables. Log data to file if so optioned.
        Called from check_and_start().
        """
        # As with task names, task times as sec.microsec are unique.
        #   In future, may want to inspect task names with
        #     tnames = BC.get_reported('tasks').
        ttimes_start = BC.get_reported('elapsed time')
        self.share.data['task_count'].set(len(ttimes_start))
        self.share.data['num_tasks_all'].set(len(BC.get_tasks('name')))

        # Begin set of used/old tasks to exclude from new tasks;
        #   used in interval_data() to track tasks across intervals.
        self.ttimes_used.update(ttimes_start)

        # Need to parse and set data returned from ttimes_stats().
        startdict = ttimes_stats(ttimes_start)
        self.share.data['tt_avg'].set(startdict['tt_avg'])
        self.share.data['tt_sd'].set(startdict['tt_sd'])
        self.share.data['tt_range'].set(
            f"{startdict['tt_min']} -- {startdict['tt_max']}")
        self.share.data['tt_total'].set(startdict['tt_total'])

        self.share.data['time_prev_cnt'].set('Last hourly BOINC report.')

        if self.share.setting['do_log'].get():
            self.share.logit('start')

    def task_states(self) -> None:
        """
        Query boinc-client for status of tasks queued, running, and
        suspended; set corresponding dictionary tk control variables.
        Called from notice_it().
        """

        self.share.status_time = datetime.now().strftime(LONG_STRFTIME)
        tasks_all = BC.get_tasks('all')
        no_new_tasks = BC.no_new_tasks()

        # Need the literal task data tags as found in boinccmd stdout;
        #   the format is same as tag_str in BC.get_tasks().
        #   Use tuple index to populate the list expressions.
        tags = ('   name: ',
                '   active_task_state: ',
                '   state: ')
        num_tasks_all = len([elem for elem in tasks_all if tags[0] in elem])
        tasks_active = [elem.replace(tags[1], '') for elem in tasks_all
                        if tags[1] in elem]
        task_states = [elem.replace(tags[2], '') for elem in tasks_all
                       if tags[2] in elem]
        # When communication to server is stalled, all tasks will be
        #  "Ready to report" with a state of 'uploaded', so a forced
        #   Project update in notice_it() may prompt finalizing
        #   the task upload.
        if 'uploaded' in task_states and 'downloaded' not in task_states:
            self.share.note['proj_stalled'].set(True)
        num_running = len(
            [task for task in tasks_active if 'EXECUTING' in task])
        num_suspended_by_boinc = len(
            [task for task in tasks_active if 'SUSPENDED' in task])
        num_suspended_by_user = len(
            [task for task in tasks_all if 'suspended via GUI: yes' in task])

        self.share.data['num_tasks_all'].set(num_tasks_all)
        self.share.note['num_running'].set(num_running)
        self.share.note['num_suspended_by_boinc'].set(num_suspended_by_boinc)
        self.share.note['num_suspended_by_user'].set(num_suspended_by_user)
        self.share.note['no_new_tasks'].set(no_new_tasks)

    def interval_data(self) -> None:
        """
        Run timer and countdown clock to update and analyze regular and
        summary data for task status and times. Set control variables
        for data and note dictionaries.
        Is threaded as interval_thread; start in Viewer.start_threads()
        Calls to: ttimes_stats(), get_minutes(), log_it().
        """
        ttimes_new = set()
        ttimes_smry = set()
        cycles_max = self.share.setting['cycles_max'].get()
        interval_m = self.share.setting['interval_m'].get()
        reference_time = time.time()
        tic_nnt = 0
        sumry_intvl_counts = []
        sumry_intvl_ttavgs = []

        for cycle in range(cycles_max):
            if cycle == 1 or cycles_max == 1:
                # Need to change button name and function from Start to Interval
                #   after initial cycle[0] completes and intvl data displays.
                #  It might be better if statement were in Viewer, but simpler
                #  to put it here with easy reference to cycle.
                self.share.starting_b.grid_forget()
                self.share.intvl_b.grid(row=0, column=1,
                                        padx=(16, 0), pady=(8, 4))

            # Need to sleep between counts while displaying a countdown timer.
            # Need to limit total time of interval to target_elapsed_time,
            #   in Epoch seconds, b/c each interval sleep cycle will run longer
            #   than the intended interval. Realized interval time should not
            #   drift by more than 1 second during count_max cycles.
            # Without this time limit, each 1h interval would gain ~4s.
            interval_sec = interval_m * 60
            target_elapsed_time = reference_time + (interval_sec * (cycle + 1))
            for _sec in range(interval_sec):
                if cycle == cycles_max:
                    break
                if time.time() > target_elapsed_time:
                    self.share.data['time_next_cnt'].set('00:00')
                    break
                interval_sec -= 1
                # Need to show the time remaining in clock time format.
                self.share.data['time_next_cnt'].set(
                    TC.sec_to_format(interval_sec, 'clock'))
                time.sleep(1.0)

            # NOTE: Starting tasks are not included in interval and summary
            #   counts, but starting task times are used here to determine
            #   "new" tasks.
            # Need to add all prior tasks to the "used" set.
            #  "new" task times are carried over from the prior interval cycle.
            #  For cycle[0], ttimes_used is starting tasks from start_data()
            #    and ttimes_new is empty.
            with self.thread_lock:
                self.ttimes_used.update(ttimes_new)
                ttimes_reported = set(BC.get_reported('elapsed time'))

                # Need to reset prior ttimes_new, then repopulate it with only
                #   newly reported tasks.
                ttimes_new.clear()
                ttimes_new = ttimes_reported - self.ttimes_used

                task_count_new = len(ttimes_new)
                self.share.data['task_count'].set(task_count_new)
                # Add new tasks to summary set for later analysis.
                ttimes_smry.update(ttimes_new)

                cycles_remain = int(self.share.data['cycles_remain'].get()) - 1
                self.share.data['cycles_remain'].set(cycles_remain)
                # Display weekday with time of previous interval to aid the user.
                self.share.data['time_prev_cnt'].set(
                    datetime.now().strftime(DAY_STRFTIME))
                # Capture full ending time here, instead of in log_it(),
                #   so that the logged time matches displayed time.
                self.share.data['intvl_count_t'].set(
                    datetime.now().strftime(LONG_STRFTIME))

                # Track when no new tasks were reported in past interval;
                #   tic_nnt used in log_it().
                # Need to update num_running value from task_states().
                self.task_states()
                num_running = self.share.note['num_running'].get()
                if task_count_new == 0:
                    tic_nnt += 1
                elif task_count_new > 0 and num_running > 0:
                    tic_nnt = 0
                self.share.note['tic_nnt'].set(tic_nnt)

                # Need to parse data returned from ttimes_stats().
                intervaldict = ttimes_stats(ttimes_new)

                self.share.data['tt_avg'].set(intervaldict['tt_avg'])
                self.share.data['tt_sd'].set(intervaldict['tt_sd'])
                self.share.data['tt_range'].set(
                    f"{intervaldict['tt_min']} -- {intervaldict['tt_max']}")
                self.share.data['tt_total'].set(intervaldict['tt_total'])

                # Need to gather interval times and counts for ea. interval in
                #   a summary segment to calc weighted mean times. This sumry
                #   list has a different function than the ttimes_smry set.
                sumry_intvl_counts.append(task_count_new)
                sumry_intvl_ttavgs.append(self.share.data['tt_avg'].get())

                # SUMMARY DATA ####################################################
                # NOTE: Starting data are not included in summary tabulations.
                summary_m = TC.string_to_m(self.share.setting['summary_t'].get())
                # When summary interval is >= 1 week, need to provide date of
                #   prior summary rather than weekday, as above (%A %H:%M).
                if summary_m >= 10080:
                    self.share.data['time_prev_cnt'].set(
                        datetime.now().strftime(LONGSMRY_STRF))
                summary_time = self.share.data['time_prev_cnt'].get()
                if (cycle + 1) % (summary_m // interval_m) == 0 and num_running > 0:
                    # Flag used in log_it() to log summary data.
                    self.share.data['log_summary'].set(True)
                    # Need to activate disabled Summary data button now; only need
                    #  statement for 1st summary, but, oh well, here we go again...
                    self.share.sumry_b.config(state=tk.NORMAL)

                    # Set time and stats of summary count.
                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(len(ttimes_smry))
                    summarydict = ttimes_stats(ttimes_smry)
                    self.share.data['tt_sd_sumry'].set(summarydict['tt_sd'])
                    self.share.data['tt_range_sumry'].set(
                        f"{summarydict['tt_min']} -- {summarydict['tt_max']}")
                    self.share.data['tt_total_sumry'].set(summarydict['tt_total'])

                    # Need the weighted mean summary task time, not the average
                    #   (arithmetic mean) value.
                    tt_wtmean = interval_stats(
                        sumry_intvl_ttavgs, 'wtmean', sumry_intvl_counts)
                    self.share.data['tt_mean_sumry'].set(tt_wtmean)

                    # Need to reset data set for the next summary interval.
                    ttimes_smry.clear()
                    sumry_intvl_counts.clear()
                    sumry_intvl_ttavgs.clear()

            # Call to log_it() needs to be outside of the thread lock.
            app.update_idletasks()
            if self.share.setting['do_log'].get():
                self.share.logit('interval')

    def notice_it(self) -> None:
        """
        Notices for BOINC task state information should run on short
        time intervals.
        Is threaded as notice_thread; start in Viewer.start_threads().
        Calls to: task_states() and log_it().
        """
        while self.share.data['cycles_remain'].get() > 0:
            time.sleep(NOTICE_INTERVAL)
            with self.thread_lock:
                # Need to quit app if boinc-client is no longer running.
                check_boinc()

                self.task_states()
                num_running = self.share.note['num_running'].get()
                num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
                num_suspended_by_boinc = self.share.note['num_suspended_by_boinc'].get()
                num_tasks_all = self.share.data['num_tasks_all'].get()
                tic_nnt = self.share.note['tic_nnt'].get()
                proj_stalled = self.share.note['proj_stalled'].get()
                no_new_tasks = self.share.note['no_new_tasks'].get()
                cycles_max = self.share.setting['cycles_max'].get()
                cycles_remain = self.share.data['cycles_remain'].get()
                interval_m = self.share.setting['interval_m'].get()

                # Need to change to notice fg color from "All is well" row_fg color.
                self.share.notice_l.config(fg=self.share.highlight)

                # Need notices for task status that might need user attention,
                #   conditioned in descending priority.
                if num_running > 0:
                    if num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'{num_suspended_by_user} tasks are suspended by user.\n'
                            'BOINC will not upload while tasks are suspended.')
                    elif num_running >= (num_tasks_all - 1):
                        self.share.note['notice_txt'].set(
                            'BOINC client is about to run out of tasks.\n'
                            'Check BOINC Manager.')
                    elif tic_nnt > 0:
                        nnt_time = TC.sec_to_format(
                            (tic_nnt * interval_m * 60), 'short')
                        self.share.note['notice_txt'].set(
                            f'NO TASKS reported in past {nnt_time}\n'
                            f'for the prior {tic_nnt} counting interval(s).')
                    else:
                        # Everything is fine, remove any prior notice.
                        # Use a de-emphasized color for this non-notice status text.
                        self.share.notice_l.config(fg=self.share.row_fg)
                        self.share.note['notice_txt'].set(
                            f'All is well (updates every {NOTICE_INTERVAL} seconds)')

                if num_running == 0:
                    if proj_stalled:
                        if self.share.setting['proj_update'].get():
                            # Note: this will sleep notice_it() for 70 seconds.
                            self.update_project()
                        else:
                            self.share.note['notice_txt'].set(
                                'A PROJECT UPDATE MAY BE NEEDED.\n'
                                'Check BOINC Manager.')
                    elif num_tasks_all == 0:
                        self.share.note['notice_txt'].set(
                            'BOINC client has no tasks to run!\n'
                            'Check BOINC Manager.')
                        if no_new_tasks:
                            self.share.note['notice_txt'].set(
                                'BOINC client has no tasks to run!\n'
                                'Project is set to receive no new tasks.\n'
                                'Check BOINC Manager Projects.')
                    elif num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'NO TASKS running; {num_suspended_by_user} tasks suspended by user.\n'
                            'You may want to resume them.')
                    elif num_suspended_by_boinc > 0:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running.\n'
                            'A BOINC Manager "When to suspend" condition was met.\n'
                            'Edit BOINC Manager Computing preferences if this is a problem.')
                    else:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running; reason unknown\nCheck BOINC Manager.')

                if cycles_remain == 0:
                    prior_note = self.share.note['notice_txt'].get()
                    if prior_note:
                        self.share.note['notice_txt'].set(
                            f'{prior_note}\n'
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    else:
                        self.share.note['notice_txt'].set(
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    print(f'\n*** {cycles_max} of {cycles_max} counting cycles have ended. ***\n')

            app.update_idletasks()
            # Call to log_it() here needs to be outside of the thread lock.
            if self.share.setting['do_log'].get():
                self.share.logit('notice')

    def log_it(self, called_from=None) -> None:
        """
        Write to file interval and summary metrics for recently reported
        BOINC tasks. Provide information on aberrant task status.
        Called from interval_data() and notice_it().
        Is threaded as log_thread; start in Viewer.start_threads()

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """

        # Log text file formatting:
        indent = ' ' * 22
        bigindent = ' ' * 33

        # Note: Lots of local variables are used here to make the notice text
        #   statements easier to read
        #   Var outside of thread lock are set in settings() and invariant.
        cycles_max = self.share.setting['cycles_max'].get()
        interval_t = self.share.setting['interval_t'].get()
        summary_t = self.share.setting['summary_t'].get()
        intvl_count_t = self.share.data['intvl_count_t'].get()
        with self.thread_lock:
            if called_from == 'start':
                self.task_count_start = self.share.data['task_count'].get()
            elif called_from == 'interval':
                self.task_count_new = self.share.data['task_count'].get()
            tt_avg = self.share.data['tt_avg'].get()
            tt_sd = self.share.data['tt_sd'].get()
            tt_range = self.share.data['tt_range'].get()
            tt_total = self.share.data['tt_total'].get()
            num_tasks_all = self.share.data['num_tasks_all'].get()
            cycles_remain = self.share.data['cycles_remain'].get()
            num_running = self.share.note['num_running'].get()
            num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
            no_new_tasks = self.share.note['no_new_tasks'].get()
            tic_nnt = self.share.note['tic_nnt'].get()

            if called_from == 'start' and cycles_max > 0:
                report = (
                    f'\n>>> START GUI TASK COUNTER v.{__version__}, SETTINGS: <<<\n'
                    f'{self.share.long_time_start};'
                    ' Number of tasks in the most recent BOINC report:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}Number of scheduled count intervals: {cycles_max}\n'
                    f'{indent}Counts every {interval_t}, summaries every {summary_t}.\n'
                    f'{indent}BOINC status evaluations every {NOTICE_INTERVAL}s.\n'
                    f'{indent}Project auto-update:'
                    f" {self.share.setting['proj_update'].get()}\n"
                    'Timed intervals beginning now...\n')
                logging.info(report)
            # Need to provide a truncated report for one-off "status" runs.
            elif called_from == 'start' and cycles_max == 0:
                report = (
                    f'\n{self.share.long_time_start}; STATUS REPORT\n'
                    f'{indent}Number of tasks recently reported by BOINC:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n')
                logging.info(report)

            # Note: Two timestamps are used: self.share.data['intvl_count_t']
            #   is defined in interval_data() at end of each count cycle,
            #   self.share.status_time is defined in task_states().
            if called_from == 'notice' and num_running > 0:
                # A Notice for no new tasks reported, tic_nnt, is issued in
                #   interval_data() instead of here.
                if num_running == num_tasks_all:
                    report = (f'\n{self.share.status_time};'
                              'BOINC client is about to run out of tasks.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'\n{self.share.status_time}; '
                              f'{num_suspended_by_user} tasks are suspended by user.')
                    logging.info(report)
            elif called_from == 'notice' and num_running == 0:
                report = (f'\n{self.share.status_time};'
                          ' *** NO TASKS RUNNING. Check BOINC Manager.***')
                logging.info(report)
                if self.share.note['proj_stalled'].get():
                    report = (
                        f' *** PROJECT AUTO-UPDATE REQUESTED for {self.share.first_project}. ***\n'
                        '  All tasks were "Ready to report" and waiting to upload.\n'
                        '  If Project auto-update is allowed, tasks should now be uploaded.\n'
                        '  Verify in BOINC Manager.')
                    logging.info(report)
                if num_tasks_all == 0:
                    report = f'{indent}BOINC client has no tasks!\n'
                    logging.info(report)
                if self.share.note['num_suspended_by_boinc'].get() > 0:
                    report = (f'{indent}BOINC Manager has suspended tasks;\n'
                              f'{indent}A "When to suspend" condition was met\n'
                              f'{indent}in BOINC Manager Computing preferences.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'{indent}'
                              f'{num_suspended_by_user} tasks suspended by user.')
                    logging.info(report)
                if no_new_tasks:
                    report = (f'{indent}Not receiving new tasks.\n'
                              f'{indent}Check BOINC Manager Projects.')
                    logging.info(report)

            if called_from == 'interval' and tic_nnt > 0:
                report = (f'\n{intvl_count_t}; NO TASKS reported in the past'
                          f' {tic_nnt} counting intervals.\n'
                          f'{indent}{cycles_remain} counts remain.')
                logging.info(report)

            # This tic condition is equivalent to: task_count_new > 0 and
            #   num_running > 0; that is, everything normal.
            elif called_from == 'interval' and tic_nnt == 0:
                report = (
                    f'\n{intvl_count_t}; Tasks reported in the past {interval_t}:'
                    f' {self.task_count_new}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}{cycles_remain} counts remain.'
                )
                logging.info(report)

            if called_from == 'interval' and self.share.data['log_summary'].get():
                report = (
                    f'\n{intvl_count_t}; >>> SUMMARY: Count for the past'
                    f" {summary_t}: {self.share.data['task_count_sumry'].get()}\n"
                    f"{indent}Task Time: mean {self.share.data['tt_mean_sumry'].get()},\n"
                    f"{bigindent}range [{self.share.data['tt_range_sumry'].get()}],\n"
                    f"{bigindent}stdev {self.share.data['tt_sd_sumry'].get()},"
                    f" total {self.share.data['tt_total_sumry'].get()}")
                logging.info(report)
                # Need to reset flag to toggle summary logging.
                self.share.data['log_summary'].set(False)

            if called_from == 'interval' and cycles_remain == 0:
                report = f'\n### {cycles_max} counting cycles have ended. ###\n'
                logging.info(report)

    def update_project(self):
        """
        Called from notice_it() when update project setting is True.
        """
        # I'm not sure how to handle multiple concurrent Projects.
        # B/c of how BC.project_action is structured, here I use the
        #  url to get the Project name ID which is used to get the
        #  url needed for the project cmd.  Silly, but uses existing
        #  boinc_command.py methods. Is there a better way?
        first_local_url = BC.get_project_url()[0]
        self.share.first_project = list(BC.project_url.keys())[
            list(BC.project_url.values()).index(first_local_url)]
        BC.project_action(self.share.first_project, 'update')
        self.share.note['notice_txt'].set(
            'Project auto-update in progress for'
            f' {self.share.first_project}...')
        if self.share.setting['do_log'].get():
            self.share.logit('notice')
        # Need to provide time for BOINC Project server to respond before
        #   continuing with notice_it() thread.
        time.sleep(70)


# MVC Viewer, the tkinter GUI engine; runs in main thread.
class CountViewer(tk.Frame):
    """
    The Viewer communicates with Modeler via 'share' objects handled
    through the Controller class. All GUI widgets go here.
    """

    def __init__(self, share):
        super().__init__()
        self.share = share
        # Note that self.master is an internal attribute and refers to the
        #   CountController() Tk top window. Outside of CountViewer(),
        #   use app. to refer to the CountController() Tk object.
        self.dataframe = tk.Frame()
        self.menubar = tk.Menu()

        # Set colors for row labels and data display.
        # These colors are compatible with red-green color-blindness.
        self.share.row_fg = 'LightYellow'  # foreground for row labels
        self.master_bg = 'SteelBlue4'  # also used for row header labels
        self.data_bg = 'grey40'  # background for data labels and frame
        self.share.highlight = 'gold1'  # fg for notices, compliments, et al.
        self.emphasize = 'grey90'
        self.deemphasize = 'grey60'

        # Need to grey-out menu bar headings and View log button when
        #   another application has focus.
        #   source: https://stackoverflow.com/questions/18089068/
        #   tk-tkinter-detect-application-lost-focus
        self.bind_all("<FocusIn>", self.app_got_focus)
        self.bind_all("<FocusOut>", self.app_lost_focus)

        # settings() window widgets:
        self.settings_win = tk.Toplevel()
        self.share.intvl_choice = ttk.Combobox(self.settings_win)
        self.sumry_value_entry = ttk.Entry(self.settings_win)
        self.share.sumry_unit_choice = ttk.Combobox(self.settings_win)
        self.cycles_max_entry = ttk.Entry(self.settings_win)
        self.countnow_button = ttk.Button(self.settings_win)
        self.log_choice = tk.Checkbutton(self.settings_win)
        self.update_choice = tk.Checkbutton(self.settings_win)
        self.good_settings = False

        # Control variables for basic run parameters/settings passed
        #    between Viewer and Modeler.
        self.share.setting = {
            'interval_t': tk.StringVar(),
            'interval_m': tk.IntVar(),
            'sumry_t_value': tk.IntVar(),
            'sumry_t_unit': tk.StringVar(),
            'summary_t': tk.StringVar(),
            'cycles_max': tk.IntVar(),
            'do_log': tk.BooleanVar(),
            'proj_update': tk.BooleanVar()
        }

        # Control variables for display in master, passed between
        #    Viewer and Modeler.
        self.share.data = {
            # Start and Interval data
            'task_count': tk.IntVar(),
            'tt_avg': tk.StringVar(),
            'tt_sd': tk.StringVar(),
            'tt_range': tk.StringVar(),
            'tt_total': tk.StringVar(),
            'intvl_count_t': tk.StringVar(),
            # General data
            'time_prev_cnt': tk.StringVar(),
            'cycles_remain': tk.IntVar(),
            'time_next_cnt': tk.StringVar(),
            'num_tasks_all': tk.IntVar(),
            # Summary data
            'time_prev_sumry': tk.StringVar(),
            'task_count_sumry': tk.IntVar(),
            'tt_mean_sumry': tk.StringVar(),
            'tt_sd_sumry': tk.StringVar(),
            'tt_range_sumry': tk.StringVar(),
            'tt_total_sumry': tk.StringVar(),
            'log_summary': tk.BooleanVar()
        }

        # Control variables for notices and logging passed between
        #   Viewer and Modeler and between Modeler threads.
        self.share.note = {
            'notice_txt': tk.StringVar(),
            'num_running': tk.IntVar(),
            'tic_nnt': tk.IntVar(),
            'proj_stalled': tk.BooleanVar(),
            'no_new_tasks': tk.BooleanVar(),
            'num_suspended_by_user': tk.IntVar(),
            'num_suspended_by_boinc': tk.IntVar(),
        }

        # Labels for settings values; gridded in master_layout(). They are
        #   fully configured here simply to reduce number of lines in code.
        # NOTE: self.time_start_l label is initially configured for text to
        #   show a startup message, then reconfigured in emphasize_start_data()
        #   for the time_start.
        self.time_start_l = tk.Label(
            self.dataframe, bg=self.data_bg, fg='grey90')
        self.interval_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['interval_t'],
            relief='groove', bg=self.data_bg)
        self.summary_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['summary_t'],
            relief='groove', bg=self.data_bg)
        self.cycles_max_l = tk.Label(
            textvariable=self.share.setting['cycles_max'],
            bg=self.master_bg, fg=self.share.row_fg)

        # Labels for BOINC data.
        self.task_count_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count'])
        self.tt_avg_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_avg'])
        self.tt_sd_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd'])
        self.tt_range_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range'])
        self.tt_total_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total'])
        self.task_count_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count_sumry'])
        self.ttmean_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_mean_sumry'])
        self.ttsd_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd_sumry'])
        self.ttrange_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range_sumry'])
        self.ttsum_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total_sumry'])
        # Data labels in master
        self.time_prev_cnt_l = tk.Label(
            textvariable=self.share.data['time_prev_cnt'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_prev_sumry_l = tk.Label(
            textvariable=self.share.data['time_prev_sumry'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_next_cnt_l = tk.Label(
            textvariable=self.share.data['time_next_cnt'],
            bg=self.master_bg, fg=self.share.highlight)
        self.cycles_remain_l = tk.Label(
            textvariable=self.share.data['cycles_remain'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.num_tasks_all_l = tk.Label(
            textvariable=self.share.data['num_tasks_all'],
            bg=self.master_bg, fg=self.share.row_fg)
        # Text for compliment_l is configured in compliment_me()
        self.share.compliment_l = tk.Label(
            bg=self.master_bg, fg=self.share.highlight)
        self.share.notice_l = tk.Label(
            textvariable=self.share.note['notice_txt'],
            fg=self.share.highlight, bg=self.master_bg,
            relief='flat', border=0)

        # This style is used only to configure viewlog_b color in
        #   app_got_focus() and app_lost_focus().
        self.view_button_style = ttk.Style(self.master)

        self.master_widgets()
        self.master_layout()
        self.share.defaultsettings()
        self.settings()
        # Starting functions sequence after settings() is called:
        #   check_and_set(), check_and_start(), start_threads(),
        #   emphasize_start_data(), CountModeler.start_data().
        # Note: none of that sequence matters, however, if BOINC
        #   client is not running, so...
        check_boinc()

    def master_widgets(self) -> None:
        """
        Master app menus and buttons.
        """
        self.master.config(menu=self.menubar)
        # Add pull-down menus
        file = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="File", menu=file)
        file.add_command(
            label="Backup log file",
            command=lambda: File.backup(Logs.LOGFILE))
        file.add_separator()
        file.add_command(label='Quit', command=quit_gui,
                         accelerator='Ctrl+Q')
        # ^^ Note: use Ctrl+Q for macOS also to call quit_gui; Cmd+Q still works.
        view = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="View", menu=view)
        view.add_command(label="Log file",
                         command=lambda: Logs.view(Logs.LOGFILE),
                         # MacOS: can't display "Cmd+L" b/c won't override native cmd.
                         accelerator="Ctrl+L")
        view.add_command(label="Analysis", command=Logs.show_analysis,
                         accelerator="Ctrl+A")
        view.add_command(label="Saved analyses",
                         command=lambda: Logs.view(Logs.ANALYSISFILE))
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label='Information', command=self.share.info)
        help_menu.add_command(label="Compliment", command=self.share.compliment,
                              accelerator="Ctrl+Shift+C")
        help_menu.add_command(label="About", command=self.share.about)

        self.share.viewlog_b = ttk.Button(self.master, text='View log file',
                                          command=lambda: Logs.view(Logs.LOGFILE))
        # Set interval & summary focus button attributes with *.share.* b/c need
        #   to reconfigure them in Modeler.
        # starting_b will be replaced with an active ttk intvl_b after first
        #   interval completes; it is re-gridded in interval_data().
        # starting_b is tk.B b/c ttk.B doesn't use disabledforeground keyword.
        self.share.starting_b = tk.Button(self.master, text='Starting data', width=18,
                                          disabledforeground='grey10',
                                          state=tk.DISABLED)
        self.share.intvl_b = ttk.Button(self.master, text='Interval data', width=18,
                                        command=self.emphasize_intvl_data)
        self.share.sumry_b = ttk.Button(self.master, text='Summary data', width=20,
                                        command=self.emphasize_sumry_data)

    def master_layout(self) -> None:
        """
        Master and dataframe configuration, keybindings, row headers,
        separators, and grids.
        """

        # OS-specific window size ranges set in Controller __init__
        # Need to color in all the master Frame and use near-white border;
        #   bd changes to darker shade for click-drag and loss of focus.
        self.master.config(bg=self.master_bg,
                           highlightthickness=3,
                           highlightcolor='grey95',
                           highlightbackground='grey75'
                           )
        # Need to provide exit info to Terminal and log.
        self.master.protocol('WM_DELETE_WINDOW', quit_gui)

        self.master.bind_all('<Escape>', quit_gui)
        self.master.bind('<Control-q>', quit_gui)
        # ^^ Note: macOS Command-q will quit program without quit_gui info msg.
        self.master.bind_all('<Control-a>', Logs.show_analysis)
        self.master.bind('<Shift-Control-C>', self.share.compliment)
        self.master.bind('<Control-l>', lambda event: Logs.view(Logs.LOGFILE))

        # Theme controls entire window theme, but only for ttk.Style objects.
        # Options: classic, alt, clam, default, aqua(MacOS only)
        ttk.Style().theme_use('alt')

        self.master.columnconfigure(1, weight=1)
        self.master.columnconfigure(2, weight=1)

        self.dataframe.configure(borderwidth=3, relief='sunken',
                                 bg=self.data_bg)
        self.dataframe.grid(row=2, column=1, rowspan=7, columnspan=2,
                            padx=(5, 10), sticky=tk.NSEW)
        self.dataframe.columnconfigure(1, weight=1)
        self.dataframe.columnconfigure(2, weight=1)

        # Fill in headers for all data rows.
        row_header = {'Counting since': 2,
                      'Count interval, t': 3,
                      '# tasks reported': 4,
                      'Task times:  avg': 5,
                      'stdev': 6,
                      'range': 7,
                      'total': 8,
                      'Interval time:': 10,
                      'Next count in:': 11,
                      'Tasks in queue:': 12,
                      'Notices:': 13
                      }
        for header, rownum in row_header.items():
            tk.Label(self.master, text=f'{header}',
                     bg=self.master_bg, fg=self.share.row_fg
                     ).grid(row=rownum, column=0, padx=(5, 0), sticky=tk.NE)
            # ^^ Grid to N (NE) to prevent Notices label from shifting down
            #    when more than one row of notice_it text appears.
        # Need to accommodate instances of two headers in same row.
        tk.Label(self.master, text='Summary time:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=10, column=2, sticky=tk.W)
        tk.Label(self.master, text='Counts until exit:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=12, column=2, sticky=tk.W)

        # For colored separators, use ttk.Frame instead of ttk.Separator.
        # Initialize then configure style for separator color.
        style_sep = ttk.Style(self.master)
        style_sep.configure('Sep.TFrame', background=self.master_bg)
        sep1 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)
        sep2 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)

        # %%%%%%%%%%%%%%%%%%% grid: sorted by row number %%%%%%%%%%%%%%%%%%%%%%
        self.share.viewlog_b.grid(
            row=0, column=0, padx=5, pady=(8, 4))
        self.share.starting_b.grid(
            row=0, column=1, padx=(16, 0), pady=(6, 4))
        self.share.sumry_b.grid(
            row=0, column=2, padx=(0, 22), pady=(8, 4))
        sep1.grid(
            row=1, column=0, columnspan=5, padx=5, pady=(2, 5), sticky=tk.EW)
        self.time_start_l.grid(
            row=2, column=1, columnspan=2, padx=(10, 16), sticky=tk.EW)
        self.interval_t_l.grid(
            row=3, column=1, padx=(12, 6), sticky=tk.EW)
        self.summary_t_l.grid(
            row=3, column=2, padx=(0, 16), sticky=tk.EW)
        self.task_count_l.grid(
            row=4, column=1, padx=10, sticky=tk.EW)
        self.task_count_sumry_l.grid(
            row=4, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_avg_l.grid(
            row=5, column=1, padx=10, sticky=tk.EW)
        self.ttmean_sumry_l.grid(
            row=5, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_sd_l.grid(
            row=6, column=1, padx=10, sticky=tk.EW)
        self.ttsd_sumry_l.grid(
            row=6, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_range_l.grid(
            row=7, column=1, padx=10, sticky=tk.EW)
        self.ttrange_sumry_l.grid(
            row=7, column=2, padx=(0, 16), sticky=tk.EW)
        self.tt_total_l.grid(
            row=8, column=1, padx=10, sticky=tk.EW)
        self.ttsum_sumry_l.grid(
            row=8, column=2, padx=(0, 16), sticky=tk.EW)
        sep2.grid(
            row=9, column=0, columnspan=5, padx=5, pady=(6, 6), sticky=tk.EW)
        self.time_prev_cnt_l.grid(
            row=10, column=1, columnspan=2, padx=3, sticky=tk.W)
        self.time_prev_sumry_l.grid(
            row=10, column=2, padx=(108, 0), sticky=tk.W)
        self.time_next_cnt_l.grid(
            row=11, column=1, padx=3, sticky=tk.W)
        self.num_tasks_all_l.grid(
            row=12, column=1, padx=3, sticky=tk.W)
        # Place cycles_remain value in same cell as its header, but shifted right.
        if MY_OS in 'lin, dar':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(123, 0), sticky=tk.W)
        elif MY_OS == 'win':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(110, 0), sticky=tk.W)
        #   Need pady for alignment with the row header.
        self.share.notice_l.grid(
            row=13, column=1, columnspan=2, rowspan=2, padx=5, pady=(1, 0),
            sticky=tk.NW)
        self.share.compliment_l.grid(
            row=14, column=1, columnspan=2, padx=5, sticky=tk.W)

        # Some control variables have default or initial start values,
        #   so make labels invisible in pre-settings dataframe by matching
        #   them to the background color.
        self.interval_t_l.config(foreground=self.data_bg)
        self.summary_t_l.config(foreground=self.data_bg)
        self.task_count_l.config(foreground=self.data_bg)
        self.task_count_sumry_l.config(foreground=self.data_bg)

    def settings(self) -> None:
        """
        Configures the Toplevel window that appears at startup.
        Confirms default parameters or sets new ones for count and
        summary interval times, counting limit, and log file option.
        """
        # Toplevel window basics
        self.settings_win.title('Set run settings')
        # Need to position over app window, which is at '+96+134'.
        self.settings_win.geometry('+136+174')
        self.settings_win.resizable(False, False)
        self.settings_win.config(relief='raised', bg=self.master_bg,
                                 highlightthickness=3,
                                 highlightcolor=self.share.highlight,
                                 highlightbackground=self.deemphasize)
        if MY_OS in 'lin, win':
            self.settings_win.attributes('-topmost', True)
        # In macOS, topmost places Combobox selections BEHIND the window,
        #    but focus_force() makes it visible; must be a tkinter bug?
        elif MY_OS == 'dar':
            self.settings_win.focus_force()

        settings_style = ttk.Style()
        settings_style.configure('Set.TLabel', background=self.master_bg,
                                 foreground=self.share.row_fg)

        # Need text in master window to prompt user to enter settings.
        #   The message text is covered by the settings_win, but is
        #   seen if user drags settings_win away.
        self.time_start_l.configure(text='Waiting for run settings...')

        # Inner functions for window and selection control and user FYI:

        # Need to disable default window Exit; only allow exit from active Confirm button.
        # https://stackoverflow.com/questions/22738412/a-suitable-do-nothing-lambda-expression-in-python
        #   to just disable 'X' exit, the protocol func can be lambda: None, or type(None)()
        # But if close on master X, or Escape, then get this error:
        #   _tkinter.TclError: can't invoke "grab" command: application has been destroyed
        def no_exit_on_x():
            msg = 'Please close window with "Count now" button.'
            messagebox.showinfo(title='Invalid exit', detail=msg,
                                parent=self.settings_win)

        self.settings_win.protocol('WM_DELETE_WINDOW', no_exit_on_x)

        def explain_intvl():
            explain = ('If the pull-down values you want do not appear, then'
                       ' either select a different interval time, a different'
                       ' summary time unit, or click "Use defaults".')
            messagebox.showinfo(parent=self.settings_win, detail=explain)

        def explain_zero_max():
            explain = ('Interval counting stops after entered number of'
                       ' cycles. Enter 0 (zero) for a status report.')
            messagebox.showinfo(parent=self.settings_win, detail=explain)

        def explain_update():
            explain = ('Allows automatic Project update to re-establish communication '
                       ' with the BOINC server when no tasks are running and '
                       ' all tasks are "Ready to report" in the BOINC Manager.')
            messagebox.showinfo(parent=self.settings_win, detail=explain)

        def update_intvl(*event):
            self.share.intvl_choice['values'] = sumry_unit[self.share.sumry_unit_choice.get()]
            return event

        def update_sumry_unit(*event):
            self.share.sumry_unit_choice['values'] = interval_t[self.share.intvl_choice.get()]
            return event

        # Settings widget construction, configurations, and grids.
        intvl_query_btn = ttk.Button(self.settings_win, text='?', width=0,
                                     command=explain_intvl)
        intvl_label = ttk.Label(self.settings_win, text='Count time interval',
                                style='Set.TLabel')
        interval_t = {'1h': ('day', 'hr'),
                      '30m': ('day', 'hr'),
                      '20m': ('hr', 'min'),
                      '15m': ('hr', 'min'),
                      '10m': ('hr', 'min'),
                      }
        self.share.intvl_choice.configure(
            state='readonly', width=4, height=5,
            textvariable=self.share.setting['interval_t'],
            values=tuple(interval_t.keys()))
        self.share.intvl_choice.bind("<<ComboboxSelected>>", update_sumry_unit)
        self.share.setting['interval_t'].set(self.share.intvl_choice.get())

        sumry_label1 = ttk.Label(
            self.settings_win, text='Summary interval: time value',
            style='Set.TLabel')
        self.sumry_value_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['sumry_t_value'],
            validatecommand=(
                self.sumry_value_entry.register(enter_only_digits), '%P', '%d'))

        sumry_label2 = ttk.Label(
            self.settings_win, text='time unit', style='Set.TLabel')
        sumry_unit = {'day': ('1h', '30m'),
                      'hr': ('30m', '20m', '15m', '10m'),
                      'min': ('20m', '15m', '10m')
                      }
        self.share.sumry_unit_choice.configure(
            state='readonly', width=4,
            textvariable=self.share.setting['sumry_t_unit'],
            values=tuple(sumry_unit.keys()))
        self.share.sumry_unit_choice.bind("<<ComboboxSelected>>", update_intvl)
        self.share.setting['sumry_t_unit'].set(self.share.sumry_unit_choice.get())

        # Specify number limit of counting cycles to run.
        cycles_query_btn = ttk.Button(self.settings_win, text='?', width=0,
                                      command=explain_zero_max)
        cycles_label = ttk.Label(self.settings_win, text='# Count cycles',
                                 style='Set.TLabel')
        self.cycles_max_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['cycles_max'],
            validatecommand=(
                self.cycles_max_entry.register(enter_only_digits), '%P', '%d'))

        # Need user options to log results to file and to use auto-updates.
        log_label = ttk.Label(self.settings_win, text='Log results to file',
                              style='Set.TLabel')
        self.log_choice.configure(variable=self.share.setting['do_log'],
                                  bg=self.master_bg, borderwidth=0)

        update_query_btn = ttk.Button(self.settings_win, text='?', width=0,
                                      command=explain_update)
        update_label = ttk.Label(self.settings_win, text='Use Project auto-update',
                                 style='Set.TLabel')
        self.update_choice.configure(variable=self.share.setting['proj_update'],
                                     bg=self.master_bg, borderwidth=0)

        default_button = ttk.Button(self.settings_win, text='Use defaults',
                                    command=self.share.defaultsettings)
        self.countnow_button.configure(text='Count now',
                                       command=self.check_and_start)

        # Grid all window widgets; generally sorted by row.
        intvl_label.grid(row=0, column=0, padx=5, pady=10, sticky=tk.E)
        self.share.intvl_choice.grid(row=0, column=1)
        default_button.grid(row=0, column=3, padx=10, pady=(10, 0), sticky=tk.E)
        sumry_label1.grid(row=1, column=0, padx=(10, 5), pady=10, sticky=tk.E)
        self.sumry_value_entry.grid(row=1, column=1)
        sumry_label2.grid(row=1, column=2, padx=5, pady=10, sticky=tk.E)
        self.share.sumry_unit_choice.grid(row=1, column=3, padx=5, pady=10, sticky=tk.W)
        cycles_label.grid(row=2, column=0, padx=5, pady=10, sticky=tk.E)
        self.cycles_max_entry.grid(row=2, column=1)
        log_label.grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.log_choice.grid(row=3, column=1, padx=0, pady=5, sticky=tk.W)
        update_label.grid(row=4, column=0, padx=5, pady=0, sticky=tk.E)
        self.update_choice.grid(row=4, column=1, padx=0, pady=0, sticky=tk.W)
        self.countnow_button.grid(
            row=5, column=3, padx=10, pady=(0, 10), sticky=tk.E)

        # Need OS-specific grids for proper padding and alignments:
        if MY_OS in 'lin, dar':
            intvl_query_btn.grid(row=0, column=0, padx=(50, 0), sticky=tk.W)
            cycles_query_btn.grid(row=2, column=0, padx=(75, 0), sticky=tk.W)
            update_query_btn.grid(row=4, column=0, padx=(15, 0), sticky=tk.W)
        if MY_OS == 'win':
            intvl_query_btn.grid(row=0, column=0, padx=(45, 0), sticky=tk.W)
            cycles_query_btn.grid(row=2, column=0, padx=(70, 0), sticky=tk.W)
            update_query_btn.grid(row=4, column=0, padx=(10, 0), sticky=tk.W)

    def check_and_set(self):
        """
        Confirm validity of summary and interval times, set all
        to valid control variable dictionary values, and set up logging
        of data, if optioned.
        Called from check_and_start().
        """

        # Note: self.share.setting['interval_t'] and self.sumry_t_value
        #    are set in settings() or in Modeler.default_settings().
        if not self.share.setting['interval_t'].get():
            self.share.defaultsettings()
        if self.share.setting['interval_t'].get() != '1h':
            interval_m = int(self.share.setting['interval_t'].get()[:-1])
        else:
            # Need to convert 1h to minutes for comparisons.
            interval_m = 60
        self.share.setting['interval_m'].set(interval_m)

        sumry_value = int(self.share.setting['sumry_t_value'].get())
        # When sumry_value == 0, it will be caught by interval_m comparison.
        if not sumry_value:
            self.share.setting['sumry_t_value'].set(1)
            sumry_value = 1

        # Need to set summary_t here as concat of the two sumry_t element strings,
        #   then convert to minutes to use in comparisons.
        summary_t = f"{sumry_value}{self.share.sumry_unit_choice.get()[:1]}"
        self.share.setting['summary_t'].set(summary_t)
        summary_m = TC.string_to_m(summary_t)
        if interval_m >= summary_m or summary_m % interval_m != 0:
            self.good_settings = False
            info = "Summary time must be greater than, and a multiple of, interval time"
            messagebox.showerror(title='Invalid entry', detail=info,
                                 parent=self.settings_win)
            # Need to offer user valid alternatives to bad times entered.
            if self.share.setting['sumry_t_unit'].get()  == 'min':
                self.share.setting['sumry_t_value'].set(2 * interval_m)
            elif self.share.setting['sumry_t_unit'].get() == 'hr':
                self.share.setting['sumry_t_value'].set(2 * sumry_value)
        elif interval_m < summary_m and summary_m % interval_m == 0:
            self.good_settings = True

        # Need to remove leading zeros, but allow a zero entry.
        #   Replace empty Entry with default values.
        cycles_max = self.cycles_max_entry.get()
        if cycles_max == '':
            self.share.setting['cycles_max'].set(1008)
        elif cycles_max != '0':
            self.share.setting['cycles_max'].set(int(cycles_max.lstrip('0')))
        # Allow zero entry for 1-off status report of task data.
        elif cycles_max == '0':
            self.share.setting['cycles_max'].set(0)

        # Need to set initial cycles_remain to cycles_max.
        self.share.data['cycles_remain'].set(self.share.setting['cycles_max'].get())

        if self.share.setting['do_log'].get():
            logging.basicConfig(filename=str(Logs.LOGFILE), level=logging.INFO,
                                filemode="a", format='%(message)s')

    def check_and_start(self):
        """
        Main gatekeeper for settings().
        Calls check_and_set(); if all is good then starts threads,
        calls emphasize_start_data(), and closes settings() window,
        which ends the startup sequence.
        Called from settings() countnow_button.
        """
        # Need to run final validation of settings in case user changed
        #   something since a prior "Confirm" check_and_set() call.
        self.check_and_set()
        if self.good_settings:
            # Run 1-off status report or begin interval counts...
            if self.share.setting['cycles_max'].get() == 0:
                self.share.data['cycles_remain'].set(0)
                self.share.setting['interval_t'].set('DISABLED')
                self.share.setting['summary_t'].set('DISABLED')
                self.share.note['notice_txt'].set('STATUS REPORT ONLY')
                self.emphasize_start_data()
                self.share.startdata()
                self.settings_win.destroy()
            # Begin main interval counting functions...
            else:
                self.start_threads()
                self.emphasize_start_data()
                self.share.startdata()
                self.settings_win.destroy()

    def start_threads(self) -> None:
        """
        Set up and start threads for intervals, notices, and logging.
        Called from check_and_start() in Viewer as part of
        startup sequence.
        """
        # There are no thread.join(), so use daemon for clean exits.
        intvl_thread = threading.Thread(
            target=self.share.intervaldata, daemon=True)
        notice_thread = threading.Thread(
            target=self.share.taskstatenotices, daemon=True)
        log_thread = threading.Thread(
            target=self.share.logit, daemon=True)
        intvl_thread.start()
        notice_thread.start()
        log_thread.start()

    def emphasize_start_data(self) -> None:
        """
        Config data labels in master window for starting data emphasis.
        Establish start time.
        Called from check_and_start() with 'Count now' button.
        """
        time_start = datetime.now().strftime(SHORT_STRFTIME)
        self.time_start_l.config(text=time_start)
        self.share.long_time_start = datetime.now().strftime(LONG_STRFTIME)

        # Need to keep sumry_b button disabled until after 1st summary interval.
        self.share.sumry_b.config(state=tk.DISABLED)

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)
        self.task_count_l.config(foreground=self.share.highlight)

        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_intvl_data(self) -> None:
        """
        Switches font emphasis from Summary data to Interval data.
        Called from 'Interval data' button.
        """

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)

        # Interval data, column1
        self.task_count_l.configure(foreground=self.share.highlight)
        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        # Summary data, column2, de-emphasize font color
        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_sumry_data(self) -> None:
        """
        Switches font emphasis from Interval data to Summary data.
        Called from 'Summary data' button.
        """
        self.interval_t_l.config(foreground=self.deemphasize)
        self.summary_t_l.config(foreground=self.emphasize)

        # Summary data, column2, emphasize font color
        self.task_count_sumry_l.configure(foreground=self.share.highlight)
        self.ttmean_sumry_l.configure(foreground=self.share.highlight)
        self.ttsd_sumry_l.configure(foreground=self.emphasize)
        self.ttrange_sumry_l.configure(text=self.share.data['tt_range'].get(),
                                       foreground=self.emphasize)
        self.ttsum_sumry_l.configure(foreground=self.emphasize)

        # Interval data, column1, de-emphasize font color
        self.task_count_l.configure(foreground=self.deemphasize)
        self.task_count_l.configure(foreground=self.deemphasize)
        self.tt_avg_l.configure(foreground=self.deemphasize)
        self.tt_sd_l.configure(foreground=self.deemphasize)
        self.tt_range_l.configure(foreground=self.deemphasize)
        self.tt_total_l.configure(foreground=self.deemphasize)

    def app_got_focus(self, *click_event):
        """
        Give menu bar headings normal color when app has focus.

        :param click_event: <FocusIn> mouse click.
        """
        self.menubar.entryconfig("File", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("View", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("Help", foreground='black', state=tk.NORMAL)
        self.view_button_style.configure('View.TButton', foreground='black',
                                         background='grey75')
        if self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.NORMAL)
        return click_event

    def app_lost_focus(self, *click_event):
        """
        Give menu bar headings grey-out color when app looses focus.

        :param click_event: <FocusOut> mouse click.
        """
        self.menubar.entryconfig("File", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("View", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("Help", foreground='grey', state=tk.DISABLED)
        self.view_button_style.configure('View.TButton', foreground='grey')
        if self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)
        return click_event


# ################## MVC Controller; is app mainloop ##################
class CountController(tk.Tk):
    """
    The Controller through which other MVC Count Classes can interact
    through the 'share' parameter.
    Based on https://stackoverflow.com/questions/32864610/
    """

    def __init__(self):
        super().__init__()

        # Use geometry so that master window will be underneath settings()
        #   Toplevel window at startup.
        #   Not setting the geometry here places app window below settings_win
        # These x, y coordinates match default window placement on Ubuntu desktop.
        # self.geometry('+96+134')

        # Need window sizes to make room for multi-line notices,
        #    but not get minimized enough to exclude notices row.
        # Need OS-specific master window sizes b/c of different default font widths.
        if MY_OS == 'lin':
            self.minsize(580, 370)
            self.maxsize(780, 400)
        elif MY_OS == 'win':
            self.minsize(532, 380)
            self.maxsize(720, 400)
        elif MY_OS == 'dar':
            self.minsize(600, 390)
            self.maxsize(780, 425)

        self.winfo_toplevel()
        CountViewer(share=self)
        # NOTE: Instead of self.winfo_toplevel(), can use tk.Frame().grid().
        # It creates a tkinter.Frame object as the first child widget, but
        #   it makes no difference to function or layout.
        # Using winfo_toplevel() first creates the __main__.CountViewer child,
        #   without any enclosing Frame.
        # In neither case is it necessary to name the child as a master
        #   parameter to call CountViewer() b/c self.master is implicit.

    def defaultsettings(self) -> None:
        """
        Starting settings of: report interval, summary interval,
        counting limit, and log file option.
        """
        CountModeler(share=self).default_settings()

    def startdata(self) -> None:
        """
        Is called from Viewer.startup().
        """
        CountModeler(share=self).start_data()

    def intervaldata(self) -> None:
        """
        Is called from Viewer.start_threads(), which starts the Modeler
        interval thread.
        """
        CountModeler(share=self).interval_data()

    def taskstatenotices(self) -> None:
        """
        Is called from Viewer.start_threads(), which starts the Modeler
        task state notification thread.
        """
        CountModeler(share=self).notice_it()

    def logit(self, called_from=None) -> None:
        """Send data to log file.
        Is called from Viewer.start_threads(), which starts the Modeler
        log_it() thread.

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """
        CountModeler(share=self).log_it(called_from)

    def info(self) -> None:
        """Is called from Help menu bar
        """
        CountFyi(share=self).information()

    # pylint: disable=unused-argument
    def compliment(self, *keybind):
        """Is called from Help menu bar. A silly diversion.

        :param keybind: Empty parameter to pass implicit keybinding event.
        """
        CountFyi(share=self).compliment_me()
        return keybind

    def about(self):
        """Is called from Viewer Help menu bar.
        """
        CountFyi(share=self).about()


if __name__ == "__main__":
    parse_args()
    try:
        app = CountController()
        app.title(f'Count BOINC tasks on {gethostname()}')
        # Need valid_path_to() when making onefile with PyInstaller.
        img = tk.PhotoImage(file=valid_path_to('images/count_icon_512.png'))
        app.iconphoto(True, img)
        print(f'{valid_path_to(str(Path(__file__))).name} now running...')
        app.mainloop()
    except KeyboardInterrupt:
        exit_msg = (f'\n{datetime.now().strftime(LONG_STRFTIME)};'
                    f' *** keyboard interrupt by user ***\n')
        print(exit_msg)
        logging.info(msg=exit_msg)
