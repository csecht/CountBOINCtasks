#!/usr/bin/env python3

"""
GcountTasks (gcount-tasks) provides task counts and time statistics at
timed intervals for tasks recently reported to BOINC servers. It can be
run on Windows, Linux, or MacOS. It is the tkinter GUI version of
count-tasks. Its MVC architecture is modified from examples provided
at https://stackoverflow.com/questions/32864610/ and links therein.
Requires Python 3.6 or later and tkinter (tk/tcl) 8.6 or later.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see https://www.gnu.org/licenses/.
"""
# ^^ Text for --about invocation argument via __doc__.
# Also used in Fyi.about(); __program_name__ used throughout.
# __program_name__ may be context-specific, see definition below.
__author__ = 'cecht, BOINC ID: 990821'
__copyright__ = 'Copyright (C) 2021 C.S. Echt'
__credits__ = 'Inspired by rickslab-gpu-utils'
__license__ = 'GNU General Public License'
__version__ = '0.9.2'
__dev_environment__ = "Python 3.8 - 3.9"
__project_url__ = 'https://github.com/csecht/CountBOINCtasks'
__maintainer__ = 'cecht'
__status__ = 'Development Status :: 2 - Beta'

import argparse
import logging
import sys
import threading
from datetime import datetime
from pathlib import Path
from random import choice
from re import search, findall, MULTILINE
from socket import gethostname
from time import sleep, time

from COUNTmodules import boinc_commands, times, files, binds, utils, instances

try:
    import tkinter as tk
    from tkinter import messagebox, ttk
    from tkinter.scrolledtext import ScrolledText
except (ImportError, ModuleNotFoundError) as error:
    print(f'This program requires tkinter, which is included with \n'
          'Python 3.7+ distributions.\n'
          'Install the most recent version or re-install Python and include Tk/Tcl.\n'
          '\nOn Linux, you may also need: $ sudo apt-get install python3-tk\n'
          f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

if sys.version_info < (3, 6):
    print(f'Sorry, but this program requires Python 3.6 or later.\n'
          'Current Python version: '
          f'{sys.version_info.major}.{sys.version_info.minor}\n'
          'Python downloads are available from https://docs.python.org/')
    sys.exit(0)

BC = boinc_commands
T = times
Files = files
Binds = binds
Utils = utils
Tooltip = utils.Tooltip
Instances = instances

__program_name__ = Instances.program_name()

MY_OS = sys.platform[:3]
LONG_STRFTIME = '%Y-%b-%d %H:%M:%S'
SHORT_STRFTIME = '%Y %b %d %H:%M'
SHORTER_STRFTIME = '%b %d %H:%M'
DAY_STRFTIME = '%A %H:%M'
NOTICE_INTERVAL = 15  # <- time.sleep() seconds


# ################ Useful functions, not part of MVC ###################
def parse_args() -> None:
    """Allow handling of common command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about',
                        help='Provides description, version, GNU license',
                        action='store_true',
                        default=False)
    args = parser.parse_args()
    if args.about:
        print(__doc__)
        print(f'{"Author:".ljust(13)}', __author__)
        print(f'{"Credits:".ljust(13)}', __credits__)
        print(f'{"License:".ljust(13)}', __license__)
        print(f'{"Copyright:".ljust(13)}', __copyright__)
        print(f'{"Program:".ljust(13)}', __program_name__)
        print(f'{"Version:".ljust(13)}', __version__)
        print(f'{"Dev Env:".ljust(13)}', __dev_environment__)
        print(f'{"URL:".ljust(13)}', __project_url__)
        print(f'{"Maintainer:".ljust(13)}', __maintainer__)
        print(f'{"Status:".ljust(13)}', __status__)
        print()
        sys.exit(0)


def check_boinc() -> None:
    """
    Check whether BOINC client is running. Called before proceeding to
    implement settings and begin counting and at each notice interval.
    """
    # Note: Any BC boinccmd will return this string (in a list)
    #   if boinc-client is not running. BC.get_version() is used b/c it
    #   is short. A similar function is BC.check_boinc(), but only for
    #   Terminal output; with GUI, need to use messagebox and destroy().
    if "can't connect to local host" in BC.get_version():
        okay = messagebox.askokcancel(
            title='BOINC ERROR',
            detail='BOINC commands cannot be executed.\n'
                   'Is the BOINC client running?\nExiting now...')
        if okay:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)
        else:
            app.update_idletasks()
            app.after(100)
            app.destroy()
            sys.exit(0)


def quit_gui(keybind=None) -> None:
    """
    Error-free and informative exit from the program.
    Called from multiple widgets or keybindings.

    :param keybind: Implicit event passed from bind().
    """

    # Write exit message to an existing log file, even if the setting
    #   "log to file" was not selected, BUT not for additional instances.
    time_now = datetime.now().strftime(LONG_STRFTIME)
    quit_txt = f'\n{time_now}; *** User quit the program. ***\n'
    print(quit_txt)
    if Path.exists(Logs.LOGFILE):
        Files.append_txt(Logs.LOGFILE, quit_txt, False)
    # pylint: disable=broad-except
    try:
        app.update_idletasks()
        app.after(200)
        app.destroy()
    except Exception as unk:
        print(f'An error occurred: {unk}')
        sys.exit('program exit with unexpected condition')
    return keybind


class Logs:
    """
    Methods to analyze and view task data logged to file.
    File paths are defined as Class attribute constants.
    """

    # Need to write log files to current working directory unless program
    #   is run from a PyInstaller frozen executable, then write to home
    #   directory. In either case, the constants will be absolute paths.
    LOGFILE = Path(Path.cwd(),
                   f'{__program_name__}_log.txt').resolve()
    ANALYSISFILE = Path(Path.cwd(),
                        f'{__program_name__}_analysis.txt').resolve()

    if getattr(sys, 'frozen', False):
        LOGFILE = Path(Path.home(),
                       f'{__program_name__}_log.txt').resolve()
        ANALYSISFILE = Path(Path.home(),
                            f'{__program_name__}_analysis.txt').resolve()

    @classmethod
    def analyze_logfile(cls) -> tuple:
        """
        Reads log file and analyses Summary and Interval counts.
        Called from cls.show_analysis().

        :return: text strings to display in show_analysis() Toplevel.
        """
        sumry_dates = []
        sumry_intvl_vals = []
        num_sumry_intvl_vals = 0
        sumry_counts = []
        sumry_cnt_avg = 0.0
        sumry_cnt_range = ''

        intvl_dates = []
        intvl_vals = []
        num_intvl_vals = 0
        intvl_cnt_avg = 0.0
        intvl_cnt_range = ''
        logged_intvl_report = ''

        recent_dates = []
        recent_intvl_vals = []
        num_recent_intvl_vals = 0
        recent_counts = []
        num_recent_tasks = 0
        recent_t_wtmean = ''
        recent_intervals = True

        summary_text = ''
        recent_interval_text = ''

        try:
            logtext = Path(cls.LOGFILE).read_text()
        except FileNotFoundError:
            info = (f'On {gethostname()}, missing necessary file:\n{cls.LOGFILE}\n'
                    'Was the settings "log results" option used?\n'
                    'Was the log file deleted, moved or renamed?')
            messagebox.showerror(title='FILE NOT FOUND', detail=info)
            return summary_text, recent_interval_text  # <- Empty strings.

        # Regex is based on this structure used in CountModeler.log_it():
        # 2021-Dec-21 06:27:18; Tasks reported in the past 1h: 18
        #                       Task Time: avg 00:21:35,
        #                                  range [00:21:20 -- 00:21:54],
        #                                  stdev 00:00:11, total 06:28:45
        #                       Total tasks in queue: 53
        #                       984 counts remain.
        # 2021-Dec-21 06:27:18; >>> SUMMARY: Count for the past 1d: 402
        #                       Task Time: mean 0:21:28,
        #                                  range [00:16:03 -- 00:22:33],
        #                                  stdev 00:00:42, total 5d 23:54:05
        found_sumrys = findall(
            r'^(.*); >>> SUMMARY: .+ (\d+[mhd]): (\d+$)', logtext, MULTILINE)
        found_intvls = findall(
            r'^(.*); Tasks reported .+ (\d+[mhd]): (\d+$)', logtext, MULTILINE)
        found_intvl_avgt = findall(
            r'Tasks reported .+\n.+ avg (\d{2}:\d{2}:\d{2})', logtext, MULTILINE)
        found_intvl_t_range = findall(
            r'Tasks reported .+\n.+\n.+ range \[(\d{2}:\d{2}:\d{2}) -- (\d{2}:\d{2}:\d{2})]',
            logtext, MULTILINE)

        if found_sumrys:
            sumry_dates, sumry_intvl_vals, sumry_cnts = zip(*found_sumrys)
            num_sumry_intvl_vals = len(set(sumry_intvl_vals))
            sumry_counts = list(map(int, sumry_cnts))
            sumry_cnt_avg = round(sum(sumry_counts) / len(sumry_counts), 1)
            sumry_cnt_range = f'[{min(sumry_counts)} -- {max(sumry_counts)}]'
        if found_intvls:
            intvl_dates, intvl_vals, intvl_cnts = zip(*found_intvls)
            num_intvl_vals = len(set(intvl_vals))
            intvl_counts = list(map(int, intvl_cnts))
            num_tasks = sum(intvl_counts)
            intvl_cnt_avg = round(sum(intvl_counts) / len(intvl_counts), 1)
            intvl_cnt_range = f'[{min(intvl_counts)} -- {max(intvl_counts)}]'
            intvl_t_wtmean = T.logtimes_stat(found_intvl_avgt, 'wtmean', intvl_counts)
            intvl_t_stdev = T.logtimes_stat(found_intvl_avgt, 'stdev', intvl_counts)
            # https://www.geeksforgeeks.org/python-convert-list-of-tuples-into-list/
            # Note: using an empty tuple as a sum() starting value flattens the
            #    list of string tuples into one tuple of strings.
            intvl_t_range = T.logtimes_stat(sum(found_intvl_t_range, ()), 'range')

            # Text & data used in most count reporting conditions below:
            logged_intvl_report = (
                'Analysis of reported tasks logged from\n'
                f'{intvl_dates[0]} to {intvl_dates[-1]}\n'
                f'   {cls.uptime(logtext).ljust(11)} hours counting tasks\n'
                f'   {str(num_tasks).ljust(11)} tasks in {len(intvl_counts)} count intervals\n'
                f'   {intvl_t_wtmean.ljust(11)} weighted mean task time\n'
                f'   {intvl_t_stdev.ljust(11)} std deviation task time\n'
                f'   {intvl_t_range} range of task times\n\n')

        # Need 'recent' vars when there are interval counts following last summary.
        #   So find the list index for first interval count after the last summary.
        #   If there are no intervals after last summary, then flag and move on.
        if found_sumrys and found_intvls:
            # When there are no intervals after last summary,
            #   the last intvl date is last summary date.
            if intvl_dates[-1] == sumry_dates[-1]:
                recent_intervals = False
            else:
                index = [
                    i for i, date in enumerate(intvl_dates) if date == sumry_dates[-1]]
                index_recent = index[0] + 1  # <- The interval after the last summary.
                recent_dates, recent_intvl_vals, recent_cnts = zip(*found_intvls[index_recent:])
                num_recent_intvl_vals = len(set(recent_intvl_vals))
                recent_counts = list(map(int, recent_cnts))
                num_recent_tasks = sum(recent_counts)
                recent_t_wtmean = T.logtimes_stat(
                    found_intvl_avgt[index_recent:], 'wtmean', recent_counts)

        # Need to tailor report texts for various counting conditions.
        if not found_sumrys and not found_intvls:
            recent_interval_text = (
                f'\nAs of {datetime.now().strftime(SHORT_STRFTIME)}\n'
                '   There are not enough data to analyze.\n'
                '   Need at least one summary or one\n'
                '   interval count in the log file.\n')
        if not found_sumrys and found_intvls:
            summary_text = '\nNo summary counts are logged yet.\n\n'
            if num_intvl_vals == 1:
                recent_interval_text = (
                    f'{logged_intvl_report}'
                    f'   {str(intvl_cnt_avg).ljust(11)} tasks per {intvl_vals[0]} count interval\n'
                    f'   {intvl_cnt_range} range of task counts\n'
                )
            else:
                recent_interval_text = (
                    f'{logged_intvl_report}'
                    f'   {str(intvl_cnt_avg).ljust(11)} tasks per count interval\n'
                    f'There are {num_intvl_vals} different interval times\n'
                    f'logged, {set(intvl_vals)},\n'
                    'so interpret results with caution.\n\n'
                )
        if found_sumrys:
            if num_sumry_intvl_vals == 1:
                summary_text = (
                    f'{logged_intvl_report}'
                    'Summary data logged from:\n'
                    f'{sumry_dates[0]} to {sumry_dates[-1]}\n'
                    f'   {str(len(sumry_counts)).ljust(7)} summaries logged\n'
                    f'   {str(sumry_cnt_avg).ljust(7)}'
                    f' tasks per {sumry_intvl_vals[0]} summary interval\n'
                    f'   {sumry_cnt_range} range of task counts\n\n'
                )
            else:
                summary_text = (
                    f'{logged_intvl_report}'
                    'Summary data logged from:\n'
                    f'{sumry_dates[0]} to {sumry_dates[-1]}\n\n'
                    f'   {str(len(sumry_counts)).ljust(7)} summaries logged\n'
                    f'   {str(sumry_cnt_avg).ljust(7)} tasks per summary\n'
                    f'   {sumry_cnt_range} range of task counts\n'
                    f'There are {num_sumry_intvl_vals} different Summary interval times,\n'
                    f'   {set(sumry_intvl_vals)},\n'
                    '   so interpret results with caution.\n\n'
                )

        # Summary text has been defined, so now do recent interval text.
        if found_sumrys and found_intvls:
            if recent_intervals:
                if num_recent_intvl_vals == 1:
                    recent_interval_text = (
                        'Since last Summary, additional counts from:\n'
                        f'{recent_dates[0]} to {recent_dates[-1]}\n'
                        f'   {str(num_recent_tasks).ljust(11)} '
                        f'tasks in {len(recent_counts)} intervals of {recent_intvl_vals[0]}\n'
                        f'   {recent_t_wtmean.ljust(11)} weighted mean task time\n'
                    )
                else:
                    recent_interval_text = (
                        'Since last Summary, additional counts from:\n'
                        f'{recent_dates[0]} to {recent_dates[-1]}\n\n'
                        f'   {str(num_recent_tasks).ljust(11)} '
                        f'tasks in {len(recent_counts)} intervals of {recent_intvl_vals[0]}\n'
                        f'   {recent_t_wtmean.ljust(11)} weighted mean task time\n'
                        f'There are {num_recent_intvl_vals} different interval times,\n'
                        f'   {set(recent_intvl_vals)},\n'
                        '   so interpret results with caution.\n'
                    )
            else:
                recent_interval_text = 'No counts logged after last Summary.\n'

        return summary_text, recent_interval_text

    @classmethod
    def show_analysis(cls) -> None:
        """
        Generate a Toplevel window to display cumulative logged task
        data that have been analyzed by cls.analyze_logfile().
        Button appends displayed results to an analysis log file.
        Called from a Logs.view() button or a master keybinding.
        """

        # NOTE: When the log file is not found by analyze_logfile(), the
        #   returned texts will be empty, so no need to continue.
        summary_text, recent_interval_text = cls.analyze_logfile()
        if not summary_text and not recent_interval_text:
            return

        # Have bg match self.master_bg of the app main window.
        analysiswin = tk.Toplevel(bg='SteelBlue4')
        analysiswin.title('Analysis of logged data')
        # Need to position window over the window from which it is called.
        analysiswin.geometry(Utils.get_toplevel('position', app))
        analysiswin.minsize(520, 320)

        insert_txt = summary_text + recent_interval_text
        max_line = len(max([line for line in insert_txt.splitlines()], key=len))
        # Separator dash from https://coolsymbol.com/line-symbols.html.
        # print(ord("─")) -> 9472
        #   unicodedata.name(chr(9472)) -> 'BOX DRAWINGS LIGHT HORIZONTAL'.
        # print(ord("═")) -> 9552
        #   unicodedata.name(chr(9552)) -> 'BOX DRAWINGS DOUBLE HORIZONTAL'.
        sep = f'\n{"─" * max_line}\n'
        insert_txt = insert_txt + sep

        num_lines = insert_txt.count('\n')
        analysistxt = tk.Text(analysiswin, font='TkFixedFont',
                              width=max_line, height=num_lines,
                              bg='grey100', fg='grey5',
                              relief='groove', bd=4, padx=15, pady=10)
        analysistxt.insert(1.0, insert_txt)
        analysistxt.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)
        Binds.click('right', analysistxt, app)
        Binds.keyboard('close', analysiswin, app)
        Binds.keyboard('append', analysiswin, app, cls.ANALYSISFILE, insert_txt)
        analysiswin.bind('<Shift-Control-A>',
                         lambda _: cls.view(cls.ANALYSISFILE))

        # Need to allow user to save annotated analysis text.
        def new_text():
            new_txt = analysistxt.get(1.0, tk.END)
            Files.append_txt(cls.ANALYSISFILE, new_txt, True, analysiswin)

        ttk.Button(analysiswin, text='Save analysis', command=new_text,
                   takefocus=False).pack(padx=4)

    @classmethod
    def uptime(cls, logtext: str) -> str:
        """
        Sum of hours spent counting tasks. Does not include time
        segments with no reported tasks counts.

        :param logtext: the full text content string from a log file.
        :return: total hours elapsed while logging data, as string.
                 Returns 'cannot determine' if negative time calculated,
                 as indication of corrupted data or user edit.
        """
        start2intvls = []
        intvl_duration = []

        # *_dt vars are datetime.timedelta objects, so initialize with
        #    formatted Epoch origin time.
        start_dt = T.string_to_dt('1970-Jan-01 00:00:00', LONG_STRFTIME)

        # Need to calc uptime hours for all start-to-finish segments that
        #   have interval task counts.
        # Datetimes that begin each log entry are formatted as,
        #    '2021-Dec-05 16:33:49; ...'; LONG_STRFTIME is the time
        #     format used in the log file.
        for line in logtext.split('\n'):
            if 'most recent BOINC report' in line:
                starttime_match = search(
                    r'^(.+); .+ most recent BOINC report', line).group(1)
                start_dt = T.string_to_dt(starttime_match, LONG_STRFTIME)
            if 'Tasks reported' in line:
                intvltime_match = search(
                    r'^(.+); Tasks reported', line).group(1)
                interval_dt = T.string_to_dt(intvltime_match, LONG_STRFTIME)
                start2intvls.append(T.duration('hours', start_dt, interval_dt))
                if any(hr < 0 for hr in start2intvls):
                    return 'cannot determine'

        # To calculate total interval hours, need a list of local maximums
        #    from all logged start-to-finish segments of count intervals.
        # There is no need for condition of no logged interval hours b/c
        #    this is only called from analyze_logfile() when there are hrs.
        for i, _hr in enumerate(start2intvls):
            if len(start2intvls) == 1:
                intvl_duration.append(_hr)
            elif i == 0:
                pass
            elif i < len(start2intvls) - 1:
                after = start2intvls[i + 1]
                if after < _hr:
                    intvl_duration.append(_hr)
            elif i == len(start2intvls) - 1:
                intvl_duration.append(_hr)

        return str(round(sum(intvl_duration), 1))

    @classmethod
    def view(cls, filepath: Path) -> None:
        """
        Create a separate window to view a text file as scrolled text.
        Called from View menu bar or keybinding.

        :param filepath: A Path object of the file to view.
        """
        # Need to set messages and sizes specific to OS and files.
        text_height = 30
        minsize_w = 0
        minsize_h = 0
        fnf_query = ''

        if filepath == cls.LOGFILE:
            minsize_h = 220
            # Need to set OS-specific width for font used in filetext.
            #   These widths are based on TkFixedFont:
            if MY_OS == 'lin':
                minsize_w = 800
            if MY_OS == 'win':
                minsize_w = 840
            if MY_OS == 'dar':
                minsize_w = 675
            fnf_query = 'Was the log option ticked in settings?'

        if filepath == cls.ANALYSISFILE:
            minsize_w = 510
            minsize_h = 150
            if MY_OS == 'win':
                minsize_w = 550
            fnf_query = 'Have any analysis results been saved yet?'

        if not Path.exists(filepath):
            info = (f'On {gethostname()}, file is missing:\n{filepath}\n'
                    f'{fnf_query}\n'
                    'Or, was file deleted, moved or renamed?')
            messagebox.showerror(title='FILE NOT FOUND', detail=info)
            return

        # Have bg match self.master_bg of the app main window.
        filewin = tk.Toplevel(bg='SteelBlue4',
                              highlightthickness=5,
                              highlightcolor='grey95',
                              highlightbackground='grey75'
                              )
        # Need title to include the file and local machine names.
        filewin.title(f'{filepath.parts[-1]} on {gethostname()}')
        filewin.minsize(minsize_w, minsize_h)
        filewin.focus_set()

        insert_txt = Path(filepath).read_text()
        max_line = len(max([line for line in insert_txt.splitlines()], key=len))

        # Use a "dark" background/foreground theme for file text.
        filetext = ScrolledText(filewin, font='TkFixedFont',
                                width=max_line, height=text_height,
                                bg='grey20', fg='grey80',
                                insertbackground='grey80',
                                relief='groove', bd=4, padx=12
                                )
        filetext.insert(tk.INSERT, insert_txt)
        filetext.see(tk.END)
        filetext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        Binds.click('right', filewin, app)
        Binds.keyboard('close', filewin, app)
        Binds.keyboard('saveas', filewin, None, filepath)

        ttk.Button(
            filewin, text='Update',
            command=lambda: Files.update(filetext, filepath, filewin),
            takefocus=False).pack(padx=4)
        ttk.Button(
            filewin, text='Backup',
            command=lambda: Files.save_as(filepath, filewin),
            takefocus=False).pack(padx=4)
        ttk.Button(
            filewin, text='File path',
            command=app.filepaths,
            takefocus=False).pack(padx=4)

        if filepath == cls.LOGFILE:
            ttk.Button(filewin, text='Analysis',
                       command=cls.show_analysis,
                       takefocus=False).pack(padx=4)
            filewin.bind('<Shift-Control-L>', lambda _: cls.show_analysis())
            filewin.bind('<Shift-Control-A>',
                         lambda _: cls.view(cls.ANALYSISFILE))

        if filepath == cls.ANALYSISFILE:
            filewin.geometry(Utils.get_toplevel('position', app))
            ttk.Button(
                filewin, text='Erase',
                command=lambda: Files.erase(cls.ANALYSISFILE, filetext, filewin),
                takefocus=False).pack(padx=4)
            filewin.bind('<Shift-Control-L>', lambda _: cls.show_analysis())


# ############ A MVC add-on; independent of data functions #############
class CountFyi:
    """
    Methods to provide user with information and help.
    """

    def __init__(self, share):
        self.share = share

    @staticmethod
    def about() -> None:
        """
        Toplevel display of program metadata.
        Called from Viewer.master_widgets() Help menu bar.

        :return: None
        """
        # Have highlightcolor match self.master_bg of the app main window.
        aboutwin = tk.Toplevel(highlightthickness=5,
                               highlightcolor='SteelBlue4',
                               highlightbackground='grey75')
        aboutwin.geometry(Utils.position_wrt_window(app, 30, 20))
        aboutwin.resizable(False, False)
        aboutwin.title(f'About {__program_name__}')
        aboutwin.focus_set()
        insert_txt = (f'{__doc__}\n'
                      f'{"Author:".ljust(13)}{__author__}\n'
                      f'{"Credits:".ljust(13)}{__credits__}\n'
                      f'{"License:".ljust(13)}{__license__}\n'
                      f'{"Program:".ljust(13)}{__program_name__}\n'
                      f'{"Version:".ljust(13)}{__version__}\n'
                      f'{"Dev. Env.:".ljust(13)}{__dev_environment__}\n'
                      f'{"URL:".ljust(13)}{__project_url__}\n'
                      f'{"Maintainer:".ljust(13)}{__maintainer__}\n'
                      f'{"Status:".ljust(13)}{__status__}\n'
                      )
        max_line = len(max([line for line in insert_txt.splitlines()], key=len))
        abouttxt = tk.Text(aboutwin, font='TkFixedFont',
                           width=max_line, height=insert_txt.count('\n') + 2,
                           relief='groove', borderwidth=5, padx=25)
        abouttxt.insert(1.0, insert_txt)
        abouttxt.pack()
        # Need to not have cursor appear in Text, but allow
        #   rt-click edit commands to work if needed.
        abouttxt.configure(state=tk.DISABLED)
        Binds.keyboard('close', aboutwin, app)
        Binds.click('right', abouttxt, app)

    def compliment_me(self) -> None:
        """A silly diversion; called from Help menu bar and keybinding.
        """
        compliments = [
            "Hey there good lookin'!", 'I wish we had met sooner.',
            'You are the smartest person I know.', 'I like your hair.',
            'You have such a nice smile.', 'Smart move!',
            'Blue is your color.', 'Good choice!',
            "That's very kind of you.", "Stop! You're making me blush.",
            'I just love what you did.', 'How witty you are!', 'Awesome!',
            'Your tastes are impeccable.', "You're incredible!",
            'You are so talented!', "I wish I'd thought of that.",
            'This is fun!', 'Get back to work.', 'Nice!', 'You saved me.',
            'You are an inspiration to us all.', "That's so funny!",
            'Show me how you do that.', "I've always looked up to you.",
            'You sound great!', 'You smell nice.', 'Great job!',
            'You are a role model.', 'I wish more people were like you.',
            'We appreciate what you did.', 'I hear people look up to you.',
            'You are a really good dancer.', 'What makes you so successful?',
            'When you speak, people listen.', 'You are a superb person.',
            'You rock!', 'You nailed it!', 'That was really well done.',
            'You are amazing!', 'We need more folks like you around here.',
            'Excuse me, are you a model?', 'What a lovely laugh you have.',
            "I'm jealous of your ability.", "You're the stuff of legends.",
            'This would not be possible without you.', 'Way to go! Yay!',
            'Did you make that? I love it!', 'You are the best!',
            'I like what you did.', 'Whoa. Have you been working out?',
            "We can't thank you enough.", 'No, really, you have done enough.',
            "That's a good look for you.", 'I could not have done it better.',
            'Congratulations!', 'Try not. Do or do not. There is no try.',
            "Well, THAT's impressive.", 'I hear that you are the one.',
            'You excel at everything.', 'Your voice is very soothing.',
            'Is it true what people say?', 'The word is, you got it!',
            'The Nobel Committee has been trying to reach you.',
            'The Academy is asking for your CV.', 'You look great!',
            'The President seeks your council.', 'Thank you so much!',
            'The Prime Minister seeks your council.', 'Crunchers rule!',
            'Crunchers are the best sort of people.',
            "I can't think of anything to say. Sorry.",
        ]
        praise = choice(compliments)
        self.share.compliment_l.config(text=praise)
        self.share.notice_l.grid_remove()
        # Need to re-grid initial master_widgets() grids b/c its grid may
        #   have been removed by a notice_l call. Original grid coordinates
        #   are set in master_widgets().
        self.share.compliment_l.grid()

        def refresh():
            self.share.compliment_l.grid_remove()
            # Re-grid notice to return to current Notice text.
            self.share.notice_l.grid()
            app.update_idletasks()

        self.share.compliment_l.after(3333, refresh)

    @staticmethod
    def file_paths() -> None:
        """
        Toplevel display of full paths for program-generated files.
        Called from Viewer.master_widgets() Help menu bar.

        :return: None
        """
        # Have highlightcolor match self.master_bg of the app main window.
        pathswin = tk.Toplevel(highlightthickness=5,
                               highlightcolor='SteelBlue4',
                               highlightbackground='grey75')
        # Need to position window over the window from which it is called.
        pathswin.geometry(Utils.get_toplevel('position', app))
        pathswin.resizable(False, False)
        pathswin.title(f'Program-generated files on {gethostname()}')
        pathswin.focus_set()
        insert_txt = (
            f'Full file paths created by {__program_name__}\n\n'
            f'Data log (file exists: {Path.exists(Logs.LOGFILE)})\n'
            f'   ...do not alter this file while program is running\n'
            f'   {Logs.LOGFILE}\n\n'
            f'Saved log analyses (file exists: {Path.exists(Logs.ANALYSISFILE)})\n'
            f'   {Logs.ANALYSISFILE}\n'
        )
        if MY_OS in 'lin, dar':
            insert_txt = (f'{insert_txt}\nLockfile (hidden):\n'
                          f'   {lockfile_path}\n')

        max_line = len(max([line for line in insert_txt.splitlines()], key=len))
        pathstxt = tk.Text(pathswin, font='TkFixedFont',
                           height=insert_txt.count('\n') + 1,
                           width=max_line,
                           relief='groove', borderwidth=5,
                           padx=10, pady=10)
        pathstxt.insert(1.0, insert_txt)
        # Need to center the header lines.
        pathstxt.tag_configure("header", justify='center')
        pathstxt.tag_add("header", "1.0", "3.0")
        pathstxt.pack()
        Binds.keyboard('close', pathswin, app)
        Binds.click('right', pathstxt, app)

    @staticmethod
    def information() -> None:
        """
        Toplevel display of basic information for usage and actions.
        Called from Viewer.master_widgets() Help menu bar.

        :return: None
        """
        # Have highlightcolor match self.master_bg of the app main window.
        infowin = tk.Toplevel(highlightthickness=5,
                              highlightcolor='SteelBlue4',
                              highlightbackground='grey75')
        infowin.geometry(Utils.position_wrt_window(app, 30, 20))
        infowin.resizable(False, False)
        infowin.title('Usage information')
        infowin.focus_set()
        insert_txt = ("""
        - Counting begins once "Count now" is clicked in settings window.\n
        - Interval and Summary data buttons switch visual emphasis;
                ...those buttons activate once their data post.
                The Summary task time "avg" is the weighted mean.\n
        - At start, '# tasks reported' and 'Interval time' are from
                the most recent hourly BOINC report.\n
        - Number of tasks in queue and Notices update every"""
                      f' {NOTICE_INTERVAL} seconds.\n'
                      """
        - Displayed countdown clock time is approximate.\n
        - Counts and Notices histories are in the log file.\n
        - While not recommended, in Linux and macOS, multiple program
                instances can be run from separate directories.
                Windows will not run multiple instances.\n
        - When analysis of logged hours is "cannot determine"...
                Quick fix: backup then delete log file, restart program.\n
        - Right-click actions only affect on-screen text, not file content,
                except edits in the log analysis window, such as notations,
                can be saved to the log analysis file.\n
        - Most common key commands work as expected.
        """)

        # OS-specific Text widths were empirically determined for TkTextFont.
        os_width = 0
        if MY_OS in 'lin, win':
            os_width = 64
        elif MY_OS == 'dar':
            os_width = 56
        infotxt = tk.Text(infowin, font='TkTextFont',
                          width=os_width, height=insert_txt.count('\n') + 2,
                          relief='groove', padx=15)
        infotxt.insert(1.0, insert_txt)
        infotxt.pack()
        # Need to not have cursor appear in Text, but allow
        #   rt-click edit commands to work if needed.
        infotxt.configure(state=tk.DISABLED)
        Binds.keyboard('close', infowin, app)
        Binds.click('right', infotxt, app)


# ############################ MVC Classes #############################
# MVC Modeler: The engine that gets BOINC data and runs count intervals.
class CountModeler:
    """
    Counting, statistical analysis, and formatting of BOINC task data.
    """
    # Need to have these vars as Class attributes, so they will not be
    # reset when interval_data() is called. ttimes_smry would be okay
    # in __init__, but is here for clarity.
    ttimes_used = set()
    ttimes_smry = set()

    def __init__(self, share):
        self.share = share
        self.thread_lock = threading.Lock()
        self.task_count_start = 0
        self.task_count_new = 0

    def default_settings(self) -> None:
        """
        Set or reset default run parameters in the setting dictionary.
        """
        self.share.setting['interval_t'].set('1h')
        self.share.setting['interval_m'].set(60)
        self.share.intvl_choice['values'] = ('1h', '30m', '20m', '15m', '10m')
        self.share.intvl_choice.select_clear()
        self.share.setting['summary_t'].set('1d')
        self.share.setting['sumry_t_value'].set(1)
        self.share.setting['sumry_t_unit'].set('day')
        self.share.sumry_unit_choice['values'] = ('day', 'hr', 'min')
        self.share.sumry_unit_choice.select_clear()
        self.share.setting['cycles_max'].set(1008)
        self.share.setting['do_log'].set(True)
        self.share.setting['proj_update'].set(False)

    def start_data(self) -> None:
        """
        Gather initial task data and times; set data dictionary
        control variables. Log data to file if so optioned.
        Called from start_when_confirmed().
        """
        # As with task names, task times as sec.microsec are unique.
        #   In the future, may want to inspect task names with
        #     tnames = BC.get_reported('tasks').
        ttimes_start = BC.get_reported('elapsed time')
        self.share.data['task_count'].set(len(ttimes_start))
        self.share.data['num_tasks_all'].set(len(BC.get_tasks('name')))

        # Begin the set of used/old tasks to exclude from new tasks;
        #   used in interval_data() to track tasks across intervals.
        self.ttimes_used.update(ttimes_start)

        startdict = T.boinc_ttimes_stats(ttimes_start)
        self.share.data['tt_avg'].set(startdict['tt_avg'])
        self.share.data['tt_sd'].set(startdict['tt_sd'])
        self.share.data['tt_range'].set(
            f"{startdict['tt_min']} -- {startdict['tt_max']}")
        self.share.data['tt_total'].set(startdict['tt_total'])

        self.share.data['time_prev_cnt'].set('Last hourly BOINC report.')

        if self.share.setting['do_log'].get():
            self.share.logit('start')

    def task_states(self) -> None:
        """
        Query boinc-client for status of tasks queued, running, and
        suspended; set corresponding dictionary tk control variables.
        Called from notice_it().
        """

        self.share.status_time = datetime.now().strftime(LONG_STRFTIME)
        tasks_all = BC.get_tasks('all')
        no_new_tasks = BC.no_new_tasks()

        # Need the literal task data tags as found in boinccmd stdout;
        #   the format is same as tag_str in BC.get_tasks().
        #   Use tuple index to populate the list expressions.
        tags = ('   name: ',
                '   active_task_state: ',
                '   state: ')
        num_tasks_all = len([elem for elem in tasks_all if tags[0] in elem])
        tasks_active = [elem.replace(tags[1], '') for elem in tasks_all
                        if tags[1] in elem]
        task_states = [elem.replace(tags[2], '') for elem in tasks_all
                       if tags[2] in elem]
        # When communication to server is stalled, all tasks will be
        #  "Ready to report" with a state of 'uploaded', so a forced
        #   Project update in notice_it() may prompt finalizing
        #   the task upload.
        if 'uploaded' in task_states and 'downloaded' not in task_states:
            self.share.note['proj_stalled'].set(True)
        num_running = len(
            [task for task in tasks_active if 'EXECUTING' in task])
        num_suspended_by_boinc = len(
            [task for task in tasks_active if 'SUSPENDED' in task])
        num_suspended_by_user = len(
            [task for task in tasks_all if 'suspended via GUI: yes' in task])

        self.share.data['num_tasks_all'].set(num_tasks_all)
        self.share.note['num_running'].set(num_running)
        self.share.note['num_suspended_by_boinc'].set(num_suspended_by_boinc)
        self.share.note['num_suspended_by_user'].set(num_suspended_by_user)
        self.share.note['no_new_tasks'].set(no_new_tasks)

    def interval_data(self) -> None:
        """
        Run timer and countdown clock to update and analyze regular and
        summary data for task status and times. Set control variables
        for data and notice dictionaries.
        Is threaded as interval_thread; started in Viewer.start_threads()
        Calls to: get_minutes(), log_it().
        """
        ttimes_new = set()
        ttimes_smry = set()
        cycles_max = self.share.setting['cycles_max'].get()
        interval_m = self.share.setting['interval_m'].get()
        reference_time = time()
        tic_nnt = 0
        sumry_intvl_counts = []
        sumry_intvl_ttavgs = []

        for cycle in range(cycles_max):
            if cycle == 1:
                # Need to change button name and function from Start to Interval
                #   after initial cycle[0] completes and intvl data displays.
                #  It might be better if statement were in Viewer, but simpler
                #  to put it here with easy reference to cycle.
                self.share.intvl_b.grid(row=0, column=1,
                                        padx=(16, 0), pady=(8, 4))
                self.share.starting_b.grid_forget()
            # Need to sleep between counts while displaying a countdown timer.
            # Need to limit total time of interval to target_elapsed_time,
            #   in Epoch seconds, b/c each interval sleep cycle will run longer
            #   than the intended interval. Realized interval time should not
            #   drift by more than 1 second during count_max cycles.
            # Without this time limit, each 1h interval would gain ~4s.
            interval_sec = interval_m*60
            target_elapsed_time = reference_time + (interval_sec * (cycle+1))
            for _sec in range(interval_sec):
                if cycle == cycles_max:
                    break
                if time() > target_elapsed_time:
                    self.share.data['time_next_cnt'].set('00:00')
                    break
                interval_sec -= 1
                # Need to show the time remaining in clock time format.
                self.share.data['time_next_cnt'].set(
                    T.sec_to_format(interval_sec, 'clock'))
                sleep(1.0)

            # NOTE: Starting tasks are not included in interval and summary
            #   counts, but starting task times are used here to determine
            #   "new" tasks.
            # Need to add all prior tasks to the "used" set.
            #  "new" task times are carried over from the prior interval cycle.
            #  For cycle[0], ttimes_used is starting tasks from start_data()
            #    and ttimes_new is empty.
            with self.thread_lock:
                self.ttimes_used.update(ttimes_new)
                ttimes_reported = set(BC.get_reported('elapsed time'))

                # Need to reset prior ttimes_new, then repopulate it with only
                #   newly reported tasks.
                ttimes_new.clear()
                ttimes_new = ttimes_reported - self.ttimes_used

                task_count_new = len(ttimes_new)
                self.share.data['task_count'].set(task_count_new)
                # Add new tasks to summary set for later analysis.
                ttimes_smry.update(ttimes_new)

                cycles_remain = int(self.share.data['cycles_remain'].get()) - 1
                self.share.data['cycles_remain'].set(cycles_remain)
                # Display weekday with time of previous interval to aid the user.
                self.share.data['time_prev_cnt'].set(
                    datetime.now().strftime(DAY_STRFTIME))
                # Capture full ending time here, instead of in log_it(),
                #   so that the logged time matches displayed time.
                self.share.data['intvl_count_t'].set(
                    datetime.now().strftime(LONG_STRFTIME))

                # Track when no new tasks were reported in past interval;
                #   tic_nnt used in log_it().
                # Need to update num_running value from task_states().
                self.task_states()
                num_running = self.share.note['num_running'].get()

                if task_count_new == 0:
                    tic_nnt += 1
                elif task_count_new > 0 and num_running > 0:
                    tic_nnt = 0
                self.share.note['tic_nnt'].set(tic_nnt)

                intervaldict = T.boinc_ttimes_stats(ttimes_new)
                self.share.data['tt_avg'].set(intervaldict['tt_avg'])
                self.share.data['tt_sd'].set(intervaldict['tt_sd'])
                self.share.data['tt_range'].set(
                    f"{intervaldict['tt_min']} -- {intervaldict['tt_max']}")
                self.share.data['tt_total'].set(intervaldict['tt_total'])

                # Need to gather interval times and counts for ea. interval in
                #   a summary segment to calc weighted mean times. This sumry
                #   list has a different function than the ttimes_smry set.
                sumry_intvl_counts.append(task_count_new)
                sumry_intvl_ttavgs.append(self.share.data['tt_avg'].get())

                # SUMMARY DATA ####################################################
                # NOTE: Starting data are not included in summary tabulations.
                summary_m = T.string_to_min(self.share.setting['summary_t'].get())
                # When summary interval is >= 1 week, need to provide date of
                #   prior summary rather than weekday, as above (%A %H:%M).
                if summary_m >= 10080:
                    self.share.data['time_prev_cnt'].set(
                        datetime.now().strftime(SHORTER_STRFTIME))
                summary_time = self.share.data['time_prev_cnt'].get()

                if (cycle + 1) % (summary_m // interval_m) == 0 and num_running > 0:
                    # Flag used in log_it() to log summary data.
                    self.share.data['log_summary'].set(True)
                    # Need to deactivate tooltip and activate the Summary
                    #  data button now; only need these statements for
                    #  1st summary, but, oh well, here we go again...
                    Tooltip(self.share.sumry_b, '', 'disabled')
                    self.share.sumry_b.config(state=tk.NORMAL)

                    # Set time and stats of summary count.
                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(len(ttimes_smry))
                    summarydict = T.boinc_ttimes_stats(ttimes_smry)
                    self.share.data['tt_sd_sumry'].set(summarydict['tt_sd'])
                    self.share.data['tt_range_sumry'].set(
                        f"{summarydict['tt_min']} -- {summarydict['tt_max']}")
                    self.share.data['tt_total_sumry'].set(summarydict['tt_total'])

                    # Need the weighted mean summary task time, not the average
                    #   (arithmetic mean) value.
                    tt_wtmean = T.logtimes_stat(
                        sumry_intvl_ttavgs, 'wtmean', sumry_intvl_counts)
                    self.share.data['tt_mean_sumry'].set(tt_wtmean)

                    # Need to reset data set for the next summary interval.
                    ttimes_smry.clear()
                    sumry_intvl_counts.clear()
                    sumry_intvl_ttavgs.clear()

                if (cycle + 1) % (summary_m // interval_m) == 0 and num_running == 0:
                    self.share.data['log_summary'].set(True)
                    Tooltip(self.share.sumry_b, '', 'disabled')
                    self.share.sumry_b.config(state=tk.NORMAL)

                    self.share.data['time_prev_sumry'].set(summary_time)
                    self.share.data['task_count_sumry'].set(0)
                    self.share.data['tt_mean_sumry'].set('n/a')
                    self.share.data['tt_sd_sumry'].set('n/a')
                    self.share.data['tt_range_sumry'].set('n/a')
                    self.share.data['tt_total_sumry'].set('n/a')

            # Call to log_it() needs to be outside the thread lock.
            app.update_idletasks()
            if self.share.setting['do_log'].get():
                self.share.logit('interval')

    def notice_it(self) -> None:
        """
        Notices for BOINC task state information should run on short
        time intervals. A NOTICE_INTERVAL of 15 works well.
        Is threaded as notice_thread; started in Viewer.start_threads().
        Calls to: task_states() and log_it().
        """
        while self.share.data['cycles_remain'].get() > 0:
            sleep(NOTICE_INTERVAL)
            with self.thread_lock:
                # Need to quit app if boinc-client is no longer running.
                check_boinc()

                self.task_states()
                num_running = self.share.note['num_running'].get()
                num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
                num_suspended_by_boinc = self.share.note['num_suspended_by_boinc'].get()
                num_tasks_all = self.share.data['num_tasks_all'].get()
                tic_nnt = self.share.note['tic_nnt'].get()
                proj_stalled = self.share.note['proj_stalled'].get()
                no_new_tasks = self.share.note['no_new_tasks'].get()
                cycles_max = self.share.setting['cycles_max'].get()
                cycles_remain = self.share.data['cycles_remain'].get()
                interval_m = self.share.setting['interval_m'].get()

                # Need to change to notice fg color from "All is well" row_fg color.
                self.share.notice_l.config(fg=self.share.highlight)

                # Need notices for task status that might need user attention,
                #   conditioned in descending priority.
                if num_running > 0:
                    if num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'{num_suspended_by_user} tasks are suspended by user.\n'
                            'BOINC will not upload while tasks are suspended.')
                    elif num_running >= (num_tasks_all - 1):
                        self.share.note['notice_txt'].set(
                            'BOINC client is about to run out of tasks.\n'
                            'Check BOINC Manager.')
                    elif tic_nnt > 0:
                        nnt_time = T.sec_to_format(
                            (tic_nnt * interval_m * 60), 'short')
                        self.share.note['notice_txt'].set(
                            f'NO TASKS reported in past {nnt_time}\n'
                            f'for the prior {tic_nnt} counting interval(s).')
                    else:
                        # Everything is fine, remove any prior notice.
                        # Use a de-emphasized color for this non-notice status text.
                        self.share.notice_l.config(fg=self.share.row_fg)
                        self.share.note['notice_txt'].set(
                            f'All is well (updates every {NOTICE_INTERVAL} seconds)')

                if num_running == 0:
                    if proj_stalled:
                        if self.share.setting['proj_update'].get():
                            # Note: this will sleep notice_it() for 70 seconds.
                            self.update_project()
                        else:
                            self.share.note['notice_txt'].set(
                                'A PROJECT UPDATE MAY BE NEEDED.\n'
                                'Check BOINC Manager.')
                    elif num_tasks_all == 0:
                        self.share.note['notice_txt'].set(
                            'BOINC client has no tasks to run!\n'
                            'Check BOINC Manager.')
                        if no_new_tasks:
                            self.share.note['notice_txt'].set(
                                'BOINC client has no tasks to run!\n'
                                'Project is set to receive no new tasks.\n'
                                'Check BOINC Manager Projects.')
                    elif num_suspended_by_user > 0:
                        self.share.note['notice_txt'].set(
                            f'NO TASKS running; {num_suspended_by_user} tasks suspended by user.\n'
                            'You may want to resume them.')
                    elif num_suspended_by_boinc > 0:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running.\n'
                            'A BOINC Manager "When to suspend" condition was met.\n'
                            'Edit BOINC Manager Computing preferences if this is a problem.')
                    else:
                        self.share.note['notice_txt'].set(
                            'NO TASKS running; reason unknown\nCheck BOINC Manager.')

                if cycles_remain == 0:
                    prior_note = self.share.note['notice_txt'].get()
                    if prior_note:
                        self.share.note['notice_txt'].set(
                            f'{prior_note}\n'
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    else:
                        self.share.note['notice_txt'].set(
                            f'*** All {cycles_max} count intervals have been run. ***\n')
                    print(f'\n*** {cycles_max} of {cycles_max} counting cycles have ended. ***\n')

            app.update_idletasks()
            # Call to log_it() here needs to be outside the thread lock.
            if self.share.setting['do_log'].get():
                self.share.logit('notice')

    def log_it(self, called_from) -> None:
        """
        Write interval and summary metrics for recently reported
        BOINC tasks. Provide information on aberrant task status.
        Called from interval_data() and notice_it().
        Is threaded as log_thread; started in Viewer.start_threads().

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """

        # Var used for log text formatting:
        indent = ' ' * 22
        bigindent = ' ' * 33

        # NOTE: any change to log text format or structure needs to be tracked
        #   by data extraction regex in Logs.analyze_logfile().
        # Note: Lots of local variables are used here to make the notice text
        #   statements easier to read.
        # Var outside of thread lock are set in settings() and thus invariant.
        cycles_max = self.share.setting['cycles_max'].get()
        interval_t = self.share.setting['interval_t'].get()
        summary_t = self.share.setting['summary_t'].get()
        with self.thread_lock:
            intvl_count_t = self.share.data['intvl_count_t'].get()
            if called_from == 'start':
                self.task_count_start = self.share.data['task_count'].get()
            elif called_from == 'interval':
                self.task_count_new = self.share.data['task_count'].get()
            tt_avg = self.share.data['tt_avg'].get()
            tt_sd = self.share.data['tt_sd'].get()
            tt_range = self.share.data['tt_range'].get()
            tt_total = self.share.data['tt_total'].get()
            num_tasks_all = self.share.data['num_tasks_all'].get()
            cycles_remain = self.share.data['cycles_remain'].get()
            num_running = self.share.note['num_running'].get()
            num_suspended_by_user = self.share.note['num_suspended_by_user'].get()
            no_new_tasks = self.share.note['no_new_tasks'].get()
            tic_nnt = self.share.note['tic_nnt'].get()

            if called_from == 'start' and cycles_max > 0:
                report = (
                    f'\n>>> START GUI TASK COUNTER v.{__version__}, SETTINGS: <<<\n'
                    f'{self.share.long_time_start};'
                    ' Number of tasks in the most recent BOINC report:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}Number of scheduled count intervals: {cycles_max}\n'
                    f'{indent}Counts every {interval_t}, summaries every {summary_t}.\n'
                    f'{indent}BOINC status evaluations every {NOTICE_INTERVAL}s.\n'
                    f'{indent}Project auto-update:'
                    f" {self.share.setting['proj_update'].get()}\n\n"
                    'Timed intervals beginning now...\n')
                logging.info(report)
            # Need to provide a truncated report for one-off "status" runs.
            elif called_from == 'start' and cycles_max == 0:
                report = (
                    f'\n{self.share.long_time_start}; STATUS REPORT\n'
                    f'{indent}Number of tasks recently reported by BOINC:'
                    f' {self.task_count_start}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n')
                logging.info(report)

            # Note: Two timestamps are used: self.share.data['intvl_count_t']
            #   is defined in interval_data() at end of each count cycle,
            #   self.share.status_time is defined in task_states().
            if called_from == 'notice' and num_running > 0:
                # A Notice for no new tasks reported, tic_nnt, is issued in
                #   interval_data() instead of here.
                if num_running == num_tasks_all:
                    report = (f'\n{self.share.status_time};'
                              'BOINC client is about to run out of tasks.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'\n{self.share.status_time}; '
                              f'{num_suspended_by_user} tasks are suspended by user.')
                    logging.info(report)
            elif called_from == 'notice' and num_running == 0:
                report = (f'\n{self.share.status_time};'
                          ' *** NO TASKS RUNNING. Check BOINC Manager.***')
                logging.info(report)
                if self.share.note['proj_stalled'].get():
                    report = (
                        f' *** PROJECT AUTO-UPDATE REQUESTED for {self.share.first_project}. ***\n'
                        '  All tasks were "Ready to report" and waiting to upload.\n'
                        '  If Project auto-update is allowed, tasks should now be uploaded.\n'
                        '  Verify in BOINC Manager.')
                    logging.info(report)
                if num_tasks_all == 0:
                    report = f'{indent}BOINC client has no tasks!\n'
                    logging.info(report)
                if self.share.note['num_suspended_by_boinc'].get() > 0:
                    report = (f'{indent}BOINC Manager has suspended tasks;\n'
                              f'{indent}A "When to suspend" condition was met\n'
                              f'{indent}in BOINC Manager Computing preferences.')
                    logging.info(report)
                if num_suspended_by_user > 0:
                    report = (f'{indent}'
                              f'{num_suspended_by_user} tasks suspended by user.')
                    logging.info(report)
                if no_new_tasks:
                    report = (f'{indent}Not receiving new tasks.\n'
                              f'{indent}Check BOINC Manager Projects.')
                    logging.info(report)

            if called_from == 'interval' and tic_nnt > 0:
                report = (f'\n{intvl_count_t}; NO TASKS reported in the past'
                          f' {tic_nnt} counting intervals.\n'
                          f'{indent}{cycles_remain} counts remain.')
                logging.info(report)

            # This tic condition is equivalent to: task_count_new > 0 and
            #   num_running > 0; that is, everything normal.
            elif called_from == 'interval' and tic_nnt == 0:
                report = (
                    f'\n{intvl_count_t}; Tasks reported in the past {interval_t}:'
                    f' {self.task_count_new}\n'
                    f'{indent}Task Time: avg {tt_avg},\n'
                    f'{bigindent}range [{tt_range}],\n'
                    f'{bigindent}stdev {tt_sd}, total {tt_total}\n'
                    f'{indent}Total tasks in queue: {num_tasks_all}\n'
                    f'{indent}{cycles_remain} counts remain.'
                )
                logging.info(report)

            if called_from == 'interval' and self.share.data['log_summary'].get():
                report = (
                    f'\n{intvl_count_t}; >>> SUMMARY: Count for the past'
                    f" {summary_t}: {self.share.data['task_count_sumry'].get()}\n"
                    f"{indent}Task Time: mean {self.share.data['tt_mean_sumry'].get()},\n"
                    f"{bigindent}range [{self.share.data['tt_range_sumry'].get()}],\n"
                    f"{bigindent}stdev {self.share.data['tt_sd_sumry'].get()},"
                    f" total {self.share.data['tt_total_sumry'].get()}")
                logging.info(report)
                # Need to reset flag to toggle summary logging.
                self.share.data['log_summary'].set(False)

            if called_from == 'interval' and cycles_remain == 0:
                report = f'\n### {cycles_max} counting cycles have ended. ###\n'
                logging.info(report)

    def update_project(self) -> None:
        """
        Called from notice_it() when auto-update project setting is True.
        """
        # I'm not sure how to handle multiple concurrent Projects.
        # B/c of how BC.project_action is structured, here I use the
        #  url to get the Project name ID which is used to get the
        #  url needed for the project cmd.  Silly, but uses existing
        #  boinc_commands.py methods. Is there a better way?
        first_local_url = BC.get_project_url()[0]
        self.share.first_project = list(BC.project_url().keys())[
            list(BC.project_url().values()).index(first_local_url)]
        BC.project_action(self.share.first_project, 'update')
        self.share.note['notice_txt'].set(
            'Project auto-update in progress for'
            f' {self.share.first_project}...')
        if self.share.setting['do_log'].get():
            self.share.logit('notice')
        # Need to provide time for BOINC Project server to respond before
        #   continuing with notice_it() thread.
        sleep(70)


# MVC Viewer, the tkinter GUI engine; runs in main thread.
class CountViewer(tk.Frame):
    """
    The Viewer communicates with Modeler via 'share' objects handled
    through the Controller class. All GUI widgets go here.
    """

    def __init__(self, share):
        super().__init__()
        self.share = share
        # Note that self.master is an internal attribute and refers to the
        #   CountController() Tk top window. Outside of CountViewer(),
        #   use app. to refer to the CountController() Tk object.
        self.dataframe = tk.Frame()
        self.menubar = tk.Menu()

        # Set colors for row labels and data display.
        # These colors are compatible with red-green color-blindness.
        self.share.row_fg = 'LightYellow'  # Row header label fg.
        self.master_bg = 'SteelBlue4'  # app and header label bg.
        self.data_bg = 'grey40'  # Data labels and data frame bg.
        self.share.highlight = 'gold1'  # Notices, compliments, highlight fg.
        self.emphasize = 'grey90'  # Lighter data label fg, use for grey-out.
        self.deemphasize = 'grey60'  # Darker data label fg.

        # Need to grey-out menu bar headings and View log button when
        #   another application has focus.
        #   source: https://stackoverflow.com/questions/18089068/
        #   tk-tkinter-detect-application-lost-focus
        self.bind_all('<FocusIn>', self.app_got_focus)
        self.bind_all('<FocusOut>', self.app_lost_focus)

        # settings() window widgets:
        self.settings_win = tk.Toplevel()
        self.share.intvl_choice = ttk.Combobox(self.settings_win)
        self.sumry_value_entry = ttk.Entry(self.settings_win)
        self.share.sumry_unit_choice = ttk.Combobox(self.settings_win)
        self.cycles_max_entry = ttk.Entry(self.settings_win)
        self.countnow_button = ttk.Button(self.settings_win)
        self.log_choice = tk.Checkbutton(self.settings_win)
        self.update_choice = tk.Checkbutton(self.settings_win)

        # Control variables for basic run parameters/settings passed
        #    between Viewer and Modeler.
        self.share.setting = {
            'interval_t': tk.StringVar(),
            'interval_m': tk.IntVar(),
            'sumry_t_value': tk.StringVar(),
            'sumry_t_unit': tk.StringVar(),
            'summary_t': tk.StringVar(),
            'cycles_max': tk.IntVar(),
            'do_log': tk.BooleanVar(),
            'proj_update': tk.BooleanVar()
        }

        # Control variables for display in master; data passed between
        #    Viewer and Modeler.
        self.share.data = {
            # Start and Interval data
            'task_count': tk.IntVar(),
            'tt_avg': tk.StringVar(),
            'tt_sd': tk.StringVar(),
            'tt_range': tk.StringVar(),
            'tt_total': tk.StringVar(),
            'intvl_count_t': tk.StringVar(),
            # General data
            'time_prev_cnt': tk.StringVar(),
            'cycles_remain': tk.IntVar(),
            'time_next_cnt': tk.StringVar(),
            'num_tasks_all': tk.IntVar(),
            # Summary data
            'time_prev_sumry': tk.StringVar(),
            'task_count_sumry': tk.IntVar(),
            'tt_mean_sumry': tk.StringVar(),
            'tt_sd_sumry': tk.StringVar(),
            'tt_range_sumry': tk.StringVar(),
            'tt_total_sumry': tk.StringVar(),
            'log_summary': tk.BooleanVar()
        }

        # Control variables for notices and logging passed between
        #   Viewer and Modeler and between Modeler threads.
        self.share.note = {
            'notice_txt': tk.StringVar(),
            'num_running': tk.IntVar(),
            'tic_nnt': tk.IntVar(),
            'proj_stalled': tk.BooleanVar(),
            'no_new_tasks': tk.BooleanVar(),
            'num_suspended_by_user': tk.IntVar(),
            'num_suspended_by_boinc': tk.IntVar(),
        }

        # Labels for settings values; gridded in master_layout(). They are
        #   fully configured here simply to reduce number of lines in code.
        # NOTE: self.time_start_l label is initially configured for text to
        #   show a startup message, then reconfigured in emphasize_start_data()
        #   for the time_start.
        self.time_start_l = tk.Label(
            self.dataframe, bg=self.data_bg, fg='grey90')
        self.interval_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['interval_t'],
            relief='groove', bg=self.data_bg)
        self.summary_t_l = tk.Label(
            self.dataframe, width=21, borderwidth=2,
            textvariable=self.share.setting['summary_t'],
            relief='groove', bg=self.data_bg)
        self.cycles_max_l = tk.Label(
            textvariable=self.share.setting['cycles_max'],
            bg=self.master_bg, fg=self.share.row_fg)

        # Labels for BOINC data.
        self.task_count_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count'])
        self.tt_avg_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_avg'])
        self.tt_sd_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd'])
        self.tt_range_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range'])
        self.tt_total_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total'])
        self.task_count_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['task_count_sumry'])
        self.ttmean_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_mean_sumry'])
        self.ttsd_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_sd_sumry'])
        self.ttrange_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_range_sumry'])
        self.ttsum_sumry_l = tk.Label(
            self.dataframe, width=3, bg=self.data_bg,
            textvariable=self.share.data['tt_total_sumry'])

        # Master data labels (self.master is implicit as the parent).
        self.time_prev_cnt_l = tk.Label(
            textvariable=self.share.data['time_prev_cnt'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_prev_sumry_l = tk.Label(
            textvariable=self.share.data['time_prev_sumry'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.time_next_cnt_l = tk.Label(
            textvariable=self.share.data['time_next_cnt'],
            bg=self.master_bg, fg=self.share.highlight)
        self.cycles_remain_l = tk.Label(
            textvariable=self.share.data['cycles_remain'],
            bg=self.master_bg, fg=self.share.row_fg)
        self.num_tasks_all_l = tk.Label(
            textvariable=self.share.data['num_tasks_all'],
            bg=self.master_bg, fg=self.share.row_fg)
        # Text for compliment_l is configured in compliment_me()
        self.share.compliment_l = tk.Label(
            bg=self.master_bg, fg=self.share.highlight)
        self.share.notice_l = tk.Label(
            textvariable=self.share.note['notice_txt'],
            fg=self.share.highlight, bg=self.master_bg,
            relief='flat', border=0)

        # This style is used only to configure viewlog_b color in
        #   app_got_focus() and app_lost_focus().
        #   self.master is implicit as the parent.
        self.view_button_style = ttk.Style()

        # Need to define image as a class variable, not a local var in methods.
        self.info_button_img = tk.PhotoImage(
            file=Utils.absolute_path_to('images/info_button20.png'))

        self.master_widgets()
        self.master_layout()
        self.share.defaultsettings()
        self.settings()
        # Sequence of starting functions after settings() is called:
        #   confirm_settings(), start_when_confirmed(), start_threads(),
        #   emphasize_start_data(), starting_tooltips(),
        #   CountModeler.start_data(). Of course none of that sequence
        #   matters if BOINC client is not running, so...
        check_boinc()

    def master_widgets(self) -> None:
        """
        Master app menus and buttons.
        """
        self.master.config(menu=self.menubar)
        # Add pull-down menus
        file = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='File', menu=file)
        file.add_command(
            label='Backup log file',
            command=lambda: Files.save_as(Logs.LOGFILE))
        file.add_command(
            label='Backup analysis file',
            command=lambda: Files.save_as(Logs.ANALYSISFILE))
        file.add_separator()
        file.add_command(label='Quit', command=quit_gui,
                         accelerator='Ctrl+Q')
        # ^^ Note: use Ctrl+Q for macOS also to call quit_gui; Cmd+Q still works.
        view = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='View', menu=view)
        view.add_command(label='Log file',
                         command=lambda: Logs.view(Logs.LOGFILE),
                         # MacOS: can't display 'Cmd+L' b/c won't override native cmd.
                         accelerator='Ctrl+L')
        view.add_command(label='Analysis of log data', command=Logs.show_analysis,
                         accelerator='Ctrl+Shift+L')
        view.add_command(label='Saved Analyses',
                         command=lambda: Logs.view(Logs.ANALYSISFILE),
                         accelerator='Ctrl+Shift+A')
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label='Help', menu=help_menu)
        help_menu.add_command(label='Information', command=self.share.info)
        help_menu.add_command(label='Compliment',
                              command=self.share.compliment,
                              accelerator='Ctrl+Shift+C')
        help_menu.add_command(label='File paths',
                              command=self.share.filepaths)
        help_menu.add_command(label='About', command=self.share.about)

        # For Button constructors, self.master is implicit as the parent.
        self.share.viewlog_b = ttk.Button(text='View log file',
                                          command=lambda: Logs.view(Logs.LOGFILE),
                                          takefocus=False)
        # Set interval & summary focus button attributes with *.share.* b/c need
        #   to reconfigure them in Modeler.
        # starting_b will be replaced with an active ttk intvl_b after first
        #   interval completes; it is re-gridded in interval_data().
        # starting_b is tk.B b/c ttk.B doesn't use disabledforeground keyword.
        self.share.starting_b = tk.Button(text='Starting data',
                                          width=18, disabledforeground='grey10',
                                          takefocus=False,
                                          state=tk.DISABLED)
        self.share.intvl_b = ttk.Button(text='Interval data', width=18,
                                        command=self.emphasize_intvl_data,
                                        takefocus=False)
        self.share.sumry_b = ttk.Button(text='Summary data', width=20,
                                        command=self.emphasize_sumry_data,
                                        takefocus=False)

    def master_layout(self) -> None:
        """
        Master and dataframe configuration, keybindings, row headers,
        separators, and grids.
        """

        # OS-specific window size ranges set in Controller __init__
        # Need to color in all the master Frame and use near-white border;
        #   bd changes to darker shade for click-drag and loss of focus.
        self.master.config(bg=self.master_bg,
                           highlightthickness=3,
                           highlightcolor='grey95',
                           highlightbackground='grey75'
                           )
        # Need to provide exit info to Terminal and log.
        self.master.protocol('WM_DELETE_WINDOW', quit_gui)

        self.master.bind_all('<Escape>', quit_gui)
        self.master.bind('<Control-q>', quit_gui)
        # ^^ Note: macOS Command-q will quit program without quit_gui info msg.
        # Note: Toplevel key bindings are set with module Binds.keyboard().
        self.master.bind('<Control-l>',
                         lambda _: Logs.view(Logs.LOGFILE))
        self.master.bind('<Shift-Control-L>', lambda _: Logs.show_analysis())
        self.master.bind('<Shift-Control-A>',
                         lambda _: Logs.view(Logs.ANALYSISFILE))
        self.master.bind('<Shift-Control-C>', lambda _: self.share.compliment())

        # Need to specify Ctrl-a for Linux b/c in tkinter that key is
        #   bound to the tkinter predefined virtual event <<LineStart>>,
        #   not <<SelectAll>>, for some reason? And  Shift-Control-A
        #   will select text from cursor to <<LineStart>>.
        if MY_OS in 'lin':
            def select_all():
                app.focus_get().event_generate('<<SelectAll>>')

            self.master.bind_all('<Control-a>', lambda _: select_all())

            def select_none():
                app.focus_get().event_generate('<<SelectNone>>')

            self.master.bind_all('<Shift-Control-A>', lambda _: select_none())

        # Theme controls entire window theme, but only for ttk.Style objects.
        # Options: classic, alt, clam, default, aqua(MacOS only)
        ttk.Style().theme_use('alt')

        self.master.columnconfigure(1, weight=1)
        self.master.columnconfigure(2, weight=1)

        self.dataframe.configure(borderwidth=3, relief='sunken',
                                 bg=self.data_bg)
        self.dataframe.grid(row=2, column=1, rowspan=7, columnspan=2,
                            padx=(5, 10), sticky=tk.NSEW)
        self.dataframe.columnconfigure(1, weight=1)
        self.dataframe.columnconfigure(2, weight=1)

        # Fill in headers for all data rows.
        # Pady first row to better align headers with data in dataframe.
        tk.Label(
            text='Counting since', bg=self.master_bg, fg=self.share.row_fg
        ).grid(row=2, column=0, padx=(5, 0), pady=(3, 0), sticky=tk.NE)
        row_header = {
            #'Counting since': 2,
            'Count interval, t': 3,
            '# tasks reported': 4,
            'Task times:  avg': 5,
            'stdev': 6,
            'range': 7,
            'total': 8,
            'Interval time:': 10,
            'Next count in:': 11,
            'Tasks in queue:': 12,
            'Notices:': 13
        }
        for header, rownum in row_header.items():
            tk.Label(
                text=f'{header}', bg=self.master_bg, fg=self.share.row_fg
            ).grid(row=rownum, column=0, padx=(5, 0), pady=(0, 1), sticky=tk.NE)
            # ^^ Grid to N or NE to prevent Notices label from shifting down
            #    when more than one row of notice_it() text appears.
            #    For all Label constructors, self.master parent is implicit.
        # Need to accommodate cases of two headers in same row.
        tk.Label(text='Summary time:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=10, column=2, sticky=tk.W)
        tk.Label(text='Counts until exit:',
                 bg=self.master_bg, fg=self.share.row_fg
                 ).grid(row=12, column=2, sticky=tk.W)

        # For colored separators, use ttk.Frame instead of ttk.Separator.
        # Initialize then configure style for separator color.
        style_sep = ttk.Style()
        style_sep.configure('Sep.TFrame', background=self.master_bg)
        sep1 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)
        sep2 = ttk.Frame(style='Sep.TFrame', relief="raised", height=6)

        # %%%%%%%%%%%%%%%%%%% grid: sorted by row number %%%%%%%%%%%%%%%%%%%%%%
        self.share.viewlog_b.grid(
            row=0, column=0, padx=5, pady=(8, 4))
        self.share.starting_b.grid(
            row=0, column=1, padx=(16, 0), pady=(6, 4))
        self.share.sumry_b.grid(
            row=0, column=2, padx=(0, 20), pady=(8, 4))
        sep1.grid(
            row=1, column=0, columnspan=5, padx=5, pady=(2, 5), sticky=tk.EW)
        self.time_start_l.grid(  # No padx + sticky EW = centered.
            row=2, column=1, columnspan=2, sticky=tk.EW)
        self.interval_t_l.grid(
            row=3, column=1, padx=(10, 8), sticky=tk.EW)
        self.summary_t_l.grid(
            row=3, column=2, padx=(0, 12), sticky=tk.EW)
        self.task_count_l.grid(
            row=4, column=1, padx=12, sticky=tk.EW)
        self.task_count_sumry_l.grid(
            row=4, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_avg_l.grid(
            row=5, column=1, padx=12, sticky=tk.EW)
        self.ttmean_sumry_l.grid(
            row=5, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_sd_l.grid(
            row=6, column=1, padx=12, sticky=tk.EW)
        self.ttsd_sumry_l.grid(
            row=6, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_range_l.grid(
            row=7, column=1, padx=12, sticky=tk.EW)
        self.ttrange_sumry_l.grid(
            row=7, column=2, padx=(0, 12), sticky=tk.EW)
        self.tt_total_l.grid(
            row=8, column=1, padx=12, sticky=tk.EW)
        self.ttsum_sumry_l.grid(
            row=8, column=2, padx=(0, 12), sticky=tk.EW)
        sep2.grid(
            row=9, column=0, columnspan=5, padx=5, pady=(6, 6), sticky=tk.EW)
        self.time_prev_cnt_l.grid(
            row=10, column=1, columnspan=2, padx=3, sticky=tk.W)
        self.time_prev_sumry_l.grid(
            row=10, column=2, padx=(108, 0), sticky=tk.W)
        self.time_next_cnt_l.grid(
            row=11, column=1, padx=3, sticky=tk.W)
        self.num_tasks_all_l.grid(
            row=12, column=1, padx=3, sticky=tk.W)
        # Place cycles_remain value in same cell as its header, but shifted right.
        if MY_OS in 'lin, dar':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(123, 0), sticky=tk.W)
        elif MY_OS == 'win':
            self.cycles_remain_l.grid(
                row=12, column=2, padx=(110, 0), sticky=tk.W)
        #   Need pady for alignment with the row header.
        self.share.notice_l.grid(
            row=13, column=1, columnspan=2, rowspan=2, padx=5, pady=(1, 0),
            sticky=tk.NW)
        self.share.compliment_l.grid(
            row=14, column=1, columnspan=2, padx=5, sticky=tk.W)

        # Some control variables have default or initial start values,
        #   so make labels invisible in pre-settings dataframe by matching
        #   them to the background color.
        self.interval_t_l.config(foreground=self.data_bg)
        self.summary_t_l.config(foreground=self.data_bg)
        self.task_count_l.config(foreground=self.data_bg)
        self.task_count_sumry_l.config(foreground=self.data_bg)

    def settings(self) -> None:
        """
        Configures the Toplevel window that appears at startup.
        Confirms default parameters or sets new ones for count and
        summary interval times, counting limit, and log file option.
        """
        # Toplevel window basics
        self.settings_win.title('Set run settings')
        self.settings_win.resizable(False, False)
        self.settings_win.config(relief='raised', bg=self.master_bg,
                                 highlightthickness=3,
                                 highlightcolor=self.share.highlight,
                                 highlightbackground=self.deemphasize)

        # Need to make settings window topmost to place it above the
        #   app window.
        if MY_OS in 'lin, win':
            self.settings_win.attributes('-topmost', True)
        # In macOS, topmost places Combobox selections BEHIND the window,
        #    but focus_force() makes it visible; must be a tkinter bug?
        elif MY_OS == 'dar':
            self.settings_win.focus_force()

        settings_style = ttk.Style()
        settings_style.configure('Set.TLabel', background=self.master_bg,
                                 foreground=self.share.row_fg)

        # Need text in master window to prompt user to enter settings.
        #   The message text is covered by the settings_win, but is
        #   seen if user drags settings_win away.
        self.time_start_l.configure(text='Waiting for run settings...')

        # Inner functions for window and selection control and user FYI:

        # Need to disable default window Exit; only allow exit from active
        #   Confirm button. https://stackoverflow.com/questions/22738412/
        #   a-suitable-do-nothing-lambda-expression-in-python
        def no_exit_on_x():
            messagebox.showinfo(
                parent=self.settings_win,
                title='Invalid exit',
                detail='"Count now" button closes window and begins'
                       ' counting. Or you can quit program from the main'
                       ' window (or "Esc" key) without starting counts.')

        self.settings_win.protocol('WM_DELETE_WINDOW', no_exit_on_x)

        def update_intvl():
            self.share.intvl_choice['values'] = sumry_unit[self.share.sumry_unit_choice.get()]

        def update_sumry_unit():
            self.share.sumry_unit_choice['values'] = interval_t[self.share.intvl_choice.get()]

        # Settings widget construction and configurations.
        intvl_label = ttk.Label(self.settings_win, text='Count time interval',
                                style='Set.TLabel')
        interval_t = {'1h': ('day', 'hr'),
                      '30m': ('day', 'hr'),
                      '20m': ('hr', 'min'),
                      '15m': ('hr', 'min'),
                      '10m': ('hr', 'min'),
                      }
        self.share.intvl_choice.configure(
            state='readonly', width=4, height=5,
            textvariable=self.share.setting['interval_t'],
            values=tuple(interval_t.keys()))
        self.share.intvl_choice.bind(
            '<<ComboboxSelected>>', lambda _: update_sumry_unit())
        self.share.setting['interval_t'].set(self.share.intvl_choice.get())

        sumry_label1 = ttk.Label(
            self.settings_win, text='Summary interval: time value',
            style='Set.TLabel')
        self.sumry_value_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['sumry_t_value'],
            validatecommand=(
                self.sumry_value_entry.register(Utils.enter_only_digits), '%P', '%d'))

        sumry_label2 = ttk.Label(
            self.settings_win, text='time unit', style='Set.TLabel')
        sumry_unit = {'day': ('1h', '30m'),
                      'hr': ('30m', '20m', '15m', '10m'),
                      'min': ('20m', '15m', '10m')
                      }
        self.share.sumry_unit_choice.configure(
            state='readonly', width=4,
            textvariable=self.share.setting['sumry_t_unit'],
            values=tuple(sumry_unit.keys()))
        self.share.sumry_unit_choice.bind(
            '<<ComboboxSelected>>', lambda _: update_intvl())
        self.share.setting['sumry_t_unit'].set(self.share.sumry_unit_choice.get())

        # Specify number limit of counting cycles to run.
        cycles_label = ttk.Label(self.settings_win, text='# Count cycles',
                                 style='Set.TLabel')
        self.cycles_max_entry.configure(
            validate='key', width=4,
            textvariable=self.share.setting['cycles_max'],
            validatecommand=(
                self.cycles_max_entry.register(Utils.enter_only_digits), '%P', '%d'))

        # Provide user options for logging results to file and using auto-update.
        log_label = ttk.Label(self.settings_win, text='Log results to file',
                              style='Set.TLabel')
        self.log_choice.configure(variable=self.share.setting['do_log'],
                                  bg=self.master_bg, borderwidth=0)
        update_label = ttk.Label(self.settings_win, text='Use Project auto-update',
                                 style='Set.TLabel')
        self.update_choice.configure(variable=self.share.setting['proj_update'],
                                     bg=self.master_bg, borderwidth=0)

        default_button = ttk.Button(self.settings_win, text='Use defaults',
                                    command=self.share.defaultsettings)
        self.countnow_button.configure(text='Count now',
                                       command=self.start_when_confirmed)

        # Grid settings widgets; generally sorted by row.
        intvl_label.grid(row=0, column=0, padx=5, pady=10, sticky=tk.E)
        self.share.intvl_choice.grid(row=0, column=1)
        default_button.grid(row=0, column=3, padx=10, pady=(10, 0), sticky=tk.E)
        sumry_label1.grid(row=1, column=0, padx=(10, 5), pady=10, sticky=tk.E)
        self.sumry_value_entry.grid(row=1, column=1)
        sumry_label2.grid(row=1, column=2, padx=5, pady=10, sticky=tk.E)
        self.share.sumry_unit_choice.grid(row=1, column=3, padx=5, pady=10, sticky=tk.W)
        cycles_label.grid(row=2, column=0, padx=5, pady=10, sticky=tk.E)
        self.cycles_max_entry.grid(row=2, column=1)
        log_label.grid(row=3, column=0, padx=5, pady=5, sticky=tk.E)
        self.log_choice.grid(row=3, column=1, padx=0, pady=5, sticky=tk.W)
        update_label.grid(row=4, column=0, padx=5, pady=0, sticky=tk.E)
        self.update_choice.grid(row=4, column=1, padx=0, pady=0, sticky=tk.W)
        self.countnow_button.grid(
            row=5, column=3, padx=10, pady=(0, 10), sticky=tk.E)

        # Add tooltips to explain entries and selections.
        self.settings_tooltips()

    def settings_tooltips(self) -> None:
        """
        Tooltips, from mouseover of info Button icons, to explain usage
        of entries and selections in the settings window.
        """

        # Need to use ttk.Button and styles on macOS to avoid square button img.
        #  Provides the same look on Linux, Windows, macOS. For Linux and
        #  Windows, works the same as tk.Button if configure with same options.
        s = ttk.Style()
        s.configure('Tooltip.TButton',
                    image=self.info_button_img,
                    background=self.master_bg,
                    highlightthickness=0,
                    highlightcolor=self.master_bg,
                    highlightbackground=self.master_bg,
                    activebackground=self.master_bg
                    )
        s.map('Tooltip.TButton',
              background=[('pressed', '!focus', self.master_bg),
                          ('active', self.master_bg)],
              relief=[('pressed', tk.FLAT),
                      ('!pressed', tk.FLAT)]
              )

        intvl_ttip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)
        cycles_ttip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)
        update_ttip_btn = ttk.Button(
            self.settings_win, style='Tooltip.TButton', takefocus=False)

        intvl_ttip_txt = (
            'If the desired pull-down time values do not appear, then'
            ' either select a different summary time (or a different'
            ' interval time if do not see a desired summary time unit)'
            ' or click "Use defaults" and try again.')
        cycles_ttip_txt = (
            'Interval counting stops after entered number of'
            ' cycles. Enter 0 (zero) for a one-off status report.')
        update_ttip_txt = (
            'Allows an automatic Project update to re-establish communication'
            ' with the BOINC server when no tasks are running and'
            ' all tasks in the BOINC Manager are "Ready to report".'
            ' This may have unwanted effects if communication is lost'
            " because of loss of the host's internet connection.")

        Tooltip(intvl_ttip_btn, intvl_ttip_txt)
        Tooltip(cycles_ttip_btn, cycles_ttip_txt)
        Tooltip(update_ttip_btn, update_ttip_txt)

        # Need OS-specific grids for proper padding and alignments:
        if MY_OS == 'lin':
            intvl_ttip_btn.grid(row=0, column=0, padx=(50, 0), sticky=tk.W)
            cycles_ttip_btn.grid(row=2, column=0, padx=(75, 0), sticky=tk.W)
            update_ttip_btn.grid(row=4, column=0, padx=(15, 0), sticky=tk.W)
        if MY_OS == 'win':
            intvl_ttip_btn.grid(row=0, column=0, padx=(35, 0), sticky=tk.W)
            cycles_ttip_btn.grid(row=2, column=0, padx=(60, 0), sticky=tk.W)
            update_ttip_btn.grid(row=4, column=0, padx=(5, 0), sticky=tk.W)
        if MY_OS == 'dar':
            intvl_ttip_btn.grid(row=0, column=0, padx=(45, 0), sticky=tk.W)
            cycles_ttip_btn.grid(row=2, column=0, padx=(70, 0), sticky=tk.W)
            update_ttip_btn.grid(row=4, column=0, padx=(8, 0), sticky=tk.W)

    def confirm_settings(self) -> bool:
        """
        Confirm validity of summary and interval times,
        set all to valid control variable dictionary values,
        and set up logging of data, if optioned.
        Called from start_when_confirmed().

        :return: True if settings are all valid.
        """
        # Need to set to True when interval and summary times are
        #   confirmed as valid. All other settings are self-validating.
        good_settings = False

        # Note: self.share.setting['interval_t'] and self.sumry_t_value
        #    are set in settings() or in Modeler.default_settings().
        if not self.share.setting['interval_t'].get():
            self.share.defaultsettings()
        if self.share.setting['interval_t'].get() != '1h':
            interval_m = int(self.share.setting['interval_t'].get()[:-1])
        else:
            # Need to convert 1h to minutes for comparisons.
            interval_m = 60
        self.share.setting['interval_m'].set(interval_m)

        if not self.share.setting['sumry_t_value'].get():
            msg = "Summary value cannot be blank. A default of '1' will be used."
            messagebox.showerror(title='Invalid entry', detail=msg,
                                 parent=self.settings_win)
            self.share.setting['sumry_t_value'].set(1)
        sumry_value = self.share.setting['sumry_t_value'].get()
        # If sumry_value = 0, it will be caught by interval_m comparison below.

        # Need to set summary_t here as concat of the two sumry_t element strings,
        #   then convert it to minutes for use in comparisons.
        summary_t = f"{sumry_value}{self.share.sumry_unit_choice.get()[:1]}"
        self.share.setting['summary_t'].set(summary_t)
        summary_m = T.string_to_min(summary_t)
        if interval_m >= summary_m or summary_m % interval_m != 0:
            info = "Summary time must be greater than, and a multiple of, interval time"
            messagebox.showerror(title='Invalid entry', detail=info,
                                 parent=self.settings_win)
            # Need to offer user valid alternatives to bad times entered.
            if self.share.setting['sumry_t_unit'].get() == 'min':
                self.share.setting['sumry_t_value'].set(2 * interval_m)
            elif self.share.setting['sumry_t_unit'].get() == 'hr':
                self.share.setting['sumry_t_value'].set(2 * sumry_value)
        elif interval_m < summary_m and summary_m % interval_m == 0:
            good_settings = True

        # Need to remove leading zeros, but allow a zero entry.
        #   Replace empty Entry with default values.
        cycles_max = self.cycles_max_entry.get()
        if cycles_max == '':
            self.share.setting['cycles_max'].set(1008)
        elif cycles_max != '0':
            self.share.setting['cycles_max'].set(int(cycles_max.lstrip('0')))
        # Allow zero entry for 1-off status report of task data.
        elif cycles_max == '0':
            self.share.setting['cycles_max'].set(0)

        # Need to set initial cycles_remain to cycles_max.
        self.share.data['cycles_remain'].set(self.share.setting['cycles_max'].get())

        # Note: logging module is used only to lazily manage the data log file.
        if self.share.setting['do_log'].get():
            logging.basicConfig(filename=str(Logs.LOGFILE), level=logging.INFO,
                                filemode="a", format='%(message)s')
        else:
            app.title(f'Count BOINC tasks on {gethostname()}'
                      ' (not logging data)')

        # Need to provide a unique name of app window for concurrent instances.
        if good_settings and not self.share.setting['do_log'].get():
            app.title(f'Count BOINC tasks on {gethostname()}'
                      f' (Parallel run, not logging data)')

        return good_settings

    def start_when_confirmed(self) -> None:
        """
        Main gatekeeper for settings().
        Calls confirm_settings(); if all is good then starts threads,
        calls emphasize_start_data(), and closes settings() window,
        which ends the startup sequence.
        Called from settings() countnow_button.
        """
        # Either run a 1-off status report or begin interval counts:
        if self.confirm_settings():
            if self.share.setting['cycles_max'].get() == 0:
                self.share.data['cycles_remain'].set(0)
                self.share.setting['interval_t'].set('DISABLED')
                self.share.setting['summary_t'].set('DISABLED')
                self.share.note['notice_txt'].set('STATUS REPORT ONLY')
            else:
                self.start_threads()

            self.emphasize_start_data()
            self.share.startdata()
            self.settings_win.destroy()

    def start_threads(self) -> None:
        """
        Set up and start threads for intervals, notices, and logging.
        Called from start_when_confirmed() as part of startup sequence.
        """
        # There are no thread.join(), so use daemon for clean exits.
        intvl_thread = threading.Thread(
            target=self.share.intervaldata, daemon=True)

        notice_thread = threading.Thread(
            target=self.share.taskstatenotices, daemon=True)

        log_thread = threading.Thread(
            target=self.share.logit, daemon=True, args=(None,))

        intvl_thread.start()
        notice_thread.start()
        log_thread.start()

    def emphasize_start_data(self) -> None:
        """
        Config data labels in master window for starting data emphasis.
        Establish start time.
        Called from start_when_confirmed() from 'Count now' button.
        """
        time_start = datetime.now().strftime(SHORT_STRFTIME)
        self.time_start_l.config(text=time_start)
        self.share.long_time_start = datetime.now().strftime(LONG_STRFTIME)

        # Need to keep sumry_b button disabled until after 1st summary interval.
        self.share.sumry_b.config(state=tk.DISABLED)

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)
        self.task_count_l.config(foreground=self.share.highlight)

        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

        if not self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)

        if self.share.setting['cycles_max'].get() > 0:
            self.starting_tooltips()

    def starting_tooltips(self):
        # Provide mouseover tooltips for data emphasis buttons.
        #  These will not be active once the first interval posts.
        starting_ttip_txt = (
            'This data column is now showing task data retrieved'
            ' from the most recent boinc-client report before'
            f' {__program_name__} started. Once the first count'
            ' interval time has elapsed, data for that interval will'
            ' display and this button will become "Interval data".'
        )
        Tooltip(self.share.starting_b, starting_ttip_txt)

        summary_ttip_txt = (
            'This button will activate and allow switching of visual'
            ' emphasis between interval and summary data columns'
            ' once the first summary count interval time has elapsed.'
        )
        Tooltip(self.share.sumry_b, summary_ttip_txt)

    def emphasize_intvl_data(self) -> None:
        """
        Switches font emphasis from Summary data to Interval data.
        Called from 'Interval data' button.
        """

        self.interval_t_l.config(foreground=self.emphasize)
        self.summary_t_l.config(foreground=self.deemphasize)

        # Interval data, column1
        self.task_count_l.configure(foreground=self.share.highlight)
        self.tt_avg_l.configure(foreground=self.share.highlight)
        self.tt_sd_l.configure(foreground=self.emphasize)
        self.tt_range_l.configure(foreground=self.emphasize)
        self.tt_total_l.configure(foreground=self.emphasize)

        # Summary data, column2, de-emphasize font color
        self.task_count_sumry_l.configure(foreground=self.deemphasize)
        self.ttmean_sumry_l.configure(foreground=self.deemphasize)
        self.ttsd_sumry_l.configure(foreground=self.deemphasize)
        self.ttrange_sumry_l.configure(foreground=self.deemphasize)
        self.ttsum_sumry_l.configure(foreground=self.deemphasize)

    def emphasize_sumry_data(self) -> None:
        """
        Switches font emphasis from Interval data to Summary data.
        Called from 'Summary data' button.
        """
        self.interval_t_l.config(foreground=self.deemphasize)
        self.summary_t_l.config(foreground=self.emphasize)

        # Interval data, column1, de-emphasize font color
        self.task_count_l.configure(foreground=self.deemphasize)
        self.tt_avg_l.configure(foreground=self.deemphasize)
        self.tt_sd_l.configure(foreground=self.deemphasize)
        self.tt_range_l.configure(foreground=self.deemphasize)
        self.tt_total_l.configure(foreground=self.deemphasize)

        # Summary data, column2, emphasize font color
        self.task_count_sumry_l.configure(foreground=self.share.highlight)
        self.ttmean_sumry_l.configure(foreground=self.share.highlight)
        self.ttsd_sumry_l.configure(foreground=self.emphasize)
        self.ttrange_sumry_l.configure(text=self.share.data['tt_range'].get(),
                                       foreground=self.emphasize)
        self.ttsum_sumry_l.configure(foreground=self.emphasize)

    def app_got_focus(self, focus_event) -> None:
        """Give menu bar headings normal color when app has focus.

        :param focus_event: Implicit event passed from .bind_all()
        """
        self.menubar.entryconfig("File", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("View", foreground='black', state=tk.NORMAL)
        self.menubar.entryconfig("Help", foreground='black', state=tk.NORMAL)
        self.view_button_style.configure('View.TButton', foreground='black',
                                         background='grey75')
        if self.share.setting['do_log'].get():
            self.share.viewlog_b.configure(style='View.TButton', state=tk.NORMAL)
        return focus_event

    def app_lost_focus(self, focus_event) -> None:
        """Give menu bar headings grey-out color when app looses focus.

        :param focus_event: Implicit event passed from .bind_all()
        """
        self.menubar.entryconfig("File", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("View", foreground='grey', state=tk.DISABLED)
        self.menubar.entryconfig("Help", foreground='grey', state=tk.DISABLED)
        self.view_button_style.configure('View.TButton', foreground='grey')
        self.share.viewlog_b.configure(style='View.TButton', state=tk.DISABLED)
        return focus_event


# ################## MVC Controller; is app mainloop ##################
class CountController(tk.Tk):
    """
    The Controller through which other MVC Count Classes can interact
    through the 'share' parameter.
    Based on https://stackoverflow.com/questions/32864610/.
    """

    def __init__(self):
        super().__init__()

        # Need window sizes to make room for multi-line notices,
        #    but not get minimized enough to exclude notices row.
        # Need OS-specific master window sizes b/c of different default font widths.
        if MY_OS == 'lin':
            self.minsize(580, 370)
            self.maxsize(780, 400)
        elif MY_OS == 'win':
            self.minsize(532, 380)
            self.maxsize(720, 400)
        elif MY_OS == 'dar':
            self.minsize(600, 390)
            self.maxsize(780, 425)

        self.winfo_toplevel()
        CountViewer(share=self)

    def defaultsettings(self) -> None:
        """
        Starting settings of: report interval, summary interval,
        counting limit, and log file option.
        """
        CountModeler(share=self).default_settings()

    def startdata(self) -> None:
        """
        Is called from Viewer.startup().
        """
        CountModeler(share=self).start_data()

    def intervaldata(self) -> None:
        """
        Is called from Viewer.start_threads().
        """
        CountModeler(share=self).interval_data()

    def taskstatenotices(self) -> None:
        """
        Is called from Viewer.start_threads().
        """
        CountModeler(share=self).notice_it()

    def logit(self, called_from) -> None:
        """Send data to log file.
        Is called from Viewer.start_threads()

        :param called_from: Either 'start', 'interval' or 'notice',
                            depending on type of data to be logged.
        """
        CountModeler(share=self).log_it(called_from)

    def info(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        """
        CountFyi(share=self).information()

    def compliment(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar and
        keybind. A silly diversion.
        """
        CountFyi(share=self).compliment_me()

    def about(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        """
        CountFyi(share=self).about()

    def filepaths(self) -> None:
        """Is called from Viewer.master_widgets(), Help menu bar.
        Toplevel window of full paths for program-generated files.
        """
        CountFyi(share=self).file_paths()


if __name__ == "__main__":
    parse_args()

    # Need to set up conditions to control multiple instances.
    _instance_msg = (f'\nNOTICE: {__program_name__} is already running from'
                     f' {Path.cwd()}. Exiting...\n')

    if MY_OS == 'win':
        _one_win = Instances.OneWinstance()
        # When a console displays for a PyInstaller Windows stand-alone,
        #   then need to leave console open long enough for user to
        #   read the exit message. Can skip this when out of Beta testing.
        if _one_win.already_running() and getattr(sys, 'frozen', False):
            print(_instance_msg)
            sleep(6)
            sys.exit(0)
        elif _one_win.already_running():
            sys.exit(_instance_msg)
    elif MY_OS in 'lin, dar':
        # NOTE: In Class Logs, path constants are different for stand-alone
        #   and Terminal executions, so both program types can use the
        #   log file option b/c they have different log file paths.
        # This also allows multiple instances of command line execution
        #   to run from different directories.
        lockfile_path = Path(Path.cwd(),
                             f'.{__program_name__}_lockfile').resolve()

        if getattr(sys, 'frozen', False):
            lockfile_path = Path(Path.home(),
                                 f'.{__program_name__}_lockfile').resolve()

        _file_handle = open(lockfile_path, 'w')
        # instances.file_lock() prints msg and exits program.
        Instances.file_lock(_file_handle, _instance_msg)

    # Now get things running....
    try:
        print(f'{__program_name__} now running...')
        app = CountController()
        app.title(f'Counting BOINC tasks on {gethostname()}')
        # Need absolute path when running stand-alone app from PyInstaller.
        img = tk.PhotoImage(
            file=Utils.absolute_path_to('images/count_icon_512.png'))
        app.iconphoto(True, img)
        app.mainloop()
    except KeyboardInterrupt:
        _interrupt_msg = (f"\n{datetime.now().strftime(LONG_STRFTIME)};"
                          " *** Keyboard interrupt by user ***\n")
        print(_interrupt_msg)
        logging.info(msg=_interrupt_msg)
    except Exception as unknown:
        print(f'\nAn unexpected error: {unknown}\n')
